module rec Glutinum.VSCode

open Fable.Core
open Fable.Core.JsInterop
open System

// You need to add Glutinum.Types NuGet package to your project
open Glutinum.Types.TypeScript

type RegExp = Text.RegularExpressions.Regex

type Iterable<'T> = Collections.Generic.IEnumerable<'T>
type AsyncIterable<'T> = class end

[<AbstractClass>]
[<Erase>]
type Exports =
    [<ImportAll("vscode")>]
    static member inline vscode
        with get () : vscode_.Exports =
            nativeOnly

module vscode_ =

    [<AbstractClass>]
    [<Erase>]
    type Exports =
        /// <summary>
        /// The version of the editor.
        /// </summary>
        [<Emit("$0.version")>]
        abstract member version: string
        /// <param name="line">
        /// A zero-based line value.
        /// </param>
        /// <param name="character">
        /// A zero-based character value.
        /// </param>
        [<Emit("new $0.Position($1...)")>]
        abstract member Position: line: float * character: float -> Position
        /// <summary>
        /// Create a new range from two positions. If <c>start</c> is not
        /// before or equal to <c>end</c>, the values will be swapped.
        /// </summary>
        /// <param name="start">
        /// A position.
        /// </param>
        /// <param name="end">
        /// A position.
        /// </param>
        [<Emit("new $0.Range($1...)")>]
        abstract member Range: start: Position * ``end``: Position -> Range
        /// <summary>
        /// Create a new range from number coordinates. It is a shorter equivalent of
        /// using <c>new Range(new Position(startLine, startCharacter), new Position(endLine, endCharacter))</c>
        /// </summary>
        /// <param name="startLine">
        /// A zero-based line value.
        /// </param>
        /// <param name="startCharacter">
        /// A zero-based character value.
        /// </param>
        /// <param name="endLine">
        /// A zero-based line value.
        /// </param>
        /// <param name="endCharacter">
        /// A zero-based character value.
        /// </param>
        [<Emit("new $0.Range($1...)")>]
        abstract member Range: startLine: float * startCharacter: float * endLine: float * endCharacter: float -> Range
        /// <summary>
        /// Create a selection from two positions.
        /// </summary>
        /// <param name="anchor">
        /// A position.
        /// </param>
        /// <param name="active">
        /// A position.
        /// </param>
        [<Emit("new $0.Selection($1...)")>]
        abstract member Selection: anchor: Position * active: Position -> Selection
        /// <summary>
        /// Create a selection from four coordinates.
        /// </summary>
        /// <param name="anchorLine">
        /// A zero-based line value.
        /// </param>
        /// <param name="anchorCharacter">
        /// A zero-based character value.
        /// </param>
        /// <param name="activeLine">
        /// A zero-based line value.
        /// </param>
        /// <param name="activeCharacter">
        /// A zero-based character value.
        /// </param>
        [<Emit("new $0.Selection($1...)")>]
        abstract member Selection: anchorLine: float * anchorCharacter: float * activeLine: float * activeCharacter: float -> Selection
        /// <summary>
        /// Creates a reference to a theme color.
        /// </summary>
        /// <param name="id">
        /// of the color. The available colors are listed in https://code.visualstudio.com/api/references/theme-color.
        /// </param>
        [<Emit("new $0.ThemeColor($1...)")>]
        abstract member ThemeColor: id: string -> ThemeColor
        /// <summary>
        /// Creates a reference to a theme icon.
        /// </summary>
        /// <param name="id">
        /// id of the icon. The available icons are listed in https://code.visualstudio.com/api/references/icons-in-labels#icon-listing.
        /// </param>
        /// <param name="color">
        /// optional <c>ThemeColor</c> for the icon. The color is currently only used in <see href="TreeItem">TreeItem</see>.
        /// </param>
        [<Emit("new $0.ThemeIcon($1...)")>]
        abstract member ThemeIcon: id: string * ?color: ThemeColor -> ThemeIcon
        /// <summary>
        /// Use the <c>file</c> and <c>parse</c> factory functions to create new <c>Uri</c> objects.
        /// </summary>
        [<Emit("new $0.Uri($1...)")>]
        abstract member Uri: scheme: string * authority: string * path: string * query: string * fragment: string -> Uri
        [<Emit("new $0.CancellationTokenSource($1...)")>]
        abstract member CancellationTokenSource: unit -> CancellationTokenSource
        /// <summary>
        /// Creates a new cancellation error.
        /// </summary>
        [<Emit("new $0.CancellationError($1...)")>]
        abstract member CancellationError: unit -> CancellationError
        /// <summary>
        /// Creates a new disposable that calls the provided function
        /// on dispose.
        ///
        /// *Note* that an asynchronous function is not awaited.
        /// </summary>
        /// <param name="callOnDispose">
        /// Function that disposes something.
        /// </param>
        [<Emit("new $0.Disposable($1...)")>]
        abstract member Disposable: callOnDispose: (unit -> obj) -> Disposable
        [<Emit("new $0.EventEmitter($1...)")>]
        abstract member EventEmitter<'T>: unit -> EventEmitter<'T>
        /// <summary>
        /// Creates a new relative pattern object with a base file path and pattern to match. This pattern
        /// will be matched on file paths relative to the base.
        ///
        /// Example:
        /// <c></c><c>ts
        /// const folder = vscode.workspace.workspaceFolders?.[0];
        /// if (folder) {
        ///
        ///   // Match any TypeScript file in the root of this workspace folder
        ///   const pattern1 = new vscode.RelativePattern(folder, '*.ts');
        ///
        ///   // Match any TypeScript file in </c>someFolder<c> inside this workspace folder
        ///   const pattern2 = new vscode.RelativePattern(folder, 'someFolder/*.ts');
        /// }
        /// </c><c></c>
        /// </summary>
        /// <param name="base">
        /// A base to which this pattern will be matched against relatively. It is recommended
        /// to pass in a <see href="WorkspaceFolder">workspace folder</see>" if the pattern should match inside the workspace.
        /// Otherwise, a uri or string should only be used if the pattern is for a file path outside the workspace.
        /// </param>
        /// <param name="pattern">
        /// A file glob pattern like <c>*.{ts,js}</c> that will be matched on paths relative to the base.
        /// </param>
        [<Emit("new $0.RelativePattern($1...)")>]
        abstract member RelativePattern: ``base``: U3<WorkspaceFolder, Uri, string> * pattern: string -> RelativePattern
        /// <summary>
        /// Private constructor, use static <c>CodeActionKind.XYZ</c> to derive from an existing code action kind.
        /// </summary>
        /// <param name="value">
        /// The value of the kind, such as <c>refactor.extract.function</c>.
        /// </param>
        [<Emit("new $0.CodeActionKind($1...)")>]
        abstract member CodeActionKind: value: string -> CodeActionKind
        /// <summary>
        /// Creates a new code action.
        ///
        /// A code action must have at least a <see href="CodeAction.titletitle">CodeAction.titletitle</see> and <see href="CodeAction.editedits">CodeAction.editedits</see>
        /// and/or a <see href="CodeAction.commandcommand">CodeAction.commandcommand</see>.
        /// </summary>
        /// <param name="title">
        /// The title of the code action.
        /// </param>
        /// <param name="kind">
        /// The kind of the code action.
        /// </param>
        [<Emit("new $0.CodeAction($1...)")>]
        abstract member CodeAction: title: string * ?kind: CodeActionKind -> CodeAction
        /// <summary>
        /// Creates a new code lens object.
        /// </summary>
        /// <param name="range">
        /// The range to which this code lens applies.
        /// </param>
        /// <param name="command">
        /// The command associated to this code lens.
        /// </param>
        [<Emit("new $0.CodeLens($1...)")>]
        abstract member CodeLens: range: Range * ?command: Command -> CodeLens
        /// <summary>
        /// Creates a new markdown string with the given value.
        /// </summary>
        /// <param name="value">
        /// Optional, initial value.
        /// </param>
        /// <param name="supportThemeIcons">
        /// Optional, Specifies whether <see href="ThemeIcon">ThemeIcons</see>" are supported within the {@linkcode MarkdownString }.
        /// </param>
        [<Emit("new $0.MarkdownString($1...)")>]
        abstract member MarkdownString: ?value: string * ?supportThemeIcons: bool -> MarkdownString
        /// <summary>
        /// Creates a new hover object.
        /// </summary>
        /// <param name="contents">
        /// The contents of the hover.
        /// </param>
        /// <param name="range">
        /// The range to which the hover applies.
        /// </param>
        [<Emit("new $0.Hover($1...)")>]
        abstract member Hover: contents: U3<MarkdownString, MarkedString, ResizeArray<U2<MarkdownString, MarkedString>>> * ?range: Range -> Hover
        /// <summary>
        /// Creates a new evaluatable expression object.
        /// </summary>
        /// <param name="range">
        /// The range in the underlying document from which the evaluatable expression is extracted.
        /// </param>
        /// <param name="expression">
        /// If specified overrides the extracted expression.
        /// </param>
        [<Emit("new $0.EvaluatableExpression($1...)")>]
        abstract member EvaluatableExpression: range: Range * ?expression: string -> EvaluatableExpression
        /// <summary>
        /// Creates a new InlineValueText object.
        /// </summary>
        /// <param name="range">
        /// The document line where to show the inline value.
        /// </param>
        /// <param name="text">
        /// The value to be shown for the line.
        /// </param>
        [<Emit("new $0.InlineValueText($1...)")>]
        abstract member InlineValueText: range: Range * text: string -> InlineValueText
        /// <summary>
        /// Creates a new InlineValueVariableLookup object.
        /// </summary>
        /// <param name="range">
        /// The document line where to show the inline value.
        /// </param>
        /// <param name="variableName">
        /// The name of the variable to look up.
        /// </param>
        /// <param name="caseSensitiveLookup">
        /// How to perform the lookup. If missing lookup is case sensitive.
        /// </param>
        [<Emit("new $0.InlineValueVariableLookup($1...)")>]
        abstract member InlineValueVariableLookup: range: Range * ?variableName: string * ?caseSensitiveLookup: bool -> InlineValueVariableLookup
        /// <summary>
        /// Creates a new InlineValueEvaluatableExpression object.
        /// </summary>
        /// <param name="range">
        /// The range in the underlying document from which the evaluatable expression is extracted.
        /// </param>
        /// <param name="expression">
        /// If specified overrides the extracted expression.
        /// </param>
        [<Emit("new $0.InlineValueEvaluatableExpression($1...)")>]
        abstract member InlineValueEvaluatableExpression: range: Range * ?expression: string -> InlineValueEvaluatableExpression
        /// <summary>
        /// Creates a new document highlight object.
        /// </summary>
        /// <param name="range">
        /// The range the highlight applies to.
        /// </param>
        /// <param name="kind">
        /// The highlight kind, default is <see href="DocumentHighlightKind.Text">text</see>".
        /// </param>
        [<Emit("new $0.DocumentHighlight($1...)")>]
        abstract member DocumentHighlight: range: Range * ?kind: DocumentHighlightKind -> DocumentHighlight
        /// <summary>
        /// Creates a new symbol information object.
        /// </summary>
        /// <param name="name">
        /// The name of the symbol.
        /// </param>
        /// <param name="kind">
        /// The kind of the symbol.
        /// </param>
        /// <param name="containerName">
        /// The name of the symbol containing the symbol.
        /// </param>
        /// <param name="location">
        /// The location of the symbol.
        /// </param>
        [<Emit("new $0.SymbolInformation($1...)")>]
        abstract member SymbolInformation: name: string * kind: SymbolKind * containerName: string * location: Location -> SymbolInformation
        /// <summary>
        /// Creates a new symbol information object.
        /// </summary>
        /// <param name="name">
        /// The name of the symbol.
        /// </param>
        /// <param name="kind">
        /// The kind of the symbol.
        /// </param>
        /// <param name="range">
        /// The range of the location of the symbol.
        /// </param>
        /// <param name="uri">
        /// The resource of the location of symbol, defaults to the current document.
        /// </param>
        /// <param name="containerName">
        /// The name of the symbol containing the symbol.
        /// </param>
        [<Emit("new $0.SymbolInformation($1...)"); Obsolete("Please use the constructor taking a {@link Location } object.")>]
        abstract member SymbolInformation: name: string * kind: SymbolKind * range: Range * ?uri: Uri * ?containerName: string -> SymbolInformation
        /// <summary>
        /// Creates a new document symbol.
        /// </summary>
        /// <param name="name">
        /// The name of the symbol.
        /// </param>
        /// <param name="detail">
        /// Details for the symbol.
        /// </param>
        /// <param name="kind">
        /// The kind of the symbol.
        /// </param>
        /// <param name="range">
        /// The full range of the symbol.
        /// </param>
        /// <param name="selectionRange">
        /// The range that should be reveal.
        /// </param>
        [<Emit("new $0.DocumentSymbol($1...)")>]
        abstract member DocumentSymbol: name: string * detail: string * kind: SymbolKind * range: Range * selectionRange: Range -> DocumentSymbol
        /// <summary>
        /// Create a new TextEdit.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <param name="newText">
        /// A string.
        /// </param>
        [<Emit("new $0.TextEdit($1...)")>]
        abstract member TextEdit: range: Range * newText: string -> TextEdit
        /// <summary>
        /// Create a new snippet edit.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <param name="snippet">
        /// A snippet string.
        /// </param>
        [<Emit("new $0.SnippetTextEdit($1...)")>]
        abstract member SnippetTextEdit: range: Range * snippet: SnippetString -> SnippetTextEdit
        /// <summary>
        /// Create a new notebook edit.
        /// </summary>
        /// <param name="range">
        /// A notebook range.
        /// </param>
        /// <param name="newCells">
        /// An array of new cell data.
        /// </param>
        [<Emit("new $0.NotebookEdit($1...)")>]
        abstract member NotebookEdit: range: NotebookRange * newCells: ResizeArray<NotebookCellData> -> NotebookEdit
        [<Emit("new $0.WorkspaceEdit($1...)")>]
        abstract member WorkspaceEdit: unit -> WorkspaceEdit
        /// <summary>
        /// Create a new snippet string.
        /// </summary>
        /// <param name="value">
        /// A snippet string.
        /// </param>
        [<Emit("new $0.SnippetString($1...)")>]
        abstract member SnippetString: ?value: string -> SnippetString
        /// <summary>
        /// Creates a semantic tokens legend.
        /// </summary>
        /// <param name="tokenTypes">
        /// An array of token types.
        /// </param>
        /// <param name="tokenModifiers">
        /// An array of token modifiers.
        /// </param>
        [<Emit("new $0.SemanticTokensLegend($1...)")>]
        abstract member SemanticTokensLegend: tokenTypes: ResizeArray<string> * ?tokenModifiers: ResizeArray<string> -> SemanticTokensLegend
        /// <summary>
        /// Creates a semantic tokens builder.
        /// </summary>
        /// <param name="legend">
        /// A semantic tokens legend.
        /// </param>
        [<Emit("new $0.SemanticTokensBuilder($1...)")>]
        abstract member SemanticTokensBuilder: ?legend: SemanticTokensLegend -> SemanticTokensBuilder
        /// <summary>
        /// Create new semantic tokens.
        /// </summary>
        /// <param name="data">
        /// Token data.
        /// </param>
        /// <param name="resultId">
        /// Result identifier.
        /// </param>
        [<Emit("new $0.SemanticTokens($1...)")>]
        abstract member SemanticTokens: data: JS.Uint32Array * ?resultId: string -> SemanticTokens
        /// <summary>
        /// Create new semantic tokens edits.
        /// </summary>
        /// <param name="edits">
        /// An array of semantic token edits
        /// </param>
        /// <param name="resultId">
        /// Result identifier.
        /// </param>
        [<Emit("new $0.SemanticTokensEdits($1...)")>]
        abstract member SemanticTokensEdits: edits: ResizeArray<SemanticTokensEdit> * ?resultId: string -> SemanticTokensEdits
        /// <summary>
        /// Create a semantic token edit.
        /// </summary>
        /// <param name="start">
        /// Start offset
        /// </param>
        /// <param name="deleteCount">
        /// Number of elements to remove.
        /// </param>
        /// <param name="data">
        /// Elements to insert
        /// </param>
        [<Emit("new $0.SemanticTokensEdit($1...)")>]
        abstract member SemanticTokensEdit: start: float * deleteCount: float * ?data: JS.Uint32Array -> SemanticTokensEdit
        /// <summary>
        /// Creates a new parameter information object.
        /// </summary>
        /// <param name="label">
        /// A label string or inclusive start and exclusive end offsets within its containing signature label.
        /// </param>
        /// <param name="documentation">
        /// A doc string.
        /// </param>
        [<Emit("new $0.ParameterInformation($1...)")>]
        abstract member ParameterInformation: label: U2<string, float * float> * ?documentation: U2<string, MarkdownString> -> ParameterInformation
        /// <summary>
        /// Creates a new signature information object.
        /// </summary>
        /// <param name="label">
        /// A label string.
        /// </param>
        /// <param name="documentation">
        /// A doc string.
        /// </param>
        [<Emit("new $0.SignatureInformation($1...)")>]
        abstract member SignatureInformation: label: string * ?documentation: U2<string, MarkdownString> -> SignatureInformation
        [<Emit("new $0.SignatureHelp($1...)")>]
        abstract member SignatureHelp: unit -> SignatureHelp
        /// <summary>
        /// Creates a new completion item.
        ///
        /// Completion items must have at least a <see href="CompletionItem.labellabel">CompletionItem.labellabel</see> which then
        /// will be used as insert text as well as for sorting and filtering.
        /// </summary>
        /// <param name="label">
        /// The label of the completion.
        /// </param>
        /// <param name="kind">
        /// The <see href="CompletionItemKind">kind</see>" of the completion.
        /// </param>
        [<Emit("new $0.CompletionItem($1...)")>]
        abstract member CompletionItem: label: U2<string, CompletionItemLabel> * ?kind: CompletionItemKind -> CompletionItem
        /// <summary>
        /// Creates a new completion list.
        /// </summary>
        /// <param name="items">
        /// The completion items.
        /// </param>
        /// <param name="isIncomplete">
        /// The list is not complete.
        /// </param>
        [<Emit("new $0.CompletionList($1...)")>]
        abstract member CompletionList<'T when 'T :> CompletionItem>: ?items: ResizeArray<'T> * ?isIncomplete: bool -> CompletionList<'T>
        /// <summary>
        /// Creates a new list of inline completion items.
        /// </summary>
        [<Emit("new $0.InlineCompletionList($1...)")>]
        abstract member InlineCompletionList: items: ResizeArray<InlineCompletionItem> -> InlineCompletionList
        /// <summary>
        /// Creates a new inline completion item.
        /// </summary>
        /// <param name="insertText">
        /// The text to replace the range with.
        /// </param>
        /// <param name="range">
        /// The range to replace. If not set, the word at the requested position will be used.
        /// </param>
        /// <param name="command">
        /// An optional <see href="Command">Command</see> that is executed *after* inserting this completion.
        /// </param>
        [<Emit("new $0.InlineCompletionItem($1...)")>]
        abstract member InlineCompletionItem: insertText: U2<string, SnippetString> * ?range: Range * ?command: Command -> InlineCompletionItem
        /// <summary>
        /// Creates a new document link.
        /// </summary>
        /// <param name="range">
        /// The range the document link applies to. Must not be empty.
        /// </param>
        /// <param name="target">
        /// The uri the document link points to.
        /// </param>
        [<Emit("new $0.DocumentLink($1...)")>]
        abstract member DocumentLink: range: Range * ?target: Uri -> DocumentLink
        /// <summary>
        /// Creates a new color instance.
        /// </summary>
        /// <param name="red">
        /// The red component.
        /// </param>
        /// <param name="green">
        /// The green component.
        /// </param>
        /// <param name="blue">
        /// The blue component.
        /// </param>
        /// <param name="alpha">
        /// The alpha component.
        /// </param>
        [<Emit("new $0.Color($1...)")>]
        abstract member Color: red: float * green: float * blue: float * alpha: float -> Color
        /// <summary>
        /// Creates a new color range.
        /// </summary>
        /// <param name="range">
        /// The range the color appears in. Must not be empty.
        /// </param>
        /// <param name="color">
        /// The value of the color.
        /// </param>
        [<Emit("new $0.ColorInformation($1...)")>]
        abstract member ColorInformation: range: Range * color: Color -> ColorInformation
        /// <summary>
        /// Creates a new color presentation.
        /// </summary>
        /// <param name="label">
        /// The label of this color presentation.
        /// </param>
        [<Emit("new $0.ColorPresentation($1...)")>]
        abstract member ColorPresentation: label: string -> ColorPresentation
        /// <summary>
        /// Creates a new inlay hint label part.
        /// </summary>
        /// <param name="value">
        /// The value of the part.
        /// </param>
        [<Emit("new $0.InlayHintLabelPart($1...)")>]
        abstract member InlayHintLabelPart: value: string -> InlayHintLabelPart
        /// <summary>
        /// Creates a new inlay hint.
        /// </summary>
        /// <param name="position">
        /// The position of the hint.
        /// </param>
        /// <param name="label">
        /// The label of the hint.
        /// </param>
        /// <param name="kind">
        /// The <see href="InlayHintKind">kind</see>" of the hint.
        /// </param>
        [<Emit("new $0.InlayHint($1...)")>]
        abstract member InlayHint: position: Position * label: U2<string, ResizeArray<InlayHintLabelPart>> * ?kind: InlayHintKind -> InlayHint
        /// <summary>
        /// Creates a new folding range.
        /// </summary>
        /// <param name="start">
        /// The start line of the folded range.
        /// </param>
        /// <param name="end">
        /// The end line of the folded range.
        /// </param>
        /// <param name="kind">
        /// The kind of the folding range.
        /// </param>
        [<Emit("new $0.FoldingRange($1...)")>]
        abstract member FoldingRange: start: float * ``end``: float * ?kind: FoldingRangeKind -> FoldingRange
        /// <summary>
        /// Creates a new selection range.
        /// </summary>
        /// <param name="range">
        /// The range of the selection range.
        /// </param>
        /// <param name="parent">
        /// The parent of the selection range.
        /// </param>
        [<Emit("new $0.SelectionRange($1...)")>]
        abstract member SelectionRange: range: Range * ?parent: SelectionRange -> SelectionRange
        /// <summary>
        /// Creates a new call hierarchy item.
        /// </summary>
        [<Emit("new $0.CallHierarchyItem($1...)")>]
        abstract member CallHierarchyItem: kind: SymbolKind * name: string * detail: string * uri: Uri * range: Range * selectionRange: Range -> CallHierarchyItem
        /// <summary>
        /// Create a new call object.
        /// </summary>
        /// <param name="item">
        /// The item making the call.
        /// </param>
        /// <param name="fromRanges">
        /// The ranges at which the calls appear.
        /// </param>
        [<Emit("new $0.CallHierarchyIncomingCall($1...)")>]
        abstract member CallHierarchyIncomingCall: item: CallHierarchyItem * fromRanges: ResizeArray<Range> -> CallHierarchyIncomingCall
        /// <summary>
        /// Create a new call object.
        /// </summary>
        /// <param name="item">
        /// The item being called
        /// </param>
        /// <param name="fromRanges">
        /// The ranges at which the calls appear.
        /// </param>
        [<Emit("new $0.CallHierarchyOutgoingCall($1...)")>]
        abstract member CallHierarchyOutgoingCall: item: CallHierarchyItem * fromRanges: ResizeArray<Range> -> CallHierarchyOutgoingCall
        /// <summary>
        /// Creates a new type hierarchy item.
        /// </summary>
        /// <param name="kind">
        /// The kind of the item.
        /// </param>
        /// <param name="name">
        /// The name of the item.
        /// </param>
        /// <param name="detail">
        /// The details of the item.
        /// </param>
        /// <param name="uri">
        /// The Uri of the item.
        /// </param>
        /// <param name="range">
        /// The whole range of the item.
        /// </param>
        /// <param name="selectionRange">
        /// The selection range of the item.
        /// </param>
        [<Emit("new $0.TypeHierarchyItem($1...)")>]
        abstract member TypeHierarchyItem: kind: SymbolKind * name: string * detail: string * uri: Uri * range: Range * selectionRange: Range -> TypeHierarchyItem
        /// <summary>
        /// Create a new linked editing ranges object.
        /// </summary>
        /// <param name="ranges">
        /// A list of ranges that can be edited together
        /// </param>
        /// <param name="wordPattern">
        /// An optional word pattern that describes valid contents for the given ranges
        /// </param>
        [<Emit("new $0.LinkedEditingRanges($1...)")>]
        abstract member LinkedEditingRanges: ranges: ResizeArray<Range> * ?wordPattern: RegExp -> LinkedEditingRanges
        /// <summary>
        /// Use {@linkcode DocumentDropOrPasteEditKind.Empty} instead.
        /// </summary>
        [<Emit("new $0.DocumentDropOrPasteEditKind($1...)")>]
        abstract member DocumentDropOrPasteEditKind: value: string -> DocumentDropOrPasteEditKind
        /// <param name="insertText">
        /// The text or snippet to insert at the drop location.
        /// </param>
        /// <param name="title">
        /// Human readable label that describes the edit.
        /// </param>
        /// <param name="kind">
        /// <see href="DocumentDropOrPasteEditKind">Kind</see>" of the edit.
        /// </param>
        [<Emit("new $0.DocumentDropEdit($1...)")>]
        abstract member DocumentDropEdit: insertText: U2<string, SnippetString> * ?title: string * ?kind: DocumentDropOrPasteEditKind -> DocumentDropEdit
        /// <summary>
        /// Create a new paste edit.
        /// </summary>
        /// <param name="insertText">
        /// The text or snippet to insert at the pasted locations.
        /// </param>
        /// <param name="title">
        /// Human readable label that describes the edit.
        /// </param>
        /// <param name="kind">
        /// <see href="DocumentDropOrPasteEditKind">Kind</see>" of the edit.
        /// </param>
        [<Emit("new $0.DocumentPasteEdit($1...)")>]
        abstract member DocumentPasteEdit: insertText: U2<string, SnippetString> * title: string * kind: DocumentDropOrPasteEditKind -> DocumentPasteEdit
        /// <summary>
        /// Creates a new location object.
        /// </summary>
        /// <param name="uri">
        /// The resource identifier.
        /// </param>
        /// <param name="rangeOrPosition">
        /// The range or position. Positions will be converted to an empty range.
        /// </param>
        [<Emit("new $0.Location($1...)")>]
        abstract member Location: uri: Uri * rangeOrPosition: U2<Range, Position> -> Location
        /// <summary>
        /// Creates a new related diagnostic information object.
        /// </summary>
        /// <param name="location">
        /// The location.
        /// </param>
        /// <param name="message">
        /// The message.
        /// </param>
        [<Emit("new $0.DiagnosticRelatedInformation($1...)")>]
        abstract member DiagnosticRelatedInformation: location: Location * message: string -> DiagnosticRelatedInformation
        /// <summary>
        /// Creates a new diagnostic object.
        /// </summary>
        /// <param name="range">
        /// The range to which this diagnostic applies.
        /// </param>
        /// <param name="message">
        /// The human-readable message.
        /// </param>
        /// <param name="severity">
        /// The severity, default is <see href="DiagnosticSeverity.Error">error</see>".
        /// </param>
        [<Emit("new $0.Diagnostic($1...)")>]
        abstract member Diagnostic: range: Range * message: string * ?severity: DiagnosticSeverity -> Diagnostic
        /// <summary>
        /// Creates a new terminal link.
        /// </summary>
        /// <param name="startIndex">
        /// The start index of the link on <see href="TerminalLinkContext.line">TerminalLinkContext.line</see>.
        /// </param>
        /// <param name="length">
        /// The length of the link on <see href="TerminalLinkContext.line">TerminalLinkContext.line</see>.
        /// </param>
        /// <param name="tooltip">
        /// The tooltip text when you hover over this link.
        ///
        /// If a tooltip is provided, is will be displayed in a string that includes instructions on
        /// how to trigger the link, such as <c>{0} (ctrl + click)</c>. The specific instructions vary
        /// depending on OS, user settings, and localization.
        /// </param>
        [<Emit("new $0.TerminalLink($1...)")>]
        abstract member TerminalLink: startIndex: float * length: float * ?tooltip: string -> TerminalLink
        /// <summary>
        /// Creates a new terminal profile.
        /// </summary>
        /// <param name="options">
        /// The options that the terminal will launch with.
        /// </param>
        [<Emit("new $0.TerminalProfile($1...)")>]
        abstract member TerminalProfile: options: U2<TerminalOptions, ExtensionTerminalOptions> -> TerminalProfile
        /// <summary>
        /// Creates a new decoration.
        /// </summary>
        /// <param name="badge">
        /// A letter that represents the decoration.
        /// </param>
        /// <param name="tooltip">
        /// The tooltip of the decoration.
        /// </param>
        /// <param name="color">
        /// The color of the decoration.
        /// </param>
        [<Emit("new $0.FileDecoration($1...)")>]
        abstract member FileDecoration: ?badge: string * ?tooltip: string * ?color: ThemeColor -> FileDecoration
        /// <summary>
        /// Private constructor
        /// </summary>
        /// <param name="id">
        /// Identifier of a task group.
        /// </param>
        /// <param name="label">
        /// The human-readable name of a task group.
        /// </param>
        [<Emit("new $0.TaskGroup($1...)")>]
        abstract member TaskGroup: id: string * label: string -> TaskGroup
        /// <summary>
        /// Creates a process execution.
        /// </summary>
        /// <param name="process">
        /// The process to start.
        /// </param>
        /// <param name="options">
        /// Optional options for the started process.
        /// </param>
        [<Emit("new $0.ProcessExecution($1...)")>]
        abstract member ProcessExecution: ``process``: string * ?options: ProcessExecutionOptions -> ProcessExecution
        /// <summary>
        /// Creates a process execution.
        /// </summary>
        /// <param name="process">
        /// The process to start.
        /// </param>
        /// <param name="args">
        /// Arguments to be passed to the process.
        /// </param>
        /// <param name="options">
        /// Optional options for the started process.
        /// </param>
        [<Emit("new $0.ProcessExecution($1...)")>]
        abstract member ProcessExecution: ``process``: string * args: ResizeArray<string> * ?options: ProcessExecutionOptions -> ProcessExecution
        /// <summary>
        /// Creates a shell execution with a full command line.
        /// </summary>
        /// <param name="commandLine">
        /// The command line to execute.
        /// </param>
        /// <param name="options">
        /// Optional options for the started the shell.
        /// </param>
        [<Emit("new $0.ShellExecution($1...)")>]
        abstract member ShellExecution: commandLine: string * ?options: ShellExecutionOptions -> ShellExecution
        /// <summary>
        /// Creates a shell execution with a command and arguments. For the real execution the editor will
        /// construct a command line from the command and the arguments. This is subject to interpretation
        /// especially when it comes to quoting. If full control over the command line is needed please
        /// use the constructor that creates a <c>ShellExecution</c> with the full command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute.
        /// </param>
        /// <param name="args">
        /// The command arguments.
        /// </param>
        /// <param name="options">
        /// Optional options for the started the shell.
        /// </param>
        [<Emit("new $0.ShellExecution($1...)")>]
        abstract member ShellExecution: command: U2<string, ShellQuotedString> * args: ResizeArray<U2<string, ShellQuotedString>> * ?options: ShellExecutionOptions -> ShellExecution
        /// <summary>
        /// Constructs a CustomExecution task object. The callback will be executed when the task is run, at which point the
        /// extension should return the Pseudoterminal it will "run in". The task should wait to do further execution until
        /// <see href="Pseudoterminal.open">Pseudoterminal.open</see> is called. Task cancellation should be handled using
        /// <see href="Pseudoterminal.close">Pseudoterminal.close</see>. When the task is complete fire
        /// <see href="Pseudoterminal.onDidClose">Pseudoterminal.onDidClose</see>.
        /// </summary>
        /// <param name="callback">
        /// The callback that will be called when the task is started by a user. Any ${} style variables that
        /// were in the task definition will be resolved and passed into the callback as <c>resolvedDefinition</c>.
        /// </param>
        [<Emit("new $0.CustomExecution($1...)")>]
        abstract member CustomExecution: callback: (TaskDefinition -> Thenable<Pseudoterminal>) -> CustomExecution
        /// <summary>
        /// Creates a new task.
        /// </summary>
        /// <param name="taskDefinition">
        /// The task definition as defined in the taskDefinitions extension point.
        /// </param>
        /// <param name="scope">
        /// Specifies the task's scope. It is either a global or a workspace task or a task for a specific workspace folder. Global tasks are currently not supported.
        /// </param>
        /// <param name="name">
        /// The task's name. Is presented in the user interface.
        /// </param>
        /// <param name="source">
        /// The task's source (e.g. 'gulp', 'npm', ...). Is presented in the user interface.
        /// </param>
        /// <param name="execution">
        /// The process or shell execution.
        /// </param>
        /// <param name="problemMatchers">
        /// the names of problem matchers to use, like '$tsc'
        /// or '$eslint'. Problem matchers can be contributed by an extension using
        /// the <c>problemMatchers</c> extension point.
        /// </param>
        [<Emit("new $0.Task($1...)")>]
        abstract member Task: taskDefinition: TaskDefinition * scope: U3<WorkspaceFolder, TaskScope, TaskScope> * name: string * source: string * ?execution: U3<ProcessExecution, ShellExecution, CustomExecution> * ?problemMatchers: U2<string, ResizeArray<string>> -> Task
        /// <summary>
        /// Creates a new task.
        /// </summary>
        /// <param name="taskDefinition">
        /// The task definition as defined in the taskDefinitions extension point.
        /// </param>
        /// <param name="name">
        /// The task's name. Is presented in the user interface.
        /// </param>
        /// <param name="source">
        /// The task's source (e.g. 'gulp', 'npm', ...). Is presented in the user interface.
        /// </param>
        /// <param name="execution">
        /// The process or shell execution.
        /// </param>
        /// <param name="problemMatchers">
        /// the names of problem matchers to use, like '$tsc'
        /// or '$eslint'. Problem matchers can be contributed by an extension using
        /// the <c>problemMatchers</c> extension point.
        /// </param>
        [<Emit("new $0.Task($1...)"); Obsolete("Use the new constructors that allow specifying a scope for the task.")>]
        abstract member Task: taskDefinition: TaskDefinition * name: string * source: string * ?execution: U2<ProcessExecution, ShellExecution> * ?problemMatchers: U2<string, ResizeArray<string>> -> Task
        /// <summary>
        /// Creates a new filesystem error.
        /// </summary>
        /// <param name="messageOrUri">
        /// Message or uri.
        /// </param>
        [<Emit("new $0.FileSystemError($1...)")>]
        abstract member FileSystemError: ?messageOrUri: U2<string, Uri> -> FileSystemError
        /// <param name="value">
        /// Custom data stored on this item. Can be retrieved using {@linkcode DataTransferItem.value }.
        /// </param>
        [<Emit("new $0.DataTransferItem($1...)")>]
        abstract member DataTransferItem: value: obj -> DataTransferItem
        [<Emit("new $0.DataTransfer($1...)")>]
        abstract member DataTransfer: unit -> DataTransfer
        /// <param name="label">
        /// A human-readable string describing this item
        /// </param>
        /// <param name="collapsibleState">
        /// <see href="TreeItemCollapsibleState">TreeItemCollapsibleState</see> of the tree item. Default is <see href="TreeItemCollapsibleState.None">TreeItemCollapsibleState.None</see>
        /// </param>
        [<Emit("new $0.TreeItem($1...)")>]
        abstract member TreeItem: label: U2<string, TreeItemLabel> * ?collapsibleState: TreeItemCollapsibleState -> TreeItem
        /// <param name="resourceUri">
        /// The <see href="Uri">Uri</see> of the resource representing this item.
        /// </param>
        /// <param name="collapsibleState">
        /// <see href="TreeItemCollapsibleState">TreeItemCollapsibleState</see> of the tree item. Default is <see href="TreeItemCollapsibleState.None">TreeItemCollapsibleState.None</see>
        /// </param>
        [<Emit("new $0.TreeItem($1...)")>]
        abstract member TreeItem: resourceUri: Uri * ?collapsibleState: TreeItemCollapsibleState -> TreeItem
        [<Emit("new $0.QuickInputButtons($1...)")>]
        abstract member QuickInputButtons: unit -> QuickInputButtons
        /// <summary>
        /// Create a new notebook range. If <c>start</c> is not
        /// before or equal to <c>end</c>, the values will be swapped.
        /// </summary>
        /// <param name="start">
        /// start index
        /// </param>
        /// <param name="end">
        /// end index.
        /// </param>
        [<Emit("new $0.NotebookRange($1...)")>]
        abstract member NotebookRange: start: float * ``end``: float -> NotebookRange
        /// <summary>
        /// Create a new notebook cell output item.
        /// </summary>
        /// <param name="data">
        /// The value of the output item.
        /// </param>
        /// <param name="mime">
        /// The mime type of the output item.
        /// </param>
        [<Emit("new $0.NotebookCellOutputItem($1...)")>]
        abstract member NotebookCellOutputItem: data: JS.Uint8Array * mime: string -> NotebookCellOutputItem
        /// <summary>
        /// Create new notebook output.
        /// </summary>
        /// <param name="items">
        /// Notebook output items.
        /// </param>
        /// <param name="metadata">
        /// Optional metadata.
        /// </param>
        [<Emit("new $0.NotebookCellOutput($1...)")>]
        abstract member NotebookCellOutput: items: ResizeArray<NotebookCellOutputItem> * ?metadata: Exports.NotebookCellOutput.metadata -> NotebookCellOutput
        /// <summary>
        /// Create new cell data. Minimal cell data specifies its kind, its source value, and the
        /// language identifier of its source.
        /// </summary>
        /// <param name="kind">
        /// The kind.
        /// </param>
        /// <param name="value">
        /// The source value.
        /// </param>
        /// <param name="languageId">
        /// The language identifier of the source value.
        /// </param>
        [<Emit("new $0.NotebookCellData($1...)")>]
        abstract member NotebookCellData: kind: NotebookCellKind * value: string * languageId: string -> NotebookCellData
        /// <summary>
        /// Create new notebook data.
        /// </summary>
        /// <param name="cells">
        /// An array of cell data.
        /// </param>
        [<Emit("new $0.NotebookData($1...)")>]
        abstract member NotebookData: cells: ResizeArray<NotebookCellData> -> NotebookData
        /// <summary>
        /// Creates a new NotebookCellStatusBarItem.
        /// </summary>
        /// <param name="text">
        /// The text to show for the item.
        /// </param>
        /// <param name="alignment">
        /// Whether the item is aligned to the left or right.
        /// </param>
        [<Emit("new $0.NotebookCellStatusBarItem($1...)")>]
        abstract member NotebookCellStatusBarItem: text: string * alignment: NotebookCellStatusBarAlignment -> NotebookCellStatusBarItem
        /// <summary>
        /// Creates a description for a debug adapter based on an executable program.
        /// </summary>
        /// <param name="command">
        /// The command or executable path that implements the debug adapter.
        /// </param>
        /// <param name="args">
        /// Optional arguments to be passed to the command or executable.
        /// </param>
        /// <param name="options">
        /// Optional options to be used when starting the command or executable.
        /// </param>
        [<Emit("new $0.DebugAdapterExecutable($1...)")>]
        abstract member DebugAdapterExecutable: command: string * ?args: ResizeArray<string> * ?options: DebugAdapterExecutableOptions -> DebugAdapterExecutable
        /// <summary>
        /// Create a description for a debug adapter running as a socket based server.
        /// </summary>
        [<Emit("new $0.DebugAdapterServer($1...)")>]
        abstract member DebugAdapterServer: port: float * ?host: string -> DebugAdapterServer
        /// <summary>
        /// Create a description for a debug adapter running as a Named Pipe (on Windows)/UNIX Domain Socket (on non-Windows) based server.
        /// </summary>
        [<Emit("new $0.DebugAdapterNamedPipeServer($1...)")>]
        abstract member DebugAdapterNamedPipeServer: path: string -> DebugAdapterNamedPipeServer
        /// <summary>
        /// Create a descriptor for an inline implementation of a debug adapter.
        /// </summary>
        [<Emit("new $0.DebugAdapterInlineImplementation($1...)")>]
        abstract member DebugAdapterInlineImplementation: implementation: DebugAdapter -> DebugAdapterInlineImplementation
        /// <summary>
        /// Creates a new breakpoint
        /// </summary>
        /// <param name="enabled">
        /// Is breakpoint enabled.
        /// </param>
        /// <param name="condition">
        /// Expression for conditional breakpoints
        /// </param>
        /// <param name="hitCondition">
        /// Expression that controls how many hits of the breakpoint are ignored
        /// </param>
        /// <param name="logMessage">
        /// Log message to display when breakpoint is hit
        /// </param>
        [<Emit("new $0.Breakpoint($1...)")>]
        abstract member Breakpoint: ?enabled: bool * ?condition: string * ?hitCondition: string * ?logMessage: string -> Breakpoint
        /// <summary>
        /// Create a new breakpoint for a source location.
        /// </summary>
        [<Emit("new $0.SourceBreakpoint($1...)")>]
        abstract member SourceBreakpoint: location: Location * ?enabled: bool * ?condition: string * ?hitCondition: string * ?logMessage: string -> SourceBreakpoint
        /// <summary>
        /// Create a new function breakpoint.
        /// </summary>
        [<Emit("new $0.FunctionBreakpoint($1...)")>]
        abstract member FunctionBreakpoint: functionName: string * ?enabled: bool * ?condition: string * ?hitCondition: string * ?logMessage: string -> FunctionBreakpoint
        [<Emit("new $0.DebugThread($1...)")>]
        abstract member DebugThread: session: DebugSession * threadId: float -> DebugThread
        [<Emit("new $0.DebugStackFrame($1...)")>]
        abstract member DebugStackFrame: session: DebugSession * threadId: float * frameId: float -> DebugStackFrame
        /// <summary>
        /// Creates a new TestTag instance.
        /// </summary>
        /// <param name="id">
        /// ID of the test tag.
        /// </param>
        [<Emit("new $0.TestTag($1...)")>]
        abstract member TestTag: id: string -> TestTag
        /// <param name="include">
        /// Array of specific tests to run, or undefined to run all tests
        /// </param>
        /// <param name="exclude">
        /// An array of tests to exclude from the run.
        /// </param>
        /// <param name="profile">
        /// The run profile used for this request.
        /// </param>
        /// <param name="continuous">
        /// Whether to run tests continuously as source changes.
        /// </param>
        /// <param name="preserveFocus">
        /// Whether to preserve the user's focus when the run is started
        /// </param>
        [<Emit("new $0.TestRunRequest($1...)")>]
        abstract member TestRunRequest: ?``include``: ReadonlyArray<TestItem> * ?exclude: ReadonlyArray<TestItem> * ?profile: TestRunProfile * ?continuous: bool * ?preserveFocus: bool -> TestRunRequest
        /// <param name="label">
        /// The name of the stack frame
        /// </param>
        /// <param name="file">
        /// The file URI of the stack frame
        /// </param>
        /// <param name="position">
        /// The position of the stack frame within the file
        /// </param>
        [<Emit("new $0.TestMessageStackFrame($1...)")>]
        abstract member TestMessageStackFrame: label: string * ?uri: Uri * ?position: Position -> TestMessageStackFrame
        /// <summary>
        /// Creates a new TestMessage instance.
        /// </summary>
        /// <param name="message">
        /// The message to show to the user.
        /// </param>
        [<Emit("new $0.TestMessage($1...)")>]
        abstract member TestMessage: message: U2<string, MarkdownString> -> TestMessage
        /// <param name="covered">
        /// Value for <see href="TestCoverageCount.covered">TestCoverageCount.covered</see>
        /// </param>
        /// <param name="total">
        /// Value for <see href="TestCoverageCount.total">TestCoverageCount.total</see>
        /// </param>
        [<Emit("new $0.TestCoverageCount($1...)")>]
        abstract member TestCoverageCount: covered: float * total: float -> TestCoverageCount
        /// <param name="uri">
        /// Covered file URI
        /// </param>
        /// <param name="statementCoverage">
        /// Statement coverage information. If the reporter
        /// does not provide statement coverage information, this can instead be
        /// used to represent line coverage.
        /// </param>
        /// <param name="branchCoverage">
        /// Branch coverage information
        /// </param>
        /// <param name="declarationCoverage">
        /// Declaration coverage information
        /// </param>
        /// <param name="includesTests">
        /// Test cases included in this coverage report, see <see href="FileCoverage.includesTests">FileCoverage.includesTests</see>
        /// </param>
        [<Emit("new $0.FileCoverage($1...)")>]
        abstract member FileCoverage: uri: Uri * statementCoverage: TestCoverageCount * ?branchCoverage: TestCoverageCount * ?declarationCoverage: TestCoverageCount * ?includesTests: ResizeArray<TestItem> -> FileCoverage
        /// <param name="location">
        /// The statement position.
        /// </param>
        /// <param name="executed">
        /// The number of times this statement was executed, or a
        /// boolean indicating  whether it was executed if the exact count is
        /// unknown. If zero or false, the statement will be marked as un-covered.
        /// </param>
        /// <param name="branches">
        /// Coverage from branches of this line.  If it's not a
        /// conditional, this should be omitted.
        /// </param>
        [<Emit("new $0.StatementCoverage($1...)")>]
        abstract member StatementCoverage: executed: U2<float, bool> * location: U2<Position, Range> * ?branches: ResizeArray<BranchCoverage> -> StatementCoverage
        /// <param name="executed">
        /// The number of times this branch was executed, or a
        /// boolean indicating  whether it was executed if the exact count is
        /// unknown. If zero or false, the branch will be marked as un-covered.
        /// </param>
        /// <param name="location">
        /// The branch position.
        /// </param>
        [<Emit("new $0.BranchCoverage($1...)")>]
        abstract member BranchCoverage: executed: U2<float, bool> * ?location: U2<Position, Range> * ?label: string -> BranchCoverage
        /// <param name="executed">
        /// The number of times this declaration was executed, or a
        /// boolean indicating  whether it was executed if the exact count is
        /// unknown. If zero or false, the declaration will be marked as un-covered.
        /// </param>
        /// <param name="location">
        /// The declaration position.
        /// </param>
        [<Emit("new $0.DeclarationCoverage($1...)")>]
        abstract member DeclarationCoverage: name: string * executed: U2<float, bool> * location: U2<Position, Range> -> DeclarationCoverage
        /// <summary>
        /// Constructs a text tab input with the given URI.
        /// </summary>
        /// <param name="uri">
        /// The URI of the tab.
        /// </param>
        [<Emit("new $0.TabInputText($1...)")>]
        abstract member TabInputText: uri: Uri -> TabInputText
        /// <summary>
        /// Constructs a new text diff tab input with the given URIs.
        /// </summary>
        /// <param name="original">
        /// The uri of the original text resource.
        /// </param>
        /// <param name="modified">
        /// The uri of the modified text resource.
        /// </param>
        [<Emit("new $0.TabInputTextDiff($1...)")>]
        abstract member TabInputTextDiff: original: Uri * modified: Uri -> TabInputTextDiff
        /// <summary>
        /// Constructs a custom editor tab input.
        /// </summary>
        /// <param name="uri">
        /// The uri of the tab.
        /// </param>
        /// <param name="viewType">
        /// The viewtype of the custom editor.
        /// </param>
        [<Emit("new $0.TabInputCustom($1...)")>]
        abstract member TabInputCustom: uri: Uri * viewType: string -> TabInputCustom
        /// <summary>
        /// Constructs a webview tab input with the given view type.
        /// </summary>
        /// <param name="viewType">
        /// The type of webview. Maps to {@linkcode WebviewPanel.viewType WebviewPanel's viewType}
        /// </param>
        [<Emit("new $0.TabInputWebview($1...)")>]
        abstract member TabInputWebview: viewType: string -> TabInputWebview
        /// <summary>
        /// Constructs a new tab input for a notebook.
        /// </summary>
        /// <param name="uri">
        /// The uri of the notebook.
        /// </param>
        /// <param name="notebookType">
        /// The type of notebook. Maps to {@linkcode NotebookDocument.notebookType NotebookDocuments's notebookType}
        /// </param>
        [<Emit("new $0.TabInputNotebook($1...)")>]
        abstract member TabInputNotebook: uri: Uri * notebookType: string -> TabInputNotebook
        /// <summary>
        /// Constructs a notebook diff tab input.
        /// </summary>
        /// <param name="original">
        /// The uri of the original unmodified notebook.
        /// </param>
        /// <param name="modified">
        /// The uri of the modified notebook.
        /// </param>
        /// <param name="notebookType">
        /// The type of notebook. Maps to {@linkcode NotebookDocument.notebookType NotebookDocuments's notebookType}
        /// </param>
        [<Emit("new $0.TabInputNotebookDiff($1...)")>]
        abstract member TabInputNotebookDiff: original: Uri * modified: Uri * notebookType: string -> TabInputNotebookDiff
        /// <summary>
        /// Constructs a terminal tab input.
        /// </summary>
        [<Emit("new $0.TabInputTerminal($1...)")>]
        abstract member TabInputTerminal: unit -> TabInputTerminal
        /// <summary>
        /// Creates a new telemetry trusted value.
        /// </summary>
        /// <param name="value">
        /// A value to trust
        /// </param>
        [<Emit("new $0.TelemetryTrustedValue($1...)")>]
        abstract member TelemetryTrustedValue<'T>: value: 'T -> TelemetryTrustedValue<'T>
        [<Emit("new $0.ChatRequestTurn($1...)")>]
        abstract member ChatRequestTurn: prompt: string * command: string option * references: ResizeArray<ChatPromptReference> * participant: string * toolReferences: ResizeArray<ChatLanguageModelToolReference> -> ChatRequestTurn
        [<Emit("new $0.ChatResponseTurn($1...)")>]
        abstract member ChatResponseTurn: response: ReadonlyArray<U4<ChatResponseMarkdownPart, ChatResponseFileTreePart, ChatResponseAnchorPart, ChatResponseCommandButtonPart>> * result: ChatResult * participant: string -> ChatResponseTurn
        /// <summary>
        /// Create a new ChatResponseMarkdownPart.
        /// </summary>
        /// <param name="value">
        /// A markdown string or a string that should be interpreted as markdown. The boolean form of <see href="MarkdownString.isTrusted">MarkdownString.isTrusted</see> is NOT supported.
        /// </param>
        [<Emit("new $0.ChatResponseMarkdownPart($1...)")>]
        abstract member ChatResponseMarkdownPart: value: U2<string, MarkdownString> -> ChatResponseMarkdownPart
        /// <summary>
        /// Create a new ChatResponseFileTreePart.
        /// </summary>
        /// <param name="value">
        /// File tree data.
        /// </param>
        /// <param name="baseUri">
        /// The base uri to which this file tree is relative.
        /// </param>
        [<Emit("new $0.ChatResponseFileTreePart($1...)")>]
        abstract member ChatResponseFileTreePart: value: ResizeArray<ChatResponseFileTree> * baseUri: Uri -> ChatResponseFileTreePart
        /// <summary>
        /// Create a new ChatResponseAnchorPart.
        /// </summary>
        /// <param name="value">
        /// A uri or location.
        /// </param>
        /// <param name="title">
        /// An optional title that is rendered with value.
        /// </param>
        [<Emit("new $0.ChatResponseAnchorPart($1...)")>]
        abstract member ChatResponseAnchorPart: value: U2<Uri, Location> * ?title: string -> ChatResponseAnchorPart
        /// <summary>
        /// Create a new ChatResponseProgressPart.
        /// </summary>
        /// <param name="value">
        /// A progress message
        /// </param>
        [<Emit("new $0.ChatResponseProgressPart($1...)")>]
        abstract member ChatResponseProgressPart: value: string -> ChatResponseProgressPart
        /// <summary>
        /// Create a new ChatResponseReferencePart.
        /// </summary>
        /// <param name="value">
        /// A uri or location
        /// </param>
        /// <param name="iconPath">
        /// Icon for the reference shown in UI
        /// </param>
        [<Emit("new $0.ChatResponseReferencePart($1...)")>]
        abstract member ChatResponseReferencePart: value: U2<Uri, Location> * ?iconPath: IconPath -> ChatResponseReferencePart
        /// <summary>
        /// Create a new ChatResponseCommandButtonPart.
        /// </summary>
        /// <param name="value">
        /// A Command that will be executed when the button is clicked.
        /// </param>
        [<Emit("new $0.ChatResponseCommandButtonPart($1...)")>]
        abstract member ChatResponseCommandButtonPart: value: Command -> ChatResponseCommandButtonPart
        /// <summary>
        /// Create a new user message.
        /// </summary>
        /// <param name="role">
        /// The role of the message.
        /// </param>
        /// <param name="content">
        /// The content of the message.
        /// </param>
        /// <param name="name">
        /// The optional name of a user for the message.
        /// </param>
        [<Emit("new $0.LanguageModelChatMessage($1...)")>]
        abstract member LanguageModelChatMessage: role: LanguageModelChatMessageRole * content: U2<string, ResizeArray<LanguageModelInputPart>> * ?name: string -> LanguageModelChatMessage
        [<Emit("new $0.LanguageModelError($1...)")>]
        abstract member LanguageModelError: unit -> LanguageModelError
        /// <param name="label">
        /// The human-readable name of the server.
        /// </param>
        /// <param name="command">
        /// The command used to start the server.
        /// </param>
        /// <param name="args">
        /// Additional command-line arguments passed to the server.
        /// </param>
        /// <param name="env">
        /// Optional additional environment information for the server.
        /// </param>
        /// <param name="version">
        /// Optional version identification for the server.
        /// </param>
        [<Emit("new $0.McpStdioServerDefinition($1...)")>]
        abstract member McpStdioServerDefinition: label: string * command: string * ?args: ResizeArray<string> * ?env: Exports.McpStdioServerDefinition.env * ?version: string -> McpStdioServerDefinition
        /// <param name="label">
        /// The human-readable name of the server.
        /// </param>
        /// <param name="uri">
        /// The URI of the server.
        /// </param>
        /// <param name="headers">
        /// Optional additional heads included with each request to the server.
        /// </param>
        [<Emit("new $0.McpHttpServerDefinition($1...)")>]
        abstract member McpHttpServerDefinition: label: string * uri: Uri * ?headers: Exports.McpHttpServerDefinition.headers * ?version: string -> McpHttpServerDefinition
        /// <summary>
        /// Create a new LanguageModelToolCallPart.
        /// </summary>
        /// <param name="callId">
        /// The ID of the tool call.
        /// </param>
        /// <param name="name">
        /// The name of the tool to call.
        /// </param>
        /// <param name="input">
        /// The input with which to call the tool.
        /// </param>
        [<Emit("new $0.LanguageModelToolCallPart($1...)")>]
        abstract member LanguageModelToolCallPart: callId: string * name: string * input: obj -> LanguageModelToolCallPart
        /// <param name="callId">
        /// The ID of the tool call.
        /// </param>
        /// <param name="content">
        /// The content of the tool result.
        /// </param>
        [<Emit("new $0.LanguageModelToolResultPart($1...)")>]
        abstract member LanguageModelToolResultPart: callId: string * content: ResizeArray<U4<LanguageModelTextPart, LanguageModelPromptTsxPart, LanguageModelDataPart, obj>> -> LanguageModelToolResultPart
        /// <summary>
        /// Construct a text part with the given content.
        /// </summary>
        /// <param name="value">
        /// The text content of the part.
        /// </param>
        [<Emit("new $0.LanguageModelTextPart($1...)")>]
        abstract member LanguageModelTextPart: value: string -> LanguageModelTextPart
        /// <summary>
        /// Construct a prompt-tsx part with the given content.
        /// </summary>
        /// <param name="value">
        /// The value of the part, the result of <c>renderElementJSON</c> from <c>@vscode/prompt-tsx</c>.
        /// </param>
        [<Emit("new $0.LanguageModelPromptTsxPart($1...)")>]
        abstract member LanguageModelPromptTsxPart: value: obj -> LanguageModelPromptTsxPart
        /// <summary>
        /// Create a LanguageModelToolResult
        /// </summary>
        /// <param name="content">
        /// A list of tool result content parts
        /// </param>
        [<Emit("new $0.LanguageModelToolResult($1...)")>]
        abstract member LanguageModelToolResult: content: ResizeArray<U4<LanguageModelTextPart, LanguageModelPromptTsxPart, LanguageModelDataPart, obj>> -> LanguageModelToolResult
        /// <summary>
        /// Construct a generic data part with the given content.
        /// </summary>
        /// <param name="data">
        /// The byte data for this part.
        /// </param>
        /// <param name="mimeType">
        /// The mime type of the data.
        /// </param>
        [<Emit("new $0.LanguageModelDataPart($1...)")>]
        abstract member LanguageModelDataPart: data: JS.Uint8Array * mimeType: string -> LanguageModelDataPart
        [<Emit("$0.tasks")>]
        abstract member tasks: tasks.Exports with get
        [<Emit("$0.env")>]
        abstract member env: env.Exports with get
        [<Emit("$0.commands")>]
        abstract member commands: commands.Exports with get
        [<Emit("$0.window")>]
        abstract member window: window.Exports with get
        [<Emit("$0.workspace")>]
        abstract member workspace: workspace.Exports with get
        [<Emit("$0.languages")>]
        abstract member languages: languages.Exports with get
        [<Emit("$0.notebooks")>]
        abstract member notebooks: notebooks.Exports with get
        [<Emit("$0.scm")>]
        abstract member scm: scm.Exports with get
        [<Emit("$0.debug")>]
        abstract member debug: debug.Exports with get
        [<Emit("$0.extensions")>]
        abstract member extensions: extensions.Exports with get
        [<Emit("$0.comments")>]
        abstract member comments: comments.Exports with get
        [<Emit("$0.authentication")>]
        abstract member authentication: authentication.Exports with get
        [<Emit("$0.l10n")>]
        abstract member l10n: l10n.Exports with get
        [<Emit("$0.tests")>]
        abstract member tests: tests.Exports with get
        [<Emit("$0.chat")>]
        abstract member chat: chat.Exports with get
        [<Emit("$0.lm")>]
        abstract member lm: lm.Exports with get

    [<AllowNullLiteral>]
    [<Interface>]
    type Command =
        /// <summary>
        /// Title of the command, like <c>save</c>.
        /// </summary>
        abstract member title: string with get, set
        /// <summary>
        /// The identifier of the actual command handler.
        /// </summary>
        abstract member command: string with get, set
        /// <summary>
        /// A tooltip for the command, when represented in the UI.
        /// </summary>
        abstract member tooltip: string option with get, set
        /// <summary>
        /// Arguments that the command handler should be
        /// invoked with.
        /// </summary>
        abstract member arguments: ResizeArray<obj> option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TextLine =
        /// <summary>
        /// The zero-based line number.
        /// </summary>
        abstract member lineNumber: float with get
        /// <summary>
        /// The text of this line without the line separator characters.
        /// </summary>
        abstract member text: string with get
        /// <summary>
        /// The range this line covers without the line separator characters.
        /// </summary>
        abstract member range: Range with get
        /// <summary>
        /// The range this line covers with the line separator characters.
        /// </summary>
        abstract member rangeIncludingLineBreak: Range with get
        /// <summary>
        /// The offset of the first character which is not a whitespace character as defined
        /// by <c>/\s/</c>. **Note** that if a line is all whitespace the length of the line is returned.
        /// </summary>
        abstract member firstNonWhitespaceCharacterIndex: float with get
        /// <summary>
        /// Whether this line is whitespace only, shorthand
        /// for <see href="TextLine.firstNonWhitespaceCharacterIndex">TextLine.firstNonWhitespaceCharacterIndex</see> === <see href="TextLine.textTextLine.text.length">TextLine.textTextLine.text.length</see>.
        /// </summary>
        abstract member isEmptyOrWhitespace: bool with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TextDocument =
        /// <summary>
        /// The associated uri for this document.
        ///
        /// *Note* that most documents use the <c>file</c>-scheme, which means they are files on disk. However, **not** all documents are
        /// saved on disk and therefore the <c>scheme</c> must be checked before trying to access the underlying file or siblings on disk.
        /// </summary>
        abstract member uri: Uri with get
        /// <summary>
        /// The file system path of the associated resource. Shorthand
        /// notation for <see href="TextDocument.uriTextDocument.uri.fsPath">TextDocument.uriTextDocument.uri.fsPath</see>. Independent of the uri scheme.
        /// </summary>
        abstract member fileName: string with get
        /// <summary>
        /// Is this document representing an untitled file which has never been saved yet. *Note* that
        /// this does not mean the document will be saved to disk, use {@linkcode Uri.scheme}
        /// to figure out where a document will be <see href="FileSystemProvidersaved">FileSystemProvidersaved</see>, e.g. <c>file</c>, <c>ftp</c> etc.
        /// </summary>
        abstract member isUntitled: bool with get
        /// <summary>
        /// The identifier of the language associated with this document.
        /// </summary>
        abstract member languageId: string with get
        /// <summary>
        /// The file encoding of this document that will be used when the document is saved.
        ///
        /// Use the <see href="workspace.onDidChangeTextDocumentonDidChangeTextDocument">workspace.onDidChangeTextDocumentonDidChangeTextDocument</see>-event to
        /// get notified when the document encoding changes.
        ///
        /// Note that the possible encoding values are currently defined as any of the following:
        /// 'utf8', 'utf8bom', 'utf16le', 'utf16be', 'windows1252', 'iso88591', 'iso88593',
        /// 'iso885915', 'macroman', 'cp437', 'windows1256', 'iso88596', 'windows1257',
        /// 'iso88594', 'iso885914', 'windows1250', 'iso88592', 'cp852', 'windows1251',
        /// 'cp866', 'cp1125', 'iso88595', 'koi8r', 'koi8u', 'iso885913', 'windows1253',
        /// 'iso88597', 'windows1255', 'iso88598', 'iso885910', 'iso885916', 'windows1254',
        /// 'iso88599', 'windows1258', 'gbk', 'gb18030', 'cp950', 'big5hkscs', 'shiftjis',
        /// 'eucjp', 'euckr', 'windows874', 'iso885911', 'koi8ru', 'koi8t', 'gb2312',
        /// 'cp865', 'cp850'.
        /// </summary>
        abstract member encoding: string with get
        /// <summary>
        /// The version number of this document (it will strictly increase after each
        /// change, including undo/redo).
        /// </summary>
        abstract member version: float with get
        /// <summary>
        /// <c>true</c> if there are unpersisted changes.
        /// </summary>
        abstract member isDirty: bool with get
        /// <summary>
        /// <c>true</c> if the document has been closed. A closed document isn't synchronized anymore
        /// and won't be re-used when the same resource is opened again.
        /// </summary>
        abstract member isClosed: bool with get
        /// <summary>
        /// Save the underlying file.
        /// </summary>
        /// <returns>
        /// A promise that will resolve to <c>true</c> when the file
        /// has been saved. If the save failed, will return <c>false</c>.
        /// </returns>
        abstract member save: unit -> Thenable<bool>
        /// <summary>
        /// The <see href="EndOfLineend">of line</see>" sequence that is predominately
        /// used in this document.
        /// </summary>
        abstract member eol: EndOfLine with get
        /// <summary>
        /// The number of lines in this document.
        /// </summary>
        abstract member lineCount: float with get
        /// <summary>
        /// Returns a text line denoted by the line number. Note
        /// that the returned object is *not* live and changes to the
        /// document are not reflected.
        /// Returns a text line denoted by the position. Note
        /// that the returned object is *not* live and changes to the
        /// document are not reflected.
        ///
        /// The position will be <see href="TextDocument.validatePositionadjusted">TextDocument.validatePositionadjusted</see>.
        /// </summary>
        /// <param name="line">
        /// A line number in <c>[0, lineCount)</c>.
        /// </param>
        /// <returns>
        /// A <see href="TextLine">line</see>".
        /// </returns>
        abstract member lineAt: line: float -> TextLine
        /// <summary>
        /// Returns a text line denoted by the line number. Note
        /// that the returned object is *not* live and changes to the
        /// document are not reflected.
        /// Returns a text line denoted by the position. Note
        /// that the returned object is *not* live and changes to the
        /// document are not reflected.
        ///
        /// The position will be <see href="TextDocument.validatePositionadjusted">TextDocument.validatePositionadjusted</see>.
        /// </summary>
        /// <param name="position">
        /// A position.
        /// </param>
        /// <returns>
        /// A <see href="TextLine">line</see>".
        /// </returns>
        abstract member lineAt: position: Position -> TextLine
        /// <summary>
        /// Converts the position to a zero-based offset.
        ///
        /// The position will be <see href="TextDocument.validatePositionadjusted">TextDocument.validatePositionadjusted</see>.
        /// </summary>
        /// <param name="position">
        /// A position.
        /// </param>
        /// <returns>
        /// A valid zero-based offset in UTF-16 [code units](https://developer.mozilla.org/en-US/docs/Glossary/Code_unit).
        /// </returns>
        abstract member offsetAt: position: Position -> float
        /// <summary>
        /// Converts a zero-based offset to a position.
        /// </summary>
        /// <param name="offset">
        /// A zero-based offset into the document. This offset is in UTF-16 [code units](https://developer.mozilla.org/en-US/docs/Glossary/Code_unit).
        /// </param>
        /// <returns>
        /// A valid <see href="Position">Position</see>.
        /// </returns>
        abstract member positionAt: offset: float -> Position
        /// <summary>
        /// Get the text of this document. A substring can be retrieved by providing
        /// a range. The range will be <see href="TextDocument.validateRangeadjusted">TextDocument.validateRangeadjusted</see>.
        /// </summary>
        /// <param name="range">
        /// Include only the text included by the range.
        /// </param>
        /// <returns>
        /// The text inside the provided range or the entire text.
        /// </returns>
        abstract member getText: ?range: Range -> string
        /// <summary>
        /// Get a word-range at the given position. By default words are defined by
        /// common separators, like space, -, _, etc. In addition, per language custom
        /// [word definitions] can be defined. It
        /// is also possible to provide a custom regular expression.
        ///
        /// * *Note 1:* A custom regular expression must not match the empty string and
        /// if it does, it will be ignored.
        /// * *Note 2:* A custom regular expression will fail to match multiline strings
        /// and in the name of speed regular expressions should not match words with
        /// spaces. Use {@linkcode TextLine.text} for more complex, non-wordy, scenarios.
        ///
        /// The position will be <see href="TextDocument.validatePositionadjusted">TextDocument.validatePositionadjusted</see>.
        /// </summary>
        /// <param name="position">
        /// A position.
        /// </param>
        /// <param name="regex">
        /// Optional regular expression that describes what a word is.
        /// </param>
        /// <returns>
        /// A range spanning a word, or <c>undefined</c>.
        /// </returns>
        abstract member getWordRangeAtPosition: position: Position * ?regex: RegExp -> Range option
        /// <summary>
        /// Ensure a range is completely contained in this document.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <returns>
        /// The given range or a new, adjusted range.
        /// </returns>
        abstract member validateRange: range: Range -> Range
        /// <summary>
        /// Ensure a position is contained in the range of this document.
        /// </summary>
        /// <param name="position">
        /// A position.
        /// </param>
        /// <returns>
        /// The given position or a new, adjusted position.
        /// </returns>
        abstract member validatePosition: position: Position -> Position

    /// <summary>
    /// Represents a line and character position, such as
    /// the position of the cursor.
    ///
    /// Position objects are __immutable__. Use the <see href="Position.withwith">Position.withwith</see> or
    /// <see href="Position.translatetranslate">Position.translatetranslate</see> methods to derive new positions
    /// from an existing position.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Position =
        /// <summary>
        /// The zero-based line value.
        /// </summary>
        abstract member line: float with get
        /// <summary>
        /// The zero-based character value.
        ///
        /// Character offsets are expressed using UTF-16 [code units](https://developer.mozilla.org/en-US/docs/Glossary/Code_unit).
        /// </summary>
        abstract member character: float with get
        /// <summary>
        /// Check if this position is before <c>other</c>.
        /// </summary>
        /// <param name="other">
        /// A position.
        /// </param>
        /// <returns>
        /// <c>true</c> if position is on a smaller line
        /// or on the same line on a smaller character.
        /// </returns>
        abstract member isBefore: other: Position -> bool
        /// <summary>
        /// Check if this position is before or equal to <c>other</c>.
        /// </summary>
        /// <param name="other">
        /// A position.
        /// </param>
        /// <returns>
        /// <c>true</c> if position is on a smaller line
        /// or on the same line on a smaller or equal character.
        /// </returns>
        abstract member isBeforeOrEqual: other: Position -> bool
        /// <summary>
        /// Check if this position is after <c>other</c>.
        /// </summary>
        /// <param name="other">
        /// A position.
        /// </param>
        /// <returns>
        /// <c>true</c> if position is on a greater line
        /// or on the same line on a greater character.
        /// </returns>
        abstract member isAfter: other: Position -> bool
        /// <summary>
        /// Check if this position is after or equal to <c>other</c>.
        /// </summary>
        /// <param name="other">
        /// A position.
        /// </param>
        /// <returns>
        /// <c>true</c> if position is on a greater line
        /// or on the same line on a greater or equal character.
        /// </returns>
        abstract member isAfterOrEqual: other: Position -> bool
        /// <summary>
        /// Check if this position is equal to <c>other</c>.
        /// </summary>
        /// <param name="other">
        /// A position.
        /// </param>
        /// <returns>
        /// <c>true</c> if the line and character of the given position are equal to
        /// the line and character of this position.
        /// </returns>
        abstract member isEqual: other: Position -> bool
        /// <summary>
        /// Compare this to <c>other</c>.
        /// </summary>
        /// <param name="other">
        /// A position.
        /// </param>
        /// <returns>
        /// A number smaller than zero if this position is before the given position,
        /// a number greater than zero if this position is after the given position, or zero when
        /// this and the given position are equal.
        /// </returns>
        abstract member compareTo: other: Position -> float
        /// <summary>
        /// Create a new position relative to this position.
        /// Derived a new position relative to this position.
        /// </summary>
        /// <param name="lineDelta">
        /// Delta value for the line value, default is <c>0</c>.
        /// </param>
        /// <param name="characterDelta">
        /// Delta value for the character value, default is <c>0</c>.
        /// </param>
        /// <returns>
        /// A position which line and character is the sum of the current line and
        /// character and the corresponding deltas.
        /// </returns>
        abstract member translate: ?lineDelta: float * ?characterDelta: float -> Position
        /// <summary>
        /// Create a new position relative to this position.
        /// Derived a new position relative to this position.
        /// </summary>
        /// <param name="change">
        /// An object that describes a delta to this position.
        /// </param>
        /// <returns>
        /// A position that reflects the given delta. Will return <c>this</c> position if the change
        /// is not changing anything.
        /// </returns>
        abstract member translate: change: Position.translate.change -> Position
        /// <summary>
        /// Create a new position derived from this position.
        /// Derived a new position from this position.
        /// </summary>
        /// <param name="line">
        /// Value that should be used as line value, default is the <see href="Position.line">existing value</see>"
        /// </param>
        /// <param name="character">
        /// Value that should be used as character value, default is the <see href="Position.character">existing value</see>"
        /// </param>
        /// <returns>
        /// A position where line and character are replaced by the given values.
        /// </returns>
        abstract member ``with``: ?line: float * ?character: float -> Position
        /// <summary>
        /// Create a new position derived from this position.
        /// Derived a new position from this position.
        /// </summary>
        /// <param name="change">
        /// An object that describes a change to this position.
        /// </param>
        /// <returns>
        /// A position that reflects the given change. Will return <c>this</c> position if the change
        /// is not changing anything.
        /// </returns>
        abstract member ``with``: change: Position.``with``.change -> Position

    /// <summary>
    /// A range represents an ordered pair of two positions.
    /// It is guaranteed that <see href="Range.startstart">Range.startstart</see>.isBeforeOrEqual(<see href="Range.endend">Range.endend</see>)
    ///
    /// Range objects are __immutable__. Use the <see href="Range.withwith">Range.withwith</see>,
    /// <see href="Range.intersectionintersection">Range.intersectionintersection</see>, or <see href="Range.unionunion">Range.unionunion</see> methods
    /// to derive new ranges from an existing range.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Range =
        /// <summary>
        /// The start position. It is before or equal to <see href="Range.endend">Range.endend</see>.
        /// </summary>
        abstract member start: Position with get
        /// <summary>
        /// The end position. It is after or equal to <see href="Range.startstart">Range.startstart</see>.
        /// </summary>
        abstract member ``end``: Position with get
        /// <summary>
        /// <c>true</c> if <c>start</c> and <c>end</c> are equal.
        /// </summary>
        abstract member isEmpty: bool with get, set
        /// <summary>
        /// <c>true</c> if <c>start.line</c> and <c>end.line</c> are equal.
        /// </summary>
        abstract member isSingleLine: bool with get, set
        /// <summary>
        /// Check if a position or a range is contained in this range.
        /// </summary>
        /// <param name="positionOrRange">
        /// A position or a range.
        /// </param>
        /// <returns>
        /// <c>true</c> if the position or range is inside or equal
        /// to this range.
        /// </returns>
        abstract member contains: positionOrRange: U2<Position, Range> -> bool
        /// <summary>
        /// Check if <c>other</c> equals this range.
        /// </summary>
        /// <param name="other">
        /// A range.
        /// </param>
        /// <returns>
        /// <c>true</c> when start and end are <see href="Position.isEqual">equal</see>" to
        /// start and end of this range.
        /// </returns>
        abstract member isEqual: other: Range -> bool
        /// <summary>
        /// Intersect <c>range</c> with this range and returns a new range or <c>undefined</c>
        /// if the ranges have no overlap.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <returns>
        /// A range of the greater start and smaller end positions. Will
        /// return undefined when there is no overlap.
        /// </returns>
        abstract member intersection: range: Range -> Range option
        /// <summary>
        /// Compute the union of <c>other</c> with this range.
        /// </summary>
        /// <param name="other">
        /// A range.
        /// </param>
        /// <returns>
        /// A range of smaller start position and the greater end position.
        /// </returns>
        abstract member union: other: Range -> Range
        /// <summary>
        /// Derived a new range from this range.
        /// </summary>
        /// <param name="start">
        /// A position that should be used as start. The default value is the <see href="Range.start">current start</see>".
        /// </param>
        /// <param name="end">
        /// A position that should be used as end. The default value is the <see href="Range.end">current end</see>".
        /// </param>
        /// <returns>
        /// A range derived from this range with the given start and end position.
        /// If start and end are not different <c>this</c> range will be returned.
        /// </returns>
        abstract member ``with``: ?start: Position * ?``end``: Position -> Range
        /// <summary>
        /// Derived a new range from this range.
        /// </summary>
        /// <param name="change">
        /// An object that describes a change to this range.
        /// </param>
        /// <returns>
        /// A range that reflects the given change. Will return <c>this</c> range if the change
        /// is not changing anything.
        /// </returns>
        abstract member ``with``: change: Range.``with``.change -> Range

    /// <summary>
    /// Represents a text selection in an editor.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Selection =
        inherit Range
        /// <summary>
        /// The position at which the selection starts.
        /// This position might be before or after <see href="Selection.activeactive">Selection.activeactive</see>.
        /// </summary>
        abstract member anchor: Position with get
        /// <summary>
        /// The position of the cursor.
        /// This position might be before or after <see href="Selection.anchoranchor">Selection.anchoranchor</see>.
        /// </summary>
        abstract member active: Position with get
        /// <summary>
        /// A selection is reversed if its <see href="Selection.anchoranchor">Selection.anchoranchor</see> is the <see href="Selection.endend">Selection.endend</see> position.
        /// </summary>
        abstract member isReversed: bool with get

    [<RequireQualifiedAccess>]
    type TextEditorSelectionChangeKind =
        | Keyboard = 1
        | Mouse = 2
        | Command = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type TextEditorSelectionChangeEvent =
        /// <summary>
        /// The <see href="TextEditortext">editor</see>" for which the selections have changed.
        /// </summary>
        abstract member textEditor: TextEditor with get
        /// <summary>
        /// The new value for the <see href="TextEditor.selectionstext">editor's selections</see>".
        /// </summary>
        abstract member selections: ReadonlyArray<Selection> with get
        /// <summary>
        /// The <see href="TextEditorSelectionChangeKindchange">kind</see>" which has triggered this
        /// event. Can be <c>undefined</c>.
        /// </summary>
        abstract member kind: TextEditorSelectionChangeKind option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TextEditorVisibleRangesChangeEvent =
        /// <summary>
        /// The <see href="TextEditortext">editor</see>" for which the visible ranges have changed.
        /// </summary>
        abstract member textEditor: TextEditor with get
        /// <summary>
        /// The new value for the <see href="TextEditor.visibleRangestext">editor's visible ranges</see>".
        /// </summary>
        abstract member visibleRanges: ReadonlyArray<Range> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TextEditorOptionsChangeEvent =
        /// <summary>
        /// The <see href="TextEditortext">editor</see>" for which the options have changed.
        /// </summary>
        abstract member textEditor: TextEditor with get
        /// <summary>
        /// The new value for the <see href="TextEditor.optionstext">editor's options</see>".
        /// </summary>
        abstract member options: TextEditorOptions with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TextEditorViewColumnChangeEvent =
        /// <summary>
        /// The <see href="TextEditortext">editor</see>" for which the view column has changed.
        /// </summary>
        abstract member textEditor: TextEditor with get
        /// <summary>
        /// The new value for the <see href="TextEditor.viewColumntext">editor's view column</see>".
        /// </summary>
        abstract member viewColumn: ViewColumn with get

    [<RequireQualifiedAccess>]
    type TextEditorCursorStyle =
        | Line = 1
        | Block = 2
        | Underline = 3
        | LineThin = 4
        | BlockOutline = 5
        | UnderlineThin = 6

    [<RequireQualifiedAccess>]
    type TextEditorLineNumbersStyle =
        | Off = 0
        | On = 1
        | Relative = 2
        | Interval = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type TextEditorOptions =
        /// <summary>
        /// The size in spaces a tab takes. This is used for two purposes:
        ///  - the rendering width of a tab character;
        ///  - the number of spaces to insert when <see href="TextEditorOptions.insertSpacesinsertSpaces">TextEditorOptions.insertSpacesinsertSpaces</see> is true
        ///    and <c>indentSize</c> is set to <c>"tabSize"</c>.
        ///
        /// When getting a text editor's options, this property will always be a number (resolved).
        /// When setting a text editor's options, this property is optional and it can be a number or <c>"auto"</c>.
        /// </summary>
        abstract member tabSize: U2<float, string> option with get, set
        /// <summary>
        /// The number of spaces to insert when <see href="TextEditorOptions.insertSpacesinsertSpaces">TextEditorOptions.insertSpacesinsertSpaces</see> is true.
        ///
        /// When getting a text editor's options, this property will always be a number (resolved).
        /// When setting a text editor's options, this property is optional and it can be a number or <c>"tabSize"</c>.
        /// </summary>
        abstract member indentSize: U2<float, string> option with get, set
        /// <summary>
        /// When pressing Tab insert <see href="TextEditorOptions.tabSizen">TextEditorOptions.tabSizen</see> spaces.
        /// When getting a text editor's options, this property will always be a boolean (resolved).
        /// When setting a text editor's options, this property is optional and it can be a boolean or <c>"auto"</c>.
        /// </summary>
        abstract member insertSpaces: U2<bool, string> option with get, set
        /// <summary>
        /// The rendering style of the cursor in this editor.
        /// When getting a text editor's options, this property will always be present.
        /// When setting a text editor's options, this property is optional.
        /// </summary>
        abstract member cursorStyle: TextEditorCursorStyle option with get, set
        /// <summary>
        /// Render relative line numbers w.r.t. the current line number.
        /// When getting a text editor's options, this property will always be present.
        /// When setting a text editor's options, this property is optional.
        /// </summary>
        abstract member lineNumbers: TextEditorLineNumbersStyle option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TextEditorDecorationType =
        /// <summary>
        /// Internal representation of the handle.
        /// </summary>
        abstract member key: string with get
        /// <summary>
        /// Remove this decoration type and all decorations on all text editors using it.
        /// </summary>
        abstract member dispose: unit -> unit

    [<RequireQualifiedAccess>]
    type TextEditorRevealType =
        | Default = 0
        | InCenter = 1
        | InCenterIfOutsideViewport = 2
        | AtTop = 3

    [<RequireQualifiedAccess>]
    type OverviewRulerLane =
        | Left = 1
        | Center = 2
        | Right = 4
        | Full = 7

    [<RequireQualifiedAccess>]
    type DecorationRangeBehavior =
        | OpenOpen = 0
        | ClosedClosed = 1
        | OpenClosed = 2
        | ClosedOpen = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type TextDocumentShowOptions =
        /// <summary>
        /// An optional view column in which the <see href="TextEditoreditor">TextEditoreditor</see> should be shown.
        /// The default is the <see href="ViewColumn.Activeactive">ViewColumn.Activeactive</see>. Columns that do not exist
        /// will be created as needed up to the maximum of {@linkcode ViewColumn.Nine}.
        /// Use {@linkcode ViewColumn.Beside} to open the editor to the side of the currently
        /// active one.
        /// </summary>
        abstract member viewColumn: ViewColumn option with get, set
        /// <summary>
        /// An optional flag that when <c>true</c> will stop the <see href="TextEditoreditor">TextEditoreditor</see> from taking focus.
        /// </summary>
        abstract member preserveFocus: bool option with get, set
        /// <summary>
        /// An optional flag that controls if an <see href="TextEditoreditor">TextEditoreditor</see>-tab shows as preview. Preview tabs will
        /// be replaced and reused until set to stay - either explicitly or through editing.
        ///
        /// *Note* that the flag is ignored if a user has disabled preview editors in settings.
        /// </summary>
        abstract member preview: bool option with get, set
        /// <summary>
        /// An optional selection to apply for the document in the <see href="TextEditoreditor">TextEditoreditor</see>.
        /// </summary>
        abstract member selection: Range option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookEditorSelectionChangeEvent =
        /// <summary>
        /// The <see href="NotebookEditornotebook">editor</see>" for which the selections have changed.
        /// </summary>
        abstract member notebookEditor: NotebookEditor with get
        /// <summary>
        /// The new value for the <see href="NotebookEditor.selectionsnotebook">editor's selections</see>".
        /// </summary>
        abstract member selections: ReadonlyArray<NotebookRange> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookEditorVisibleRangesChangeEvent =
        /// <summary>
        /// The <see href="NotebookEditornotebook">editor</see>" for which the visible ranges have changed.
        /// </summary>
        abstract member notebookEditor: NotebookEditor with get
        /// <summary>
        /// The new value for the <see href="NotebookEditor.visibleRangesnotebook">editor's visibleRanges</see>".
        /// </summary>
        abstract member visibleRanges: ReadonlyArray<NotebookRange> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookDocumentShowOptions =
        /// <summary>
        /// An optional view column in which the <see href="NotebookEditornotebook">editor</see>" should be shown.
        /// The default is the <see href="ViewColumn.Activeactive">ViewColumn.Activeactive</see>. Columns that do not exist
        /// will be created as needed up to the maximum of {@linkcode ViewColumn.Nine}.
        /// Use {@linkcode ViewColumn.Beside} to open the editor to the side of the currently
        /// active one.
        /// </summary>
        abstract member viewColumn: ViewColumn option with get
        /// <summary>
        /// An optional flag that when <c>true</c> will stop the <see href="NotebookEditornotebook">editor</see>" from taking focus.
        /// </summary>
        abstract member preserveFocus: bool option with get
        /// <summary>
        /// An optional flag that controls if an <see href="NotebookEditornotebook">editor</see>"-tab shows as preview. Preview tabs will
        /// be replaced and reused until set to stay - either explicitly or through editing. The default behaviour depends
        /// on the <c>workbench.editor.enablePreview</c>-setting.
        /// </summary>
        abstract member preview: bool option with get
        /// <summary>
        /// An optional selection to apply for the document in the <see href="NotebookEditornotebook">editor</see>".
        /// </summary>
        abstract member selections: ReadonlyArray<NotebookRange> option with get

    /// <summary>
    /// A reference to one of the workbench colors as defined in https://code.visualstudio.com/api/references/theme-color.
    /// Using a theme color is preferred over a custom color as it gives theme authors and users the possibility to change the color.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ThemeColor =
        /// <summary>
        /// The id of this color.
        /// </summary>
        abstract member id: string with get

    /// <summary>
    /// A reference to a named icon. Currently, <see href="ThemeIcon.FileFile">ThemeIcon.FileFile</see>, <see href="ThemeIcon.FolderFolder">ThemeIcon.FolderFolder</see>,
    /// and [ThemeIcon ids](https://code.visualstudio.com/api/references/icons-in-labels#icon-listing) are supported.
    /// Using a theme icon is preferred over a custom icon as it gives product theme authors the possibility to change the icons.
    ///
    /// *Note* that theme icons can also be rendered inside labels and descriptions. Places that support theme icons spell this out
    /// and they use the <c>$(<name>)</c>-syntax, for instance <c>quickPick.label = "Hello World $(globe)"</c>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ThemeIcon =
        /// <summary>
        /// Reference to an icon representing a file. The icon is taken from the current file icon theme or a placeholder icon is used.
        /// </summary>
        static member inline File
            with get () : ThemeIcon =
                emitJsExpr () $$"""
import { ThemeIcon } from "vscode";
ThemeIcon.File"""
        /// <summary>
        /// Reference to an icon representing a folder. The icon is taken from the current file icon theme or a placeholder icon is used.
        /// </summary>
        static member inline Folder
            with get () : ThemeIcon =
                emitJsExpr () $$"""
import { ThemeIcon } from "vscode";
ThemeIcon.Folder"""
        /// <summary>
        /// The id of the icon. The available icons are listed in https://code.visualstudio.com/api/references/icons-in-labels#icon-listing.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The optional ThemeColor of the icon. The color is currently only used in <see href="TreeItem">TreeItem</see>.
        /// </summary>
        abstract member color: ThemeColor option with get

    /// <summary>
    /// Represents an icon in the UI. This is either an uri, separate uris for the light- and dark-themes,
    /// or a <see href="ThemeIcontheme">icon</see>".
    /// </summary>
    type IconPath =
        U3<Uri, IconPath.U3.Case2, ThemeIcon>

    [<AllowNullLiteral>]
    [<Interface>]
    type ThemableDecorationRenderOptions =
        /// <summary>
        /// Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.
        /// Alternatively a color from the color registry can be <see href="ThemeColorreferenced">ThemeColorreferenced</see>.
        /// </summary>
        abstract member backgroundColor: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member outline: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// Better use 'outline' for setting one or more of the individual outline properties.
        /// </summary>
        abstract member outlineColor: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// Better use 'outline' for setting one or more of the individual outline properties.
        /// </summary>
        abstract member outlineStyle: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// Better use 'outline' for setting one or more of the individual outline properties.
        /// </summary>
        abstract member outlineWidth: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member border: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// Better use 'border' for setting one or more of the individual border properties.
        /// </summary>
        abstract member borderColor: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// Better use 'border' for setting one or more of the individual border properties.
        /// </summary>
        abstract member borderRadius: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// Better use 'border' for setting one or more of the individual border properties.
        /// </summary>
        abstract member borderSpacing: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// Better use 'border' for setting one or more of the individual border properties.
        /// </summary>
        abstract member borderStyle: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// Better use 'border' for setting one or more of the individual border properties.
        /// </summary>
        abstract member borderWidth: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member fontStyle: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member fontWeight: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member textDecoration: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member cursor: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member color: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member opacity: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member letterSpacing: string option with get, set
        /// <summary>
        /// An **absolute path** or an URI to an image to be rendered in the gutter.
        /// </summary>
        abstract member gutterIconPath: U2<string, Uri> option with get, set
        /// <summary>
        /// Specifies the size of the gutter icon.
        /// Available values are 'auto', 'contain', 'cover' and any percentage value.
        /// For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx
        /// </summary>
        abstract member gutterIconSize: string option with get, set
        /// <summary>
        /// The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.
        /// </summary>
        abstract member overviewRulerColor: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// Defines the rendering options of the attachment that is inserted before the decorated text.
        /// </summary>
        abstract member before: ThemableDecorationAttachmentRenderOptions option with get, set
        /// <summary>
        /// Defines the rendering options of the attachment that is inserted after the decorated text.
        /// </summary>
        abstract member after: ThemableDecorationAttachmentRenderOptions option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ThemableDecorationAttachmentRenderOptions =
        /// <summary>
        /// Defines a text content that is shown in the attachment. Either an icon or a text can be shown, but not both.
        /// </summary>
        abstract member contentText: string option with get, set
        /// <summary>
        /// An **absolute path** or an URI to an image to be rendered in the attachment. Either an icon
        /// or a text can be shown, but not both.
        /// </summary>
        abstract member contentIconPath: U2<string, Uri> option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member border: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to text enclosed by a decoration.
        /// </summary>
        abstract member borderColor: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member fontStyle: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member fontWeight: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member textDecoration: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member color: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member backgroundColor: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member margin: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member width: string option with get, set
        /// <summary>
        /// CSS styling property that will be applied to the decoration attachment.
        /// </summary>
        abstract member height: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DecorationRenderOptions =
        inherit ThemableDecorationRenderOptions
        /// <summary>
        /// Should the decoration be rendered also on the whitespace after the line text.
        /// Defaults to <c>false</c>.
        /// </summary>
        abstract member isWholeLine: bool option with get, set
        /// <summary>
        /// Customize the growing behavior of the decoration when edits occur at the edges of the decoration's range.
        /// Defaults to <c>DecorationRangeBehavior.OpenOpen</c>.
        /// </summary>
        abstract member rangeBehavior: DecorationRangeBehavior option with get, set
        /// <summary>
        /// The position in the overview ruler where the decoration should be rendered.
        /// </summary>
        abstract member overviewRulerLane: OverviewRulerLane option with get, set
        /// <summary>
        /// Overwrite options for light themes.
        /// </summary>
        abstract member light: ThemableDecorationRenderOptions option with get, set
        /// <summary>
        /// Overwrite options for dark themes.
        /// </summary>
        abstract member dark: ThemableDecorationRenderOptions option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DecorationOptions =
        /// <summary>
        /// Range to which this decoration is applied. The range must not be empty.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// A message that should be rendered when hovering over the decoration.
        /// </summary>
        abstract member hoverMessage: U3<MarkdownString, MarkedString, ResizeArray<U2<MarkdownString, MarkedString>>> option with get, set
        /// <summary>
        /// Render options applied to the current decoration. For performance reasons, keep the
        /// number of decoration specific options small, and use decoration types wherever possible.
        /// </summary>
        abstract member renderOptions: DecorationInstanceRenderOptions option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ThemableDecorationInstanceRenderOptions =
        /// <summary>
        /// Defines the rendering options of the attachment that is inserted before the decorated text.
        /// </summary>
        abstract member before: ThemableDecorationAttachmentRenderOptions option with get, set
        /// <summary>
        /// Defines the rendering options of the attachment that is inserted after the decorated text.
        /// </summary>
        abstract member after: ThemableDecorationAttachmentRenderOptions option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DecorationInstanceRenderOptions =
        inherit ThemableDecorationInstanceRenderOptions
        /// <summary>
        /// Overwrite options for light themes.
        /// </summary>
        abstract member light: ThemableDecorationInstanceRenderOptions option with get, set
        /// <summary>
        /// Overwrite options for dark themes.
        /// </summary>
        abstract member dark: ThemableDecorationInstanceRenderOptions option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TextEditor =
        /// <summary>
        /// The document associated with this text editor. The document will be the same for the entire lifetime of this text editor.
        /// </summary>
        abstract member document: TextDocument with get
        /// <summary>
        /// The primary selection on this text editor. Shorthand for <c>TextEditor.selections[0]</c>.
        /// </summary>
        abstract member selection: Selection with get, set
        /// <summary>
        /// The selections in this text editor. The primary selection is always at index 0.
        /// </summary>
        abstract member selections: ReadonlyArray<Selection> with get, set
        /// <summary>
        /// The current visible ranges in the editor (vertically).
        /// This accounts only for vertical scrolling, and not for horizontal scrolling.
        /// </summary>
        abstract member visibleRanges: ReadonlyArray<Range> with get
        /// <summary>
        /// Text editor options.
        /// </summary>
        abstract member options: TextEditorOptions with get, set
        /// <summary>
        /// The column in which this editor shows. Will be <c>undefined</c> in case this
        /// isn't one of the main editors, e.g. an embedded editor, or when the editor
        /// column is larger than three.
        /// </summary>
        abstract member viewColumn: ViewColumn option with get
        /// <summary>
        /// Perform an edit on the document associated with this text editor.
        ///
        /// The given callback-function is invoked with an <see href="TextEditorEditedit-builder">TextEditorEditedit-builder</see> which must
        /// be used to make edits. Note that the edit-builder is only valid while the
        /// callback executes.
        /// </summary>
        /// <param name="callback">
        /// A function which can create edits using an <see href="TextEditorEdit">edit-builder</see>".
        /// </param>
        /// <param name="options">
        /// The undo/redo behavior around this edit. By default, undo stops will be created before and after this edit.
        /// </param>
        /// <returns>
        /// A promise that resolves with a value indicating if the edits could be applied.
        /// </returns>
        abstract member edit: callback: (TextEditorEdit -> unit) * ?options: TextEditor.edit.options -> Thenable<bool>
        /// <summary>
        /// Insert a <see href="SnippetStringsnippet">SnippetStringsnippet</see> and put the editor into snippet mode. "Snippet mode"
        /// means the editor adds placeholders and additional cursors so that the user can complete
        /// or accept the snippet.
        /// </summary>
        /// <param name="snippet">
        /// The snippet to insert in this edit.
        /// </param>
        /// <param name="location">
        /// Position or range at which to insert the snippet, defaults to the current editor selection or selections.
        /// </param>
        /// <param name="options">
        /// The undo/redo behavior around this edit. By default, undo stops will be created before and after this edit.
        /// </param>
        /// <returns>
        /// A promise that resolves with a value indicating if the snippet could be inserted. Note that the promise does not signal
        /// that the snippet is completely filled-in or accepted.
        /// </returns>
        abstract member insertSnippet: snippet: SnippetString * ?location: U4<Position, Range, ReadonlyArray<Position>, ReadonlyArray<Range>> * ?options: TextEditor.insertSnippet.options -> Thenable<bool>
        /// <summary>
        /// Adds a set of decorations to the text editor. If a set of decorations already exists with
        /// the given <see href="TextEditorDecorationTypedecoration">type</see>", they will be replaced. If
        /// <c>rangesOrOptions</c> is empty, the existing decorations with the given <see href="TextEditorDecorationTypedecoration">type</see>"
        /// will be removed.
        /// </summary>
        /// <param name="decorationType">
        /// A decoration type.
        /// </param>
        /// <param name="rangesOrOptions">
        /// Either <see href="Range">ranges</see>" or more detailed <see href="DecorationOptions">options</see>".
        /// </param>
        abstract member setDecorations: decorationType: TextEditorDecorationType * rangesOrOptions: U2<ReadonlyArray<Range>, ReadonlyArray<DecorationOptions>> -> unit
        /// <summary>
        /// Scroll as indicated by <c>revealType</c> in order to reveal the given range.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <param name="revealType">
        /// The scrolling strategy for revealing <c>range</c>.
        /// </param>
        abstract member revealRange: range: Range * ?revealType: TextEditorRevealType -> unit
        /// <summary>
        /// Show the text editor.
        /// </summary>
        /// <param name="column">
        /// The <see href="ViewColumn">column</see>" in which to show this editor.
        /// This method shows unexpected behavior and will be removed in the next major update.
        /// </param>
        [<Obsolete("Use {@link window.showTextDocument } instead.")>]
        abstract member show: ?column: ViewColumn -> unit
        /// <summary>
        /// Hide the text editor.
        /// </summary>
        [<Obsolete("""Use the command `workbench.action.closeActiveEditor` instead.
This method shows unexpected behavior and will be removed in the next major update.""")>]
        abstract member hide: unit -> unit

    [<RequireQualifiedAccess>]
    type EndOfLine =
        | LF = 1
        | CRLF = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type TextEditorEdit =
        /// <summary>
        /// Replace a certain text region with a new value.
        /// You can use <c>\r\n</c> or <c>\n</c> in <c>value</c> and they will be normalized to the current <see href="TextDocumentdocument">TextDocumentdocument</see>.
        /// </summary>
        /// <param name="location">
        /// The range this operation should remove.
        /// </param>
        /// <param name="value">
        /// The new text this operation should insert after removing <c>location</c>.
        /// </param>
        abstract member replace: location: U3<Position, Range, Selection> * value: string -> unit
        /// <summary>
        /// Insert text at a location.
        /// You can use <c>\r\n</c> or <c>\n</c> in <c>value</c> and they will be normalized to the current <see href="TextDocumentdocument">TextDocumentdocument</see>.
        /// Although the equivalent text edit can be made with <see href="TextEditorEdit.replacereplace">TextEditorEdit.replacereplace</see>, <c>insert</c> will produce a different resulting selection (it will get moved).
        /// </summary>
        /// <param name="location">
        /// The position where the new text should be inserted.
        /// </param>
        /// <param name="value">
        /// The new text this operation should insert.
        /// </param>
        abstract member insert: location: Position * value: string -> unit
        /// <summary>
        /// Delete a certain text region.
        /// </summary>
        /// <param name="location">
        /// The range this operation should remove.
        /// </param>
        abstract member delete: location: U2<Range, Selection> -> unit
        /// <summary>
        /// Set the end of line sequence.
        /// </summary>
        /// <param name="endOfLine">
        /// The new end of line for the <see href="TextDocument">document</see>".
        /// </param>
        abstract member setEndOfLine: endOfLine: EndOfLine -> unit

    /// <summary>
    /// A universal resource identifier representing either a file on disk
    /// or another resource, like untitled resources.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Uri =
        /// <summary>
        /// Create an URI from a string, e.g. <c>http://www.example.com/some/path</c>,
        /// <c>file:///usr/home</c>, or <c>scheme:with/path</c>.
        ///
        /// *Note* that for a while uris without a <c>scheme</c> were accepted. That is not correct
        /// as all uris should have a scheme. To avoid breakage of existing code the optional
        /// <c>strict</c>-argument has been added. We *strongly* advise to use it, e.g. <c>Uri.parse('my:uri', true)</c>
        /// </summary>
        /// <param name="value">
        /// The string value of an Uri.
        /// </param>
        /// <param name="strict">
        /// Throw an error when <c>value</c> is empty or when no <c>scheme</c> can be parsed.
        /// </param>
        /// <returns>
        /// A new Uri instance.
        /// </returns>
        static member inline parse (value: string, ?strict: bool): Uri =
            emitJsExpr (value, strict) $$"""
import { Uri } from "vscode";
Uri.parse($0, $1)"""
        /// <summary>
        /// Create an URI from a file system path. The <see href="Uri.schemescheme">Uri.schemescheme</see>
        /// will be <c>file</c>.
        ///
        /// The *difference* between <see href="Uri.parse">Uri.parse</see> and <see href="Uri.file">Uri.file</see> is that the latter treats the argument
        /// as path, not as stringified-uri. E.g. <c>Uri.file(path)</c> is *not* the same as
        /// <c>Uri.parse('file://' + path)</c> because the path might contain characters that are
        /// interpreted (# and ?). See the following sample:
        /// <code lang="ts">
        /// const good = URI.file('/coding/c#/project1');
        /// good.scheme === 'file';
        /// good.path === '/coding/c#/project1';
        /// good.fragment === '';
        ///
        /// const bad = URI.parse('file://' + '/coding/c#/project1');
        /// bad.scheme === 'file';
        /// bad.path === '/coding/c'; // path is now broken
        /// bad.fragment === '/project1';
        /// </code>
        /// </summary>
        /// <param name="path">
        /// A file system or UNC path.
        /// </param>
        /// <returns>
        /// A new Uri instance.
        /// </returns>
        static member inline file (path: string): Uri =
            emitJsExpr (path) $$"""
import { Uri } from "vscode";
Uri.file($0)"""
        /// <summary>
        /// Create a new uri which path is the result of joining
        /// the path of the base uri with the provided path segments.
        ///
        /// - Note 1: <c>joinPath</c> only affects the path component
        /// and all other components (scheme, authority, query, and fragment) are
        /// left as they are.
        /// - Note 2: The base uri must have a path; an error is thrown otherwise.
        ///
        /// The path segments are normalized in the following ways:
        /// - sequences of path separators (<c>/</c> or <c>\</c>) are replaced with a single separator
        /// - for <c>file</c>-uris on windows, the backslash-character (<c>\</c>) is considered a path-separator
        /// - the <c>..</c>-segment denotes the parent segment, the <c>.</c> denotes the current segment
        /// - paths have a root which always remains, for instance on windows drive-letters are roots
        /// so that is true: <c>joinPath(Uri.file('file:///c:/root'), '../../other').fsPath === 'c:/other'</c>
        /// </summary>
        /// <param name="base">
        /// An uri. Must have a path.
        /// </param>
        /// <param name="pathSegments">
        /// One more more path fragments
        /// </param>
        /// <returns>
        /// A new uri which path is joined with the given fragments
        /// </returns>
        static member inline joinPath (``base``: Uri, [<ParamArray>] pathSegments: string []): Uri =
            emitJsExpr (``base``, pathSegments) $$"""
import { Uri } from "vscode";
Uri.joinPath($0, $1)"""
        /// <summary>
        /// Create an URI from its component parts
        /// </summary>
        /// <param name="components">
        /// The component parts of an Uri.
        /// </param>
        /// <returns>
        /// A new Uri instance.
        /// </returns>
        static member inline from (components: Uri.from.components): Uri =
            emitJsExpr (components) $$"""
import { Uri } from "vscode";
Uri.from($0)"""
        /// <summary>
        /// Scheme is the <c>http</c> part of <c>http://www.example.com/some/path?query#fragment</c>.
        /// The part before the first colon.
        /// </summary>
        abstract member scheme: string with get
        /// <summary>
        /// Authority is the <c>www.example.com</c> part of <c>http://www.example.com/some/path?query#fragment</c>.
        /// The part between the first double slashes and the next slash.
        /// </summary>
        abstract member authority: string with get
        /// <summary>
        /// Path is the <c>/some/path</c> part of <c>http://www.example.com/some/path?query#fragment</c>.
        /// </summary>
        abstract member path: string with get
        /// <summary>
        /// Query is the <c>query</c> part of <c>http://www.example.com/some/path?query#fragment</c>.
        /// </summary>
        abstract member query: string with get
        /// <summary>
        /// Fragment is the <c>fragment</c> part of <c>http://www.example.com/some/path?query#fragment</c>.
        /// </summary>
        abstract member fragment: string with get
        /// <summary>
        /// The string representing the corresponding file system path of this Uri.
        ///
        /// Will handle UNC paths and normalize windows drive letters to lower-case. Also
        /// uses the platform specific path separator.
        ///
        /// * Will *not* validate the path for invalid characters and semantics.
        /// * Will *not* look at the scheme of this Uri.
        /// * The resulting string shall *not* be used for display purposes but
        /// for disk operations, like <c>readFile</c> et al.
        ///
        /// The *difference* to the {@linkcode Uri.pathpath}-property is the use of the platform specific
        /// path separator and the handling of UNC paths. The sample below outlines the difference:
        /// <code lang="ts">
        /// const u = URI.parse('file://server/c$/folder/file.txt')
        /// u.authority === 'server'
        /// u.path === '/c$/folder/file.txt'
        /// u.fsPath === '\\server\c$\folder\file.txt'
        /// </code>
        /// </summary>
        abstract member fsPath: string with get
        /// <summary>
        /// Derive a new Uri from this Uri.
        ///
        /// <code lang="ts">
        /// let file = Uri.parse('before:some/file/path');
        /// let other = file.with({ scheme: 'after' });
        /// assert.ok(other.toString() === 'after:some/file/path');
        /// </code>
        /// </summary>
        /// <param name="change">
        /// An object that describes a change to this Uri. To unset components use <c>null</c> or
        /// the empty string.
        /// </param>
        /// <returns>
        /// A new Uri that reflects the given change. Will return <c>this</c> Uri if the change
        /// is not changing anything.
        /// </returns>
        abstract member ``with``: change: Uri.``with``.change -> Uri
        /// <summary>
        /// Returns a string representation of this Uri. The representation and normalization
        /// of a URI depends on the scheme.
        ///
        /// * The resulting string can be safely used with <see href="Uri.parse">Uri.parse</see>.
        /// * The resulting string shall *not* be used for display purposes.
        ///
        /// *Note* that the implementation will encode _aggressive_ which often leads to unexpected,
        /// but not incorrect, results. For instance, colons are encoded to <c>%3A</c> which might be unexpected
        /// in file-uri. Also <c>&</c> and <c>=</c> will be encoded which might be unexpected for http-uris. For stability
        /// reasons this cannot be changed anymore. If you suffer from too aggressive encoding you should use
        /// the <c>skipEncoding</c>-argument: <c>uri.toString(true)</c>.
        /// </summary>
        /// <param name="skipEncoding">
        /// Do not percentage-encode the result, defaults to <c>false</c>. Note that
        /// the <c>#</c> and <c>?</c> characters occurring in the path will always be encoded.
        /// </param>
        /// <returns>
        /// A string representation of this Uri.
        /// </returns>
        abstract member toString: ?skipEncoding: bool -> string
        /// <summary>
        /// Returns a JSON representation of this Uri.
        /// </summary>
        /// <returns>
        /// An object.
        /// </returns>
        abstract member toJSON: unit -> obj

    [<AllowNullLiteral>]
    [<Interface>]
    type CancellationToken =
        /// <summary>
        /// Is <c>true</c> when the token has been cancelled, <c>false</c> otherwise.
        /// </summary>
        abstract member isCancellationRequested: bool with get, set
        /// <summary>
        /// An <see href="Event">Event</see> which fires upon cancellation.
        /// </summary>
        abstract member onCancellationRequested: Event<obj> with get

    /// <summary>
    /// A cancellation source creates and controls a <see href="CancellationTokencancellation">token</see>".
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CancellationTokenSource =
        /// <summary>
        /// The cancellation token of this source.
        /// </summary>
        abstract member token: CancellationToken with get, set
        /// <summary>
        /// Signal cancellation on the token.
        /// </summary>
        abstract member cancel: unit -> unit
        /// <summary>
        /// Dispose object and free resources.
        /// </summary>
        abstract member dispose: unit -> unit

    /// <summary>
    /// An error type that should be used to signal cancellation of an operation.
    ///
    /// This type can be used in response to a <see href="CancellationTokencancellation">token</see>"
    /// being cancelled or when an operation is being cancelled by the
    /// executor of that operation.
    /// </summary>
    [<AllowNullLiteral>]
    [<AbstractClass>]
    type CancellationError =
        inherit Exception

    /// <summary>
    /// Represents a type which can release resources, such
    /// as event listening or a timer.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Disposable =
        /// <summary>
        /// Combine many disposable-likes into one. You can use this method when having objects with
        /// a dispose function which aren't instances of <c>Disposable</c>.
        /// </summary>
        /// <param name="disposableLikes">
        /// Objects that have at least a <c>dispose</c>-function member. Note that asynchronous
        /// dispose-functions aren't awaited.
        /// </param>
        /// <returns>
        /// Returns a new disposable which, upon dispose, will
        /// dispose all provided disposables.
        /// </returns>
        static member inline from ([<ParamArray>] disposableLikes: Disposable.from.disposableLikes []): Disposable =
            emitJsExpr (disposableLikes) $$"""
import { Disposable } from "vscode";
Disposable.from($0)"""
        /// <summary>
        /// Dispose this object.
        /// </summary>
        abstract member dispose: unit -> obj

    [<AllowNullLiteral>]
    [<Interface>]
    type Event<'T> =
        [<Emit("$0($1...)")>]
        abstract member Invoke: listener: ('T -> obj) * ?thisArgs: obj * ?disposables: ResizeArray<Disposable> -> Disposable

    /// <summary>
    /// An event emitter can be used to create and manage an <see href="Event">Event</see> for others
    /// to subscribe to. One emitter always owns one event.
    ///
    /// Use this class if you want to provide event from within your extension, for instance
    /// inside a <see href="TextDocumentContentProvider">TextDocumentContentProvider</see> or when providing
    /// API to other extensions.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type EventEmitter<'T> =
        /// <summary>
        /// The event listeners can subscribe to.
        /// </summary>
        abstract member event: Event<'T> with get, set
        /// <summary>
        /// Notify all subscribers of the <see href="EventEmitter.eventevent">EventEmitter.eventevent</see>. Failure
        /// of one or more listener will not fail this function call.
        /// </summary>
        /// <param name="data">
        /// The event object.
        /// </param>
        abstract member fire: data: 'T -> unit
        /// <summary>
        /// Dispose this object and free resources.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type FileSystemWatcher =
        inherit Disposable
        /// <summary>
        /// true if this file system watcher has been created such that
        /// it ignores creation file system events.
        /// </summary>
        abstract member ignoreCreateEvents: bool with get
        /// <summary>
        /// true if this file system watcher has been created such that
        /// it ignores change file system events.
        /// </summary>
        abstract member ignoreChangeEvents: bool with get
        /// <summary>
        /// true if this file system watcher has been created such that
        /// it ignores delete file system events.
        /// </summary>
        abstract member ignoreDeleteEvents: bool with get
        /// <summary>
        /// An event which fires on file/folder creation.
        /// </summary>
        abstract member onDidCreate: Event<Uri> with get
        /// <summary>
        /// An event which fires on file/folder change.
        /// </summary>
        abstract member onDidChange: Event<Uri> with get
        /// <summary>
        /// An event which fires on file/folder deletion.
        /// </summary>
        abstract member onDidDelete: Event<Uri> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TextDocumentContentProvider =
        /// <summary>
        /// An event to signal a resource has changed.
        /// </summary>
        abstract member onDidChange: Event<Uri> option with get, set
        /// <summary>
        /// Provide textual content for a given uri.
        ///
        /// The editor will use the returned string-content to create a readonly
        /// <see href="TextDocumentdocument">TextDocumentdocument</see>. Resources allocated should be released when
        /// the corresponding document has been <see href="workspace.onDidCloseTextDocumentclosed">workspace.onDidCloseTextDocumentclosed</see>.
        ///
        /// **Note**: The contents of the created <see href="TextDocumentdocument">TextDocumentdocument</see> might not be
        /// identical to the provided text due to end-of-line-sequence normalization.
        /// </summary>
        /// <param name="uri">
        /// An uri which scheme matches the scheme this provider was <see href="workspace.registerTextDocumentContentProvider">registered</see>" for.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A string or a thenable that resolves to such.
        /// </returns>
        abstract member provideTextDocumentContent: uri: Uri * token: CancellationToken -> ProviderResult<string>

    [<RequireQualifiedAccess>]
    type QuickPickItemKind =
        | Separator = -1
        | Default = 0

    [<AllowNullLiteral>]
    [<Interface>]
    type QuickPickItem =
        /// <summary>
        /// A human-readable string which is rendered prominently.
        ///
        /// Supports rendering of <see href="ThemeIcontheme">icons</see>" via the <c>$(<name>)</c>-syntax.
        ///
        /// **Note:** When <see href="QuickPickItem.kindkind">QuickPickItem.kindkind</see> is set to <see href="QuickPickItemKind.Default">QuickPickItemKind.Default</see> (so a regular
        /// item instead of a separator), it supports rendering of <see href="ThemeIcontheme">icons</see>" via the
        /// <c>$(<name>)</c>-syntax.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// The kind of this item that determines how it is rendered in the quick pick.
        ///
        /// When not specified, the default is <see href="QuickPickItemKind.Default">QuickPickItemKind.Default</see>.
        /// </summary>
        abstract member kind: QuickPickItemKind option with get, set
        /// <summary>
        /// The icon for the item.
        /// </summary>
        abstract member iconPath: IconPath option with get, set
        /// <summary>
        /// A human-readable string which is rendered less prominently in the same line.
        ///
        /// Supports rendering of <see href="ThemeIcontheme">icons</see>" via the <c>$(<name>)</c>-syntax.
        ///
        /// **Note:** This property is ignored when <see href="QuickPickItem.kindkind">QuickPickItem.kindkind</see> is set to
        /// <see href="QuickPickItemKind.Separator">QuickPickItemKind.Separator</see>.
        /// </summary>
        abstract member description: string option with get, set
        /// <summary>
        /// A human-readable string which is rendered less prominently in a separate line.
        ///
        /// Supports rendering of <see href="ThemeIcontheme">icons</see>" via the <c>$(<name>)</c>-syntax.
        ///
        /// **Note:** This property is ignored when <see href="QuickPickItem.kindkind">QuickPickItem.kindkind</see> is set to
        /// <see href="QuickPickItemKind.Separator">QuickPickItemKind.Separator</see>.
        /// </summary>
        abstract member detail: string option with get, set
        /// <summary>
        /// A <see href="Uri">Uri</see> representing the resource associated with this item.
        ///
        /// When set, this property is used to automatically derive several item properties if they are not explicitly provided:
        /// - **Label**: Derived from the resource's file name when <see href="QuickPickItem.labellabel">QuickPickItem.labellabel</see> is not provided or is empty.
        /// - **Description**: Derived from the resource's path when <see href="QuickPickItem.descriptiondescription">QuickPickItem.descriptiondescription</see> is not provided or is empty.
        /// - **Icon**: Derived from the current file icon theme when <see href="QuickPickItem.iconPathiconPath">QuickPickItem.iconPathiconPath</see> is set to
        ///   <see href="ThemeIcon.File">ThemeIcon.File</see> or <see href="ThemeIcon.Folder">ThemeIcon.Folder</see>.
        /// </summary>
        abstract member resourceUri: Uri option with get, set
        /// <summary>
        /// Optional flag indicating if this item is initially selected.
        ///
        /// This is only honored when using the <see href="window.showQuickPickshowQuickPick">window.showQuickPickshowQuickPick</see> API. To do the same
        /// thing with the <see href="window.createQuickPickcreateQuickPick">window.createQuickPickcreateQuickPick</see> API, simply set the
        /// <see href="QuickPick.selectedItemsselectedItems">QuickPick.selectedItemsselectedItems</see> to the items you want selected initially.
        ///
        /// **Note:** This is only honored when the picker allows multiple selections.
        /// </summary>
        abstract member picked: bool option with get, set
        /// <summary>
        /// Determines if this item is always shown, even when filtered out by the user's input.
        ///
        /// **Note:** This property is ignored when <see href="QuickPickItem.kindkind">QuickPickItem.kindkind</see> is set to
        /// <see href="QuickPickItemKind.Separator">QuickPickItemKind.Separator</see>.
        /// </summary>
        abstract member alwaysShow: bool option with get, set
        /// <summary>
        /// Optional buttons that will be rendered on this particular item.
        ///
        /// These buttons will trigger an <see href="QuickPickItemButtonEvent">QuickPickItemButtonEvent</see> when pressed. Buttons are only rendered
        /// when using a quick pick created by the <see href="window.createQuickPickcreateQuickPick">window.createQuickPickcreateQuickPick</see> API. Buttons are
        /// not rendered when using the <see href="window.showQuickPickshowQuickPick">window.showQuickPickshowQuickPick</see> API.
        ///
        /// **Note:** This property is ignored when <see href="QuickPickItem.kindkind">QuickPickItem.kindkind</see> is set to
        /// <see href="QuickPickItemKind.Separator">QuickPickItemKind.Separator</see>.
        /// </summary>
        abstract member buttons: ReadonlyArray<QuickInputButton> option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type QuickPickOptions =
        /// <summary>
        /// An optional title for the quick pick.
        /// </summary>
        abstract member title: string option with get, set
        /// <summary>
        /// Determines if the <see href="QuickPickItem.descriptiondescription">QuickPickItem.descriptiondescription</see> should be included when filtering items. Defaults to <c>false</c>.
        /// </summary>
        abstract member matchOnDescription: bool option with get, set
        /// <summary>
        /// Determines if the <see href="QuickPickItem.detaildetail">QuickPickItem.detaildetail</see> should be included when filtering items. Defaults to <c>false</c>.
        /// </summary>
        abstract member matchOnDetail: bool option with get, set
        /// <summary>
        /// An optional string to show as placeholder in the input box to guide the user.
        /// </summary>
        abstract member placeHolder: string option with get, set
        /// <summary>
        /// Optional text that provides instructions or context to the user.
        ///
        /// The prompt is displayed below the input box and above the list of items.
        /// </summary>
        abstract member prompt: string option with get, set
        /// <summary>
        /// Set to <c>true</c> to keep the picker open when focus moves to another part of the editor or to another window.
        /// This setting is ignored on iPad and is always <c>false</c>.
        /// </summary>
        abstract member ignoreFocusOut: bool option with get, set
        /// <summary>
        /// Determines if the picker allows multiple selections. When <c>true</c>, the result is an array of picks.
        /// </summary>
        abstract member canPickMany: bool option with get, set
        /// <summary>
        /// An optional function that is invoked whenever an item is selected.
        /// </summary>
        abstract member onDidSelectItem: item: U2<QuickPickItem, string> -> obj

    [<AllowNullLiteral>]
    [<Interface>]
    type WorkspaceFolderPickOptions =
        /// <summary>
        /// An optional string to show as placeholder in the input box to guide the user.
        /// </summary>
        abstract member placeHolder: string option with get, set
        /// <summary>
        /// Set to <c>true</c> to keep the picker open when focus moves to another part of the editor or to another window.
        /// This setting is ignored on iPad and is always <c>false</c>.
        /// </summary>
        abstract member ignoreFocusOut: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type OpenDialogOptions =
        /// <summary>
        /// The resource the dialog shows when opened.
        /// </summary>
        abstract member defaultUri: Uri option with get, set
        /// <summary>
        /// A human-readable string for the open button.
        /// </summary>
        abstract member openLabel: string option with get, set
        /// <summary>
        /// Allow to select files, defaults to <c>true</c>.
        /// </summary>
        abstract member canSelectFiles: bool option with get, set
        /// <summary>
        /// Allow to select folders, defaults to <c>false</c>.
        /// </summary>
        abstract member canSelectFolders: bool option with get, set
        /// <summary>
        /// Allow to select many files or folders.
        /// </summary>
        abstract member canSelectMany: bool option with get, set
        /// <summary>
        /// A set of file filters that are used by the dialog. Each entry is a human-readable label,
        /// like "TypeScript", and an array of extensions, for example:
        /// <code lang="ts">
        /// {
        /// 	'Images': ['png', 'jpg'],
        /// 	'TypeScript': ['ts', 'tsx']
        /// }
        /// </code>
        /// </summary>
        abstract member filters: OpenDialogOptions.filters option with get, set
        /// <summary>
        /// Dialog title.
        ///
        /// This parameter might be ignored, as not all operating systems display a title on open dialogs
        /// (for example, macOS).
        /// </summary>
        abstract member title: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type SaveDialogOptions =
        /// <summary>
        /// The resource the dialog shows when opened.
        /// </summary>
        abstract member defaultUri: Uri option with get, set
        /// <summary>
        /// A human-readable string for the save button.
        /// </summary>
        abstract member saveLabel: string option with get, set
        /// <summary>
        /// A set of file filters that are used by the dialog. Each entry is a human-readable label,
        /// like "TypeScript", and an array of extensions, for example:
        /// <code lang="ts">
        /// {
        /// 	'Images': ['png', 'jpg'],
        /// 	'TypeScript': ['ts', 'tsx']
        /// }
        /// </code>
        /// </summary>
        abstract member filters: SaveDialogOptions.filters option with get, set
        /// <summary>
        /// Dialog title.
        ///
        /// This parameter might be ignored, as not all operating systems display a title on save dialogs
        /// (for example, macOS).
        /// </summary>
        abstract member title: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type MessageItem =
        /// <summary>
        /// A short title like 'Retry', 'Open Log' etc.
        /// </summary>
        abstract member title: string with get, set
        /// <summary>
        /// A hint for modal dialogs that the item should be triggered
        /// when the user cancels the dialog (e.g. by pressing the ESC
        /// key).
        ///
        /// Note: this option is ignored for non-modal messages.
        /// </summary>
        abstract member isCloseAffordance: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type MessageOptions =
        /// <summary>
        /// Indicates that this message should be modal.
        /// </summary>
        abstract member modal: bool option with get, set
        /// <summary>
        /// Human-readable detail message that is rendered less prominent. _Note_ that detail
        /// is only shown for <see href="MessageOptions.modalmodal">MessageOptions.modalmodal</see> messages.
        /// </summary>
        abstract member detail: string option with get, set

    [<RequireQualifiedAccess>]
    type InputBoxValidationSeverity =
        | Info = 1
        | Warning = 2
        | Error = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type InputBoxValidationMessage =
        /// <summary>
        /// The validation message to display to the user.
        /// </summary>
        abstract member message: string with get
        /// <summary>
        /// The severity level of the validation message.
        ///
        /// **Note:** When using <see href="InputBoxValidationSeverity.Error">InputBoxValidationSeverity.Error</see>, the user will not be able to accept
        /// the input (e.g., by pressing Enter). <see href="InputBoxValidationSeverity.InfoInfo">InputBoxValidationSeverity.InfoInfo</see> and
        /// <see href="InputBoxValidationSeverity.WarningWarning">InputBoxValidationSeverity.WarningWarning</see> severities will still allow the input to be accepted.
        /// </summary>
        abstract member severity: InputBoxValidationSeverity with get

    [<AllowNullLiteral>]
    [<Interface>]
    type InputBoxOptions =
        /// <summary>
        /// An optional string that represents the title of the input box.
        /// </summary>
        abstract member title: string option with get, set
        /// <summary>
        /// The value to pre-fill in the input box.
        /// </summary>
        abstract member value: string option with get, set
        /// <summary>
        /// Selection of the pre-filled {@linkcode InputBoxOptions.valuevalue}. Defined as tuple of two number where the
        /// first is the inclusive start index and the second the exclusive end index. When <c>undefined</c> the whole
        /// pre-filled value will be selected, when empty (start equals end) only the cursor will be set,
        /// otherwise the defined range will be selected.
        /// </summary>
        abstract member valueSelection: float * float option with get, set
        /// <summary>
        /// The text to display underneath the input box.
        /// </summary>
        abstract member prompt: string option with get, set
        /// <summary>
        /// An optional string to show as placeholder in the input box to guide the user what to type.
        /// </summary>
        abstract member placeHolder: string option with get, set
        /// <summary>
        /// Controls if a password input is shown. Password input hides the typed text.
        /// </summary>
        abstract member password: bool option with get, set
        /// <summary>
        /// Set to <c>true</c> to keep the input box open when focus moves to another part of the editor or to another window.
        /// This setting is ignored on iPad and is always false.
        /// </summary>
        abstract member ignoreFocusOut: bool option with get, set
        /// <summary>
        /// An optional function that will be called to validate input and to give a hint
        /// to the user.
        /// </summary>
        /// <param name="value">
        /// The current value of the input box.
        /// </param>
        /// <returns>
        /// Either a human-readable string which is presented as an error message or an <see href="InputBoxValidationMessage">InputBoxValidationMessage</see>which can provide a specific message severity. Return <c>undefined</c>, <c>null</c>, or the empty string when 'value' is valid.
        /// </returns>
        abstract member validateInput: value: string -> U3<string, InputBoxValidationMessage, Thenable<U2<string, InputBoxValidationMessage> option>> option

    /// <summary>
    /// A relative pattern is a helper to construct glob patterns that are matched
    /// relatively to a base file path. The base path can either be an absolute file
    /// path as string or uri or a <see href="WorkspaceFolderworkspace">folder</see>", which is the
    /// preferred way of creating the relative pattern.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type RelativePattern =
        /// <summary>
        /// A base file path to which this pattern will be matched against relatively. The
        /// file path must be absolute, should not have any trailing path separators and
        /// not include any relative segments (<c>.</c> or <c>..</c>).
        /// </summary>
        abstract member baseUri: Uri with get, set
        /// <summary>
        /// A base file path to which this pattern will be matched against relatively.
        ///
        /// This matches the <c>fsPath</c> value of <see href="RelativePattern.baseUri">RelativePattern.baseUri</see>.
        ///
        /// *Note:* updating this value will update <see href="RelativePattern.baseUri">RelativePattern.baseUri</see> to
        /// be a uri with <c>file</c> scheme.
        /// </summary>
        [<Obsolete("This property is deprecated, please use {@link RelativePattern.baseUri } instead.")>]
        abstract member ``base``: string with get, set
        /// <summary>
        /// A file glob pattern like <c>*.{ts,js}</c> that will be matched on file paths
        /// relative to the base path.
        ///
        /// Example: Given a base of <c>/home/work/folder</c> and a file path of <c>/home/work/folder/index.js</c>,
        /// the file glob pattern will match on <c>index.js</c>.
        /// </summary>
        abstract member pattern: string with get, set

    /// <summary>
    /// A file glob pattern to match file paths against. This can either be a glob pattern string
    /// (like <c>**​/*.{ts,js}</c> or <c>*.{ts,js}</c>) or a <see href="RelativePatternrelative">pattern</see>".
    ///
    /// Glob patterns can have the following syntax:
    /// * <c>*</c> to match zero or more characters in a path segment
    /// * <c>?</c> to match on one character in a path segment
    /// * <c>**</c> to match any number of path segments, including none
    /// * <c>{}</c> to group conditions (e.g. <c>**​/*.{ts,js}</c> matches all TypeScript and JavaScript files)
    /// * <c>[]</c> to declare a range of characters to match in a path segment (e.g., <c>example.[0-9]</c> to match on <c>example.0</c>, <c>example.1</c>, …)
    /// * <c>[!...]</c> to negate a range of characters to match in a path segment (e.g., <c>example.[!0-9]</c> to match on <c>example.a</c>, <c>example.b</c>, but not <c>example.0</c>)
    ///
    /// Note: a backslash (<c>\</c>) is not valid within a glob pattern. If you have an existing file
    /// path to match against, consider to use the <see href="RelativePatternrelative">pattern</see>" support
    /// that takes care of converting any backslash into slash. Otherwise, make sure to convert
    /// any backslash to slash when creating the glob pattern.
    /// </summary>
    type GlobPattern =
        U2<string, RelativePattern>

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentFilter =
        /// <summary>
        /// A language id, like <c>typescript</c>.
        /// </summary>
        abstract member language: string option with get
        /// <summary>
        /// The <see href="NotebookDocument.notebookTypetype">NotebookDocument.notebookTypetype</see> of a notebook, like <c>jupyter-notebook</c>. This allows
        /// to narrow down on the type of a notebook that a <see href="NotebookCell.documentcell">document</see>" belongs to.
        ///
        /// *Note* that setting the <c>notebookType</c>-property changes how <c>scheme</c> and <c>pattern</c> are interpreted. When set
        /// they are evaluated against the <see href="NotebookDocument.urinotebook">uri</see>", not the document uri.
        /// </summary>
        /// <example>
        /// <caption>Match python document inside jupyter notebook that aren't stored yet (<c>untitled</c>)</caption>
        /// { language: 'python', notebookType: 'jupyter-notebook', scheme: 'untitled' }
        /// </example>
        abstract member notebookType: string option with get
        /// <summary>
        /// A Uri <see href="Uri.schemescheme">Uri.schemescheme</see>, like <c>file</c> or <c>untitled</c>.
        /// </summary>
        abstract member scheme: string option with get
        /// <summary>
        /// A <see href="GlobPatternglob">pattern</see>" that is matched on the absolute path of the document. Use a <see href="RelativePatternrelative">pattern</see>"
        /// to filter documents to a <see href="WorkspaceFolderworkspace">folder</see>".
        /// </summary>
        abstract member pattern: GlobPattern option with get

    /// <summary>
    /// A language selector is the combination of one or many language identifiers
    /// and <see href="DocumentFilterlanguage">filters</see>".
    ///
    /// *Note* that a document selector that is just a language identifier selects *all*
    /// documents, even those that are not saved on disk. Only use such selectors when
    /// a feature works without further context, e.g. without the need to resolve related
    /// 'files'.
    /// </summary>
    /// <example>
    /// let sel:DocumentSelector = { scheme: 'file', language: 'typescript' };
    /// </example>
    type DocumentSelector =
        U3<DocumentFilter, string, ReadonlyArray<U2<DocumentFilter, string>>>

    /// <summary>
    /// A provider result represents the values a provider, like the {@linkcode HoverProvider},
    /// may return. For once this is the actual result type <c>T</c>, like <c>Hover</c>, or a thenable that resolves
    /// to that type <c>T</c>. In addition, <c>null</c> and <c>undefined</c> can be returned - either directly or from a
    /// thenable.
    ///
    /// The snippets below are all valid implementations of the {@linkcode HoverProvider}:
    ///
    /// <code lang="ts">
    /// let a: HoverProvider = {
    /// 	provideHover(doc, pos, token): ProviderResult<Hover> {
    /// 		return new Hover('Hello World');
    /// 	}
    /// }
    ///
    /// let b: HoverProvider = {
    /// 	provideHover(doc, pos, token): ProviderResult<Hover> {
    /// 		return new Promise(resolve => {
    /// 			resolve(new Hover('Hello World'));
    /// 	 	});
    /// 	}
    /// }
    ///
    /// let c: HoverProvider = {
    /// 	provideHover(doc, pos, token): ProviderResult<Hover> {
    /// 		return; // undefined
    /// 	}
    /// }
    /// </code>
    /// </summary>
    type ProviderResult<'T> =
        U2<'T, Thenable<'T option>> option

    /// <summary>
    /// Kind of a code action.
    ///
    /// Kinds are a hierarchical list of identifiers separated by <c>.</c>, e.g. <c>"refactor.extract.function"</c>.
    ///
    /// Code action kinds are used by the editor for UI elements such as the refactoring context menu. Users
    /// can also trigger code actions with a specific kind with the <c>editor.action.codeAction</c> command.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CodeActionKind =
        /// <summary>
        /// Empty kind.
        /// </summary>
        static member inline Empty
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.Empty"""
        /// <summary>
        /// Base kind for quickfix actions: <c>quickfix</c>.
        ///
        /// Quick fix actions address a problem in the code and are shown in the normal code action context menu.
        /// </summary>
        static member inline QuickFix
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.QuickFix"""
        /// <summary>
        /// Base kind for refactoring actions: <c>refactor</c>
        ///
        /// Refactoring actions are shown in the refactoring context menu.
        /// </summary>
        static member inline Refactor
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.Refactor"""
        /// <summary>
        /// Base kind for refactoring extraction actions: <c>refactor.extract</c>
        ///
        /// Example extract actions:
        ///
        /// - Extract method
        /// - Extract function
        /// - Extract variable
        /// - Extract interface from class
        /// - ...
        /// </summary>
        static member inline RefactorExtract
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.RefactorExtract"""
        /// <summary>
        /// Base kind for refactoring inline actions: <c>refactor.inline</c>
        ///
        /// Example inline actions:
        ///
        /// - Inline function
        /// - Inline variable
        /// - Inline constant
        /// - ...
        /// </summary>
        static member inline RefactorInline
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.RefactorInline"""
        /// <summary>
        /// Base kind for refactoring move actions: <c>refactor.move</c>
        ///
        /// Example move actions:
        ///
        /// - Move a function to a new file
        /// - Move a property between classes
        /// - Move method to base class
        /// - ...
        /// </summary>
        static member inline RefactorMove
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.RefactorMove"""
        /// <summary>
        /// Base kind for refactoring rewrite actions: <c>refactor.rewrite</c>
        ///
        /// Example rewrite actions:
        ///
        /// - Convert JavaScript function to class
        /// - Add or remove parameter
        /// - Encapsulate field
        /// - Make method static
        /// - ...
        /// </summary>
        static member inline RefactorRewrite
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.RefactorRewrite"""
        /// <summary>
        /// Base kind for source actions: <c>source</c>
        ///
        /// Source code actions apply to the entire file. They must be explicitly requested and will not show in the
        /// normal [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) menu. Source actions
        /// can be run on save using <c>editor.codeActionsOnSave</c> and are also shown in the <c>source</c> context menu.
        /// </summary>
        static member inline Source
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.Source"""
        /// <summary>
        /// Base kind for an organize imports source action: <c>source.organizeImports</c>.
        /// </summary>
        static member inline SourceOrganizeImports
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.SourceOrganizeImports"""
        /// <summary>
        /// Base kind for auto-fix source actions: <c>source.fixAll</c>.
        ///
        /// Fix all actions automatically fix errors that have a clear fix that do not require user input.
        /// They should not suppress errors or perform unsafe fixes such as generating new types or classes.
        /// </summary>
        static member inline SourceFixAll
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.SourceFixAll"""
        /// <summary>
        /// Base kind for all code actions applying to the entire notebook's scope. CodeActionKinds using
        /// this should always begin with <c>notebook.</c>
        ///
        /// This requires that new CodeActions be created for it and contributed via extensions.
        /// Pre-existing kinds can not just have the new <c>notebook.</c> prefix added to them, as the functionality
        /// is unique to the full-notebook scope.
        ///
        /// Notebook CodeActionKinds can be initialized as either of the following (both resulting in <c>notebook.source.xyz</c>):
        /// - <c>const newKind =  CodeActionKind.Notebook.append(CodeActionKind.Source.append('xyz').value)</c>
        /// - <c>const newKind =  CodeActionKind.Notebook.append('source.xyz')</c>
        ///
        /// Example Kinds/Actions:
        /// - <c>notebook.source.organizeImports</c> (might move all imports to a new top cell)
        /// - <c>notebook.source.normalizeVariableNames</c> (might rename all variables to a standardized casing format)
        /// </summary>
        static member inline Notebook
            with get () : CodeActionKind =
                emitJsExpr () $$"""
import { CodeActionKind } from "vscode";
CodeActionKind.Notebook"""
        /// <summary>
        /// String value of the kind, e.g. <c>"refactor.extract.function"</c>.
        /// </summary>
        abstract member value: string with get
        /// <summary>
        /// Create a new kind by appending a more specific selector to the current kind.
        ///
        /// Does not modify the current kind.
        /// </summary>
        abstract member append: parts: string -> CodeActionKind
        /// <summary>
        /// Checks if this code action kind intersects <c>other</c>.
        ///
        /// The kind <c>"refactor.extract"</c> for example intersects <c>refactor</c>, <c>"refactor.extract"</c> and <c>"refactor.extract.function"</c>,
        /// but not <c>"unicorn.refactor.extract"</c>, or <c>"refactor.extractAll"</c>.
        /// </summary>
        /// <param name="other">
        /// Kind to check.
        /// </param>
        abstract member intersects: other: CodeActionKind -> bool
        /// <summary>
        /// Checks if <c>other</c> is a sub-kind of this <c>CodeActionKind</c>.
        ///
        /// The kind <c>"refactor.extract"</c> for example contains <c>"refactor.extract"</c> and <c></c>"refactor.extract.function"<c>,
        /// but not </c>"unicorn.refactor.extract"<c>, or </c>"refactor.extractAll"<c> or </c>refactor`.
        /// </summary>
        /// <param name="other">
        /// Kind to check.
        /// </param>
        abstract member contains: other: CodeActionKind -> bool

    [<RequireQualifiedAccess>]
    type CodeActionTriggerKind =
        | Invoke = 1
        | Automatic = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type CodeActionContext =
        /// <summary>
        /// The reason why code actions were requested.
        /// </summary>
        abstract member triggerKind: CodeActionTriggerKind with get
        /// <summary>
        /// An array of diagnostics.
        /// </summary>
        abstract member diagnostics: ReadonlyArray<Diagnostic> with get
        /// <summary>
        /// Requested kind of actions to return.
        ///
        /// Actions not of this kind are filtered out before being shown by the [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action).
        /// </summary>
        abstract member only: CodeActionKind option with get

    /// <summary>
    /// A code action represents a change that can be performed in code, e.g. to fix a problem or
    /// to refactor code.
    ///
    /// A CodeAction must set either {@linkcode CodeAction.editedit} and/or a {@linkcode CodeAction.commandcommand}. If both are supplied, the <c>edit</c> is applied first, then the command is executed.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CodeAction =
        /// <summary>
        /// A short, human-readable, title for this code action.
        /// </summary>
        abstract member title: string with get, set
        /// <summary>
        /// A <see href="WorkspaceEditworkspace">edit</see>" this code action performs.
        /// </summary>
        abstract member edit: WorkspaceEdit option with get, set
        /// <summary>
        /// <see href="DiagnosticDiagnostics">DiagnosticDiagnostics</see> that this code action resolves.
        /// </summary>
        abstract member diagnostics: ResizeArray<Diagnostic> option with get, set
        /// <summary>
        /// A <see href="Command">Command</see> this code action executes.
        ///
        /// If this command throws an exception, the editor displays the exception message to users in the editor at the
        /// current cursor position.
        /// </summary>
        abstract member command: Command option with get, set
        /// <summary>
        /// <see href="CodeActionKindKind">CodeActionKindKind</see> of the code action.
        ///
        /// Used to filter code actions.
        /// </summary>
        abstract member kind: CodeActionKind option with get, set
        /// <summary>
        /// Marks this as a preferred action. Preferred actions are used by the <c>auto fix</c> command and can be targeted
        /// by keybindings.
        ///
        /// A quick fix should be marked preferred if it properly addresses the underlying error.
        /// A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
        /// </summary>
        abstract member isPreferred: bool option with get, set
        /// <summary>
        /// Marks that the code action cannot currently be applied.
        ///
        /// - Disabled code actions are not shown in automatic [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
        /// code action menu.
        ///
        /// - Disabled actions are shown as faded out in the code action menu when the user request a more specific type
        /// of code action, such as refactorings.
        ///
        /// - If the user has a [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions)
        /// that auto applies a code action and only a disabled code actions are returned, the editor will show the user an
        /// error message with <c>reason</c> in the editor.
        /// </summary>
        abstract member disabled: CodeAction.disabled option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type CodeActionProvider<'T when 'T :> CodeAction> =
        /// <summary>
        /// Get code actions for a given range in a document.
        ///
        /// Only return code actions that are relevant to user for the requested range. Also keep in mind how the
        /// returned code actions will appear in the UI. The lightbulb widget and <c>Refactor</c> commands for instance show
        /// returned code actions as a list, so do not return a large number of code actions that will overwhelm the user.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="range">
        /// The selector or range for which the command was invoked. This will always be a
        /// <see href="Selection">selection</see>" if the actions are being requested in the currently active editor.
        /// </param>
        /// <param name="context">
        /// Provides additional information about what code actions are being requested. You can use this
        /// to see what specific type of code actions are being requested by the editor in order to return more relevant
        /// actions and avoid returning irrelevant code actions that the editor will discard.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of code actions, such as quick fixes or refactorings. The lack of a result can be signaled
        /// by returning <c>undefined</c>, <c>null</c>, or an empty array.
        ///
        /// We also support returning <c>Command</c> for legacy reasons, however all new extensions should return
        /// <c>CodeAction</c> object instead.
        /// </returns>
        abstract member provideCodeActions: document: TextDocument * range: U2<Range, Selection> * context: CodeActionContext * token: CancellationToken -> ProviderResult<ResizeArray<U2<Command, 'T>>>
        /// <summary>
        /// Given a code action fill in its {@linkcode CodeAction.editedit}-property. Changes to
        /// all other properties, like title, are ignored. A code action that has an edit
        /// will not be resolved.
        ///
        /// *Note* that a code action provider that returns commands, not code actions, cannot successfully
        /// implement this function. Returning commands is deprecated and instead code actions should be
        /// returned.
        /// </summary>
        /// <param name="codeAction">
        /// A code action.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved code action or a thenable that resolves to such. It is OK to return the given
        /// <c>item</c>. When no result is returned, the given <c>item</c> will be used.
        /// </returns>
        abstract member resolveCodeAction: codeAction: 'T * token: CancellationToken -> ProviderResult<'T>

    [<AllowNullLiteral>]
    [<Interface>]
    type CodeActionProviderMetadata =
        /// <summary>
        /// List of <see href="CodeActionKindCodeActionKinds">CodeActionKindCodeActionKinds</see> that a <see href="CodeActionProvider">CodeActionProvider</see> may return.
        ///
        /// This list is used to determine if a given <c>CodeActionProvider</c> should be invoked or not.
        /// To avoid unnecessary computation, every <c>CodeActionProvider</c> should list use <c>providedCodeActionKinds</c>. The
        /// list of kinds may either be generic, such as <c>[CodeActionKind.Refactor]</c>, or list out every kind provided,
        /// such as <c>[CodeActionKind.Refactor.Extract.append('function'), CodeActionKind.Refactor.Extract.append('constant'), ...]</c>.
        /// </summary>
        abstract member providedCodeActionKinds: ReadonlyArray<CodeActionKind> option with get
        /// <summary>
        /// Static documentation for a class of code actions.
        ///
        /// Documentation from the provider is shown in the code actions menu if either:
        ///
        /// - Code actions of <c>kind</c> are requested by the editor. In this case, the editor will show the documentation that
        ///   most closely matches the requested code action kind. For example, if a provider has documentation for
        ///   both <c>Refactor</c> and <c>RefactorExtract</c>, when the user requests code actions for <c>RefactorExtract</c>,
        ///   the editor will use the documentation for <c>RefactorExtract</c> instead of the documentation for <c>Refactor</c>.
        ///
        /// - Any code actions of <c>kind</c> are returned by the provider.
        ///
        /// At most one documentation entry will be shown per provider.
        /// </summary>
        abstract member documentation: ReadonlyArray<CodeActionProviderMetadata.documentation> option with get

    /// <summary>
    /// A code lens represents a <see href="Command">Command</see> that should be shown along with
    /// source text, like the number of references, a way to run tests, etc.
    ///
    /// A code lens is _unresolved_ when no command is associated to it. For performance
    /// reasons the creation of a code lens and resolving should be done to two stages.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CodeLens =
        /// <summary>
        /// The range in which this code lens is valid. Should only span a single line.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The command this code lens represents.
        /// </summary>
        abstract member command: Command option with get, set
        /// <summary>
        /// <c>true</c> when there is a command associated.
        /// </summary>
        abstract member isResolved: bool with get

    [<AllowNullLiteral>]
    [<Interface>]
    type CodeLensProvider<'T when 'T :> CodeLens> =
        /// <summary>
        /// An optional event to signal that the code lenses from this provider have changed.
        /// </summary>
        abstract member onDidChangeCodeLenses: Event<unit> option with get, set
        /// <summary>
        /// Compute a list of <see href="CodeLenslenses">CodeLenslenses</see>. This call should return as fast as possible and if
        /// computing the commands is expensive implementors should only return code lens objects with the
        /// range set and implement <see href="CodeLensProvider.resolveCodeLensresolve">CodeLensProvider.resolveCodeLensresolve</see>.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of code lenses or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideCodeLenses: document: TextDocument * token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// This function will be called for each visible code lens, usually when scrolling and after
        /// calls to <see href="CodeLensProvider.provideCodeLensescompute">CodeLensProvider.provideCodeLensescompute</see>-lenses.
        /// </summary>
        /// <param name="codeLens">
        /// Code lens that must be resolved.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The given, resolved code lens or thenable that resolves to such.
        /// </returns>
        abstract member resolveCodeLens: codeLens: 'T * token: CancellationToken -> ProviderResult<'T>

    /// <summary>
    /// Information about where a symbol is defined.
    ///
    /// Provides additional metadata over normal <see href="Location">Location</see> definitions, including the range of
    /// the defining symbol
    /// </summary>
    type DefinitionLink =
        LocationLink

    /// <summary>
    /// The definition of a symbol represented as one or many <see href="Locationlocations">Locationlocations</see>.
    /// For most programming languages there is only one location at which a symbol is
    /// defined.
    /// </summary>
    type Definition =
        U2<Location, ResizeArray<Location>>

    [<AllowNullLiteral>]
    [<Interface>]
    type DefinitionProvider =
        /// <summary>
        /// Provide the definition of the symbol at the given position and document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A definition or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideDefinition: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<U2<Definition, ResizeArray<DefinitionLink>>>

    [<AllowNullLiteral>]
    [<Interface>]
    type ImplementationProvider =
        /// <summary>
        /// Provide the implementations of the symbol at the given position and document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A definition or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideImplementation: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<U2<Definition, ResizeArray<DefinitionLink>>>

    [<AllowNullLiteral>]
    [<Interface>]
    type TypeDefinitionProvider =
        /// <summary>
        /// Provide the type definition of the symbol at the given position and document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A definition or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideTypeDefinition: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<U2<Definition, ResizeArray<DefinitionLink>>>

    /// <summary>
    /// The declaration of a symbol representation as one or many <see href="Locationlocations">Locationlocations</see>
    /// or <see href="LocationLinklocation">links</see>".
    /// </summary>
    type Declaration =
        U3<Location, ResizeArray<Location>, ResizeArray<LocationLink>>

    [<AllowNullLiteral>]
    [<Interface>]
    type DeclarationProvider =
        /// <summary>
        /// Provide the declaration of the symbol at the given position and document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A declaration or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideDeclaration: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<Declaration>

    /// <summary>
    /// Human-readable text that supports formatting via the [markdown syntax](https://commonmark.org).
    ///
    /// Rendering of <see href="ThemeIcontheme">icons</see>" via the <c>$(<name>)</c>-syntax is supported
    /// when the {@linkcode supportThemeIcons} is set to <c>true</c>.
    ///
    /// Rendering of embedded html is supported when {@linkcode supportHtml} is set to <c>true</c>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type MarkdownString =
        /// <summary>
        /// The markdown string.
        /// </summary>
        abstract member value: string with get, set
        /// <summary>
        /// Indicates that this markdown string is from a trusted source. Only *trusted*
        /// markdown supports links that execute commands, e.g. <c>[Run it](command:myCommandId)</c>.
        ///
        /// Defaults to <c>false</c> (commands are disabled).
        /// </summary>
        abstract member isTrusted: U2<bool, MarkdownString.isTrusted.U2.Case2> option with get, set
        /// <summary>
        /// Indicates that this markdown string can contain <see href="ThemeIconThemeIcons">ThemeIconThemeIcons</see>, e.g. <c>$(zap)</c>.
        /// </summary>
        abstract member supportThemeIcons: bool option with get, set
        /// <summary>
        /// Indicates that this markdown string can contain raw html tags. Defaults to <c>false</c>.
        ///
        /// When <c>supportHtml</c> is false, the markdown renderer will strip out any raw html tags
        /// that appear in the markdown text. This means you can only use markdown syntax for rendering.
        ///
        /// When <c>supportHtml</c> is true, the markdown render will also allow a safe subset of html tags
        /// and attributes to be rendered. See https://github.com/microsoft/vscode/blob/6d2920473c6f13759c978dd89104c4270a83422d/src/vs/base/browser/markdownRenderer.ts#L296
        /// for a list of all supported tags and attributes.
        /// </summary>
        abstract member supportHtml: bool option with get, set
        /// <summary>
        /// Uri that relative paths are resolved relative to.
        ///
        /// If the <c>baseUri</c> ends with <c>/</c>, it is considered a directory and relative paths in the markdown are resolved relative to that directory:
        ///
        /// <c></c><c>ts
        /// const md = new vscode.MarkdownString(</c>[link](./file.js)<c>);
        /// md.baseUri = vscode.Uri.file('/path/to/dir/');
        /// // Here 'link' in the rendered markdown resolves to '/path/to/dir/file.js'
        /// </c><c></c>
        ///
        /// If the <c>baseUri</c> is a file, relative paths in the markdown are resolved relative to the parent dir of that file:
        ///
        /// <c></c><c>ts
        /// const md = new vscode.MarkdownString(</c>[link](./file.js)<c>);
        /// md.baseUri = vscode.Uri.file('/path/to/otherFile.js');
        /// // Here 'link' in the rendered markdown resolves to '/path/to/file.js'
        /// </c><c></c>
        /// </summary>
        abstract member baseUri: Uri option with get, set
        /// <summary>
        /// Appends and escapes the given string to this markdown string.
        /// </summary>
        /// <param name="value">
        /// Plain text.
        /// </param>
        abstract member appendText: value: string -> MarkdownString
        /// <summary>
        /// Appends the given string 'as is' to this markdown string. When {@linkcode MarkdownString.supportThemeIconssupportThemeIcons} is <c>true</c>, <see href="ThemeIconThemeIcons">ThemeIconThemeIcons</see> in the <c>value</c> will be iconified.
        /// </summary>
        /// <param name="value">
        /// Markdown string.
        /// </param>
        abstract member appendMarkdown: value: string -> MarkdownString
        /// <summary>
        /// Appends the given string as codeblock using the provided language.
        /// </summary>
        /// <param name="value">
        /// A code snippet.
        /// </param>
        /// <param name="language">
        /// An optional <see href="languages.getLanguages">language identifier</see>".
        /// </param>
        abstract member appendCodeblock: value: string * ?language: string -> MarkdownString

    /// <summary>
    /// MarkedString can be used to render human-readable text. It is either a markdown string
    /// or a code-block that provides a language and a code snippet. Note that
    /// markdown strings will be sanitized - that means html will be escaped.
    /// </summary>
    [<Obsolete("This type is deprecated, please use {@linkcode MarkdownString } instead.")>]
    type MarkedString =
        U2<string, MarkedString.U2.Case2>

    /// <summary>
    /// A hover represents additional information for a symbol or word. Hovers are
    /// rendered in a tooltip-like widget.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Hover =
        /// <summary>
        /// The contents of this hover.
        /// </summary>
        abstract member contents: ResizeArray<U2<MarkdownString, MarkedString>> with get, set
        /// <summary>
        /// The range to which this hover applies. When missing, the
        /// editor will use the range at the current position or the
        /// current position itself.
        /// </summary>
        abstract member range: Range option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type HoverProvider =
        /// <summary>
        /// Provide a hover for the given position and document. Multiple hovers at the same
        /// position will be merged by the editor. A hover can have a range which defaults
        /// to the word range at the position when omitted.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A hover or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideHover: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<Hover>

    /// <summary>
    /// An EvaluatableExpression represents an expression in a document that can be evaluated by an active debugger or runtime.
    /// The result of this evaluation is shown in a tooltip-like widget.
    /// If only a range is specified, the expression will be extracted from the underlying document.
    /// An optional expression can be used to override the extracted expression.
    /// In this case the range is still used to highlight the range in the document.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type EvaluatableExpression =
        /// <summary>
        /// The range is used to extract the evaluatable expression from the underlying document and to highlight it.
        /// </summary>
        abstract member range: Range with get
        /// <summary>
        /// If specified the expression overrides the extracted expression.
        /// </summary>
        abstract member expression: string option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type EvaluatableExpressionProvider =
        /// <summary>
        /// Provide an evaluatable expression for the given document and position.
        /// The editor will evaluate this expression in the active debug session and will show the result in the debug hover.
        /// The expression can be implicitly specified by the range in the underlying document or by explicitly returning an expression.
        /// </summary>
        /// <param name="document">
        /// The document for which the debug hover is about to appear.
        /// </param>
        /// <param name="position">
        /// The line and character position in the document where the debug hover is about to appear.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An EvaluatableExpression or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideEvaluatableExpression: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<EvaluatableExpression>

    /// <summary>
    /// Provide inline value as text.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type InlineValueText =
        /// <summary>
        /// The document range for which the inline value applies.
        /// </summary>
        abstract member range: Range with get
        /// <summary>
        /// The text of the inline value.
        /// </summary>
        abstract member text: string with get

    /// <summary>
    /// Provide inline value through a variable lookup.
    /// If only a range is specified, the variable name will be extracted from the underlying document.
    /// An optional variable name can be used to override the extracted name.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type InlineValueVariableLookup =
        /// <summary>
        /// The document range for which the inline value applies.
        /// The range is used to extract the variable name from the underlying document.
        /// </summary>
        abstract member range: Range with get
        /// <summary>
        /// If specified the name of the variable to look up.
        /// </summary>
        abstract member variableName: string option with get
        /// <summary>
        /// How to perform the lookup.
        /// </summary>
        abstract member caseSensitiveLookup: bool with get

    /// <summary>
    /// Provide an inline value through an expression evaluation.
    /// If only a range is specified, the expression will be extracted from the underlying document.
    /// An optional expression can be used to override the extracted expression.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type InlineValueEvaluatableExpression =
        /// <summary>
        /// The document range for which the inline value applies.
        /// The range is used to extract the evaluatable expression from the underlying document.
        /// </summary>
        abstract member range: Range with get
        /// <summary>
        /// If specified the expression overrides the extracted expression.
        /// </summary>
        abstract member expression: string option with get

    /// <summary>
    /// Inline value information can be provided by different means:
    /// - directly as a text value (class InlineValueText).
    /// - as a name to use for a variable lookup (class InlineValueVariableLookup)
    /// - as an evaluatable expression (class InlineValueEvaluatableExpression)
    /// The InlineValue types combines all inline value types into one type.
    /// </summary>
    type InlineValue =
        U3<InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression>

    [<AllowNullLiteral>]
    [<Interface>]
    type InlineValueContext =
        /// <summary>
        /// The stack frame (as a DAP Id) where the execution has stopped.
        /// </summary>
        abstract member frameId: float with get
        /// <summary>
        /// The document range where execution has stopped.
        /// Typically the end position of the range denotes the line where the inline values are shown.
        /// </summary>
        abstract member stoppedLocation: Range with get

    [<AllowNullLiteral>]
    [<Interface>]
    type InlineValuesProvider =
        /// <summary>
        /// An optional event to signal that inline values have changed.
        /// </summary>
        abstract member onDidChangeInlineValues: Event<unit> option with get, set
        /// <summary>
        /// Provide "inline value" information for a given document and range.
        /// The editor calls this method whenever debugging stops in the given document.
        /// The returned inline values information is rendered in the editor at the end of lines.
        /// </summary>
        /// <param name="document">
        /// The document for which the inline values information is needed.
        /// </param>
        /// <param name="viewPort">
        /// The visible document range for which inline values should be computed.
        /// </param>
        /// <param name="context">
        /// A bag containing contextual information like the current location.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of InlineValueDescriptors or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideInlineValues: document: TextDocument * viewPort: Range * context: InlineValueContext * token: CancellationToken -> ProviderResult<ResizeArray<InlineValue>>

    [<RequireQualifiedAccess>]
    type DocumentHighlightKind =
        | Text = 0
        | Read = 1
        | Write = 2

    /// <summary>
    /// A document highlight is a range inside a text document which deserves
    /// special attention. Usually a document highlight is visualized by changing
    /// the background color of its range.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentHighlight =
        /// <summary>
        /// The range this highlight applies to.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The highlight kind, default is <see href="DocumentHighlightKind.Texttext">DocumentHighlightKind.Texttext</see>.
        /// </summary>
        abstract member kind: DocumentHighlightKind option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentHighlightProvider =
        /// <summary>
        /// Provide a set of document highlights, like all occurrences of a variable or
        /// all exit-points of a function.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of document highlights or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideDocumentHighlights: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<ResizeArray<DocumentHighlight>>

    [<RequireQualifiedAccess>]
    type SymbolKind =
        | File = 0
        | Module = 1
        | Namespace = 2
        | Package = 3
        | Class = 4
        | Method = 5
        | Property = 6
        | Field = 7
        | Constructor = 8
        | Enum = 9
        | Interface = 10
        | Function = 11
        | Variable = 12
        | Constant = 13
        | String = 14
        | Number = 15
        | Boolean = 16
        | Array = 17
        | Object = 18
        | Key = 19
        | Null = 20
        | EnumMember = 21
        | Struct = 22
        | Event = 23
        | Operator = 24
        | TypeParameter = 25

    [<RequireQualifiedAccess>]
    type SymbolTag =
        | Deprecated = 1

    /// <summary>
    /// Represents information about programming constructs like variables, classes,
    /// interfaces etc.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SymbolInformation =
        /// <summary>
        /// The name of this symbol.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The name of the symbol containing this symbol.
        /// </summary>
        abstract member containerName: string with get, set
        /// <summary>
        /// The kind of this symbol.
        /// </summary>
        abstract member kind: SymbolKind with get, set
        /// <summary>
        /// Tags for this symbol.
        /// </summary>
        abstract member tags: ReadonlyArray<SymbolTag> option with get, set
        /// <summary>
        /// The location of this symbol.
        /// </summary>
        abstract member location: Location with get, set

    /// <summary>
    /// Represents programming constructs like variables, classes, interfaces etc. that appear in a document. Document
    /// symbols can be hierarchical and they have two ranges: one that encloses its definition and one that points to
    /// its most interesting range, e.g. the range of an identifier.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentSymbol =
        /// <summary>
        /// The name of this symbol.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// More detail for this symbol, e.g. the signature of a function.
        /// </summary>
        abstract member detail: string with get, set
        /// <summary>
        /// The kind of this symbol.
        /// </summary>
        abstract member kind: SymbolKind with get, set
        /// <summary>
        /// Tags for this symbol.
        /// </summary>
        abstract member tags: ReadonlyArray<SymbolTag> option with get, set
        /// <summary>
        /// The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The range that should be selected and reveal when this symbol is being picked, e.g. the name of a function.
        /// Must be contained by the {@linkcode DocumentSymbol.rangerange}.
        /// </summary>
        abstract member selectionRange: Range with get, set
        /// <summary>
        /// Children of this symbol, e.g. properties of a class.
        /// </summary>
        abstract member children: ResizeArray<DocumentSymbol> with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentSymbolProvider =
        /// <summary>
        /// Provide symbol information for the given document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of document highlights or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideDocumentSymbols: document: TextDocument * token: CancellationToken -> ProviderResult<U2<ResizeArray<SymbolInformation>, ResizeArray<DocumentSymbol>>>

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentSymbolProviderMetadata =
        /// <summary>
        /// A human-readable string that is shown when multiple outlines trees show for one document.
        /// </summary>
        abstract member label: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type WorkspaceSymbolProvider<'T when 'T :> SymbolInformation> =
        /// <summary>
        /// Project-wide search for a symbol matching the given query string.
        ///
        /// The <c>query</c>-parameter should be interpreted in a *relaxed way* as the editor will apply its own highlighting
        /// and scoring on the results. A good rule of thumb is to match case-insensitive and to simply check that the
        /// characters of *query* appear in their order in a candidate symbol. Don't use prefix, substring, or similar
        /// strict matching.
        ///
        /// To improve performance implementors can implement <c>resolveWorkspaceSymbol</c> and then provide symbols with partial
        /// <see href="SymbolInformation.locationlocation">SymbolInformation.locationlocation</see>-objects, without a <c>range</c> defined. The editor will then call
        /// <c>resolveWorkspaceSymbol</c> for selected symbols only, e.g. when opening a workspace symbol.
        /// </summary>
        /// <param name="query">
        /// A query string, can be the empty string in which case all symbols should be returned.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of document highlights or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideWorkspaceSymbols: query: string * token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// Given a symbol fill in its <see href="SymbolInformation.locationlocation">SymbolInformation.locationlocation</see>. This method is called whenever a symbol
        /// is selected in the UI. Providers can implement this method and return incomplete symbols from
        /// {@linkcode WorkspaceSymbolProvider.provideWorkspaceSymbolsprovideWorkspaceSymbols} which often helps to improve
        /// performance.
        /// </summary>
        /// <param name="symbol">
        /// The symbol that is to be resolved. Guaranteed to be an instance of an object returned from an
        /// earlier call to <c>provideWorkspaceSymbols</c>.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved symbol or a thenable that resolves to that. When no result is returned,
        /// the given <c>symbol</c> is used.
        /// </returns>
        abstract member resolveWorkspaceSymbol: symbol: 'T * token: CancellationToken -> ProviderResult<'T>

    [<AllowNullLiteral>]
    [<Interface>]
    type ReferenceContext =
        /// <summary>
        /// Include the declaration of the current symbol.
        /// </summary>
        abstract member includeDeclaration: bool with get

    [<AllowNullLiteral>]
    [<Interface>]
    type ReferenceProvider =
        /// <summary>
        /// Provide a set of project-wide references for the given position and document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="context">
        /// Additional information about the references request.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of locations or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideReferences: document: TextDocument * position: Position * context: ReferenceContext * token: CancellationToken -> ProviderResult<ResizeArray<Location>>

    /// <summary>
    /// A text edit represents edits that should be applied
    /// to a document.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TextEdit =
        /// <summary>
        /// Utility to create a replace edit.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <param name="newText">
        /// A string.
        /// </param>
        /// <returns>
        /// A new text edit object.
        /// </returns>
        static member inline replace (range: Range, newText: string): TextEdit =
            emitJsExpr (range, newText) $$"""
import { TextEdit } from "vscode";
TextEdit.replace($0, $1)"""
        /// <summary>
        /// Utility to create an insert edit.
        /// </summary>
        /// <param name="position">
        /// A position, will become an empty range.
        /// </param>
        /// <param name="newText">
        /// A string.
        /// </param>
        /// <returns>
        /// A new text edit object.
        /// </returns>
        static member inline insert (position: Position, newText: string): TextEdit =
            emitJsExpr (position, newText) $$"""
import { TextEdit } from "vscode";
TextEdit.insert($0, $1)"""
        /// <summary>
        /// Utility to create a delete edit.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <returns>
        /// A new text edit object.
        /// </returns>
        static member inline delete (range: Range): TextEdit =
            emitJsExpr (range) $$"""
import { TextEdit } from "vscode";
TextEdit.delete($0)"""
        /// <summary>
        /// Utility to create an eol-edit.
        /// </summary>
        /// <param name="eol">
        /// An eol-sequence
        /// </param>
        /// <returns>
        /// A new text edit object.
        /// </returns>
        static member inline setEndOfLine (eol: EndOfLine): TextEdit =
            emitJsExpr (eol) $$"""
import { TextEdit } from "vscode";
TextEdit.setEndOfLine($0)"""
        /// <summary>
        /// The range this edit applies to.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The string this edit will insert.
        /// </summary>
        abstract member newText: string with get, set
        /// <summary>
        /// The eol-sequence used in the document.
        ///
        /// *Note* that the eol-sequence will be applied to the
        /// whole document.
        /// </summary>
        abstract member newEol: EndOfLine option with get, set

    /// <summary>
    /// A snippet edit represents an interactive edit that is performed by
    /// the editor.
    ///
    /// *Note* that a snippet edit can always be performed as a normal <see href="TextEdittext">edit</see>".
    /// This will happen when no matching editor is open or when a <see href="WorkspaceEditworkspace">edit</see>"
    /// contains snippet edits for multiple files. In that case only those that match the active editor
    /// will be performed as snippet edits and the others as normal text edits.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SnippetTextEdit =
        /// <summary>
        /// Utility to create a replace snippet edit.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <param name="snippet">
        /// A snippet string.
        /// </param>
        /// <returns>
        /// A new snippet edit object.
        /// </returns>
        static member inline replace (range: Range, snippet: SnippetString): SnippetTextEdit =
            emitJsExpr (range, snippet) $$"""
import { SnippetTextEdit } from "vscode";
SnippetTextEdit.replace($0, $1)"""
        /// <summary>
        /// Utility to create an insert snippet edit.
        /// </summary>
        /// <param name="position">
        /// A position, will become an empty range.
        /// </param>
        /// <param name="snippet">
        /// A snippet string.
        /// </param>
        /// <returns>
        /// A new snippet edit object.
        /// </returns>
        static member inline insert (position: Position, snippet: SnippetString): SnippetTextEdit =
            emitJsExpr (position, snippet) $$"""
import { SnippetTextEdit } from "vscode";
SnippetTextEdit.insert($0, $1)"""
        /// <summary>
        /// The range this edit applies to.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The <see href="SnippetStringsnippet">SnippetStringsnippet</see> this edit will perform.
        /// </summary>
        abstract member snippet: SnippetString with get, set
        /// <summary>
        /// Whether the snippet edit should be applied with existing whitespace preserved.
        /// </summary>
        abstract member keepWhitespace: bool option with get, set

    /// <summary>
    /// A notebook edit represents edits that should be applied to the contents of a notebook.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookEdit =
        /// <summary>
        /// Utility to create a edit that replaces cells in a notebook.
        /// </summary>
        /// <param name="range">
        /// The range of cells to replace
        /// </param>
        /// <param name="newCells">
        /// The new notebook cells.
        /// </param>
        static member inline replaceCells (range: NotebookRange, newCells: ResizeArray<NotebookCellData>): NotebookEdit =
            emitJsExpr (range, newCells) $$"""
import { NotebookEdit } from "vscode";
NotebookEdit.replaceCells($0, $1)"""
        /// <summary>
        /// Utility to create an edit that replaces cells in a notebook.
        /// </summary>
        /// <param name="index">
        /// The index to insert cells at.
        /// </param>
        /// <param name="newCells">
        /// The new notebook cells.
        /// </param>
        static member inline insertCells (index: float, newCells: ResizeArray<NotebookCellData>): NotebookEdit =
            emitJsExpr (index, newCells) $$"""
import { NotebookEdit } from "vscode";
NotebookEdit.insertCells($0, $1)"""
        /// <summary>
        /// Utility to create an edit that deletes cells in a notebook.
        /// </summary>
        /// <param name="range">
        /// The range of cells to delete.
        /// </param>
        static member inline deleteCells (range: NotebookRange): NotebookEdit =
            emitJsExpr (range) $$"""
import { NotebookEdit } from "vscode";
NotebookEdit.deleteCells($0)"""
        /// <summary>
        /// Utility to create an edit that update a cell's metadata.
        /// </summary>
        /// <param name="index">
        /// The index of the cell to update.
        /// </param>
        /// <param name="newCellMetadata">
        /// The new metadata for the cell.
        /// </param>
        static member inline updateCellMetadata (index: float, newCellMetadata: NotebookEdit.updateCellMetadata.newCellMetadata): NotebookEdit =
            emitJsExpr (index, newCellMetadata) $$"""
import { NotebookEdit } from "vscode";
NotebookEdit.updateCellMetadata($0, $1)"""
        /// <summary>
        /// Utility to create an edit that updates the notebook's metadata.
        /// </summary>
        /// <param name="newNotebookMetadata">
        /// The new metadata for the notebook.
        /// </param>
        static member inline updateNotebookMetadata (newNotebookMetadata: NotebookEdit.updateNotebookMetadata.newNotebookMetadata): NotebookEdit =
            emitJsExpr (newNotebookMetadata) $$"""
import { NotebookEdit } from "vscode";
NotebookEdit.updateNotebookMetadata($0)"""
        /// <summary>
        /// Range of the cells being edited. May be empty.
        /// </summary>
        abstract member range: NotebookRange with get, set
        /// <summary>
        /// New cells being inserted. May be empty.
        /// </summary>
        abstract member newCells: ResizeArray<NotebookCellData> with get, set
        /// <summary>
        /// Optional new metadata for the cells.
        /// </summary>
        abstract member newCellMetadata: NotebookEdit.newCellMetadata option with get, set
        /// <summary>
        /// Optional new metadata for the notebook.
        /// </summary>
        abstract member newNotebookMetadata: NotebookEdit.newNotebookMetadata option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type WorkspaceEditEntryMetadata =
        /// <summary>
        /// A flag which indicates that user confirmation is needed.
        /// </summary>
        abstract member needsConfirmation: bool with get, set
        /// <summary>
        /// A human-readable string which is rendered prominent.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// A human-readable string which is rendered less prominent on the same line.
        /// </summary>
        abstract member description: string option with get, set
        /// <summary>
        /// The icon path or <see href="ThemeIcon">ThemeIcon</see> for the edit.
        /// </summary>
        abstract member iconPath: IconPath option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type WorkspaceEditMetadata =
        /// <summary>
        /// Signal to the editor that this edit is a refactoring.
        /// </summary>
        abstract member isRefactoring: bool option with get, set

    /// <summary>
    /// A workspace edit is a collection of textual and files changes for
    /// multiple resources and documents.
    ///
    /// Use the <see href="workspace.applyEditapplyEdit">workspace.applyEditapplyEdit</see>-function to apply a workspace edit.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type WorkspaceEdit =
        /// <summary>
        /// The number of affected resources of textual or resource changes.
        /// </summary>
        abstract member size: float with get
        /// <summary>
        /// Replace the given range with given text for the given resource.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <param name="newText">
        /// A string.
        /// </param>
        /// <param name="metadata">
        /// Optional metadata for the entry.
        /// </param>
        abstract member replace: uri: Uri * range: Range * newText: string * ?metadata: WorkspaceEditEntryMetadata -> unit
        /// <summary>
        /// Insert the given text at the given position.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <param name="position">
        /// A position.
        /// </param>
        /// <param name="newText">
        /// A string.
        /// </param>
        /// <param name="metadata">
        /// Optional metadata for the entry.
        /// </param>
        abstract member insert: uri: Uri * position: Position * newText: string * ?metadata: WorkspaceEditEntryMetadata -> unit
        /// <summary>
        /// Delete the text at the given range.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <param name="metadata">
        /// Optional metadata for the entry.
        /// </param>
        abstract member delete: uri: Uri * range: Range * ?metadata: WorkspaceEditEntryMetadata -> unit
        /// <summary>
        /// Check if a text edit for a resource exists.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <returns>
        /// <c>true</c> if the given resource will be touched by this edit.
        /// </returns>
        abstract member has: uri: Uri -> bool
        /// <summary>
        /// Set (and replace) text edits or snippet edits for a resource.
        /// Set (and replace) text edits or snippet edits with metadata for a resource.
        /// Set (and replace) notebook edits for a resource.
        /// Set (and replace) notebook edits with metadata for a resource.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <param name="edits">
        /// An array of edits.
        /// </param>
        abstract member set: uri: Uri * edits: ReadonlyArray<U2<TextEdit, SnippetTextEdit>> -> unit
        /// <summary>
        /// Set (and replace) text edits or snippet edits for a resource.
        /// Set (and replace) text edits or snippet edits with metadata for a resource.
        /// Set (and replace) notebook edits for a resource.
        /// Set (and replace) notebook edits with metadata for a resource.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <param name="edits">
        /// An array of edits.
        /// </param>
        abstract member set: uri: Uri * edits: ReadonlyArray<U2<TextEdit, SnippetTextEdit> * WorkspaceEditEntryMetadata option> -> unit
        /// <summary>
        /// Set (and replace) text edits or snippet edits for a resource.
        /// Set (and replace) text edits or snippet edits with metadata for a resource.
        /// Set (and replace) notebook edits for a resource.
        /// Set (and replace) notebook edits with metadata for a resource.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <param name="edits">
        /// An array of edits.
        /// </param>
        abstract member set: uri: Uri * edits: ReadonlyArray<NotebookEdit> -> unit
        /// <summary>
        /// Set (and replace) text edits or snippet edits for a resource.
        /// Set (and replace) text edits or snippet edits with metadata for a resource.
        /// Set (and replace) notebook edits for a resource.
        /// Set (and replace) notebook edits with metadata for a resource.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <param name="edits">
        /// An array of edits.
        /// </param>
        abstract member set: uri: Uri * edits: ReadonlyArray<NotebookEdit * WorkspaceEditEntryMetadata option> -> unit
        /// <summary>
        /// Get the text edits for a resource.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <returns>
        /// An array of text edits.
        /// </returns>
        abstract member get: uri: Uri -> ResizeArray<TextEdit>
        /// <summary>
        /// Create a regular file.
        /// </summary>
        /// <param name="uri">
        /// Uri of the new file.
        /// </param>
        /// <param name="options">
        /// Defines if an existing file should be overwritten or be
        /// ignored. When <c>overwrite</c> and <c>ignoreIfExists</c> are both set <c>overwrite</c> wins.
        /// When both are unset and when the file already exists then the edit cannot
        /// be applied successfully. The <c>content</c>-property allows to set the initial contents
        /// the file is being created with.
        /// </param>
        /// <param name="metadata">
        /// Optional metadata for the entry.
        /// </param>
        abstract member createFile: uri: Uri * ?options: WorkspaceEdit.createFile.options * ?metadata: WorkspaceEditEntryMetadata -> unit
        /// <summary>
        /// Delete a file or folder.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file that is to be deleted.
        /// </param>
        /// <param name="metadata">
        /// Optional metadata for the entry.
        /// </param>
        abstract member deleteFile: uri: Uri * ?options: WorkspaceEdit.deleteFile.options * ?metadata: WorkspaceEditEntryMetadata -> unit
        /// <summary>
        /// Rename a file or folder.
        /// </summary>
        /// <param name="oldUri">
        /// The existing file.
        /// </param>
        /// <param name="newUri">
        /// The new location.
        /// </param>
        /// <param name="options">
        /// Defines if existing files should be overwritten or be
        /// ignored. When overwrite and ignoreIfExists are both set overwrite wins.
        /// </param>
        /// <param name="metadata">
        /// Optional metadata for the entry.
        /// </param>
        abstract member renameFile: oldUri: Uri * newUri: Uri * ?options: WorkspaceEdit.renameFile.options * ?metadata: WorkspaceEditEntryMetadata -> unit
        /// <summary>
        /// Get all text edits grouped by resource.
        /// </summary>
        /// <returns>
        /// A shallow copy of <c>[Uri, TextEdit[]]</c>-tuples.
        /// </returns>
        abstract member entries: unit -> ResizeArray<Uri * ResizeArray<TextEdit>>

    /// <summary>
    /// A snippet string is a template which allows to insert text
    /// and to control the editor cursor when insertion happens.
    ///
    /// A snippet can define tab stops and placeholders with <c>$1</c>, <c>$2</c>
    /// and <c>${3:foo}</c>. <c>$0</c> defines the final tab stop, it defaults to
    /// the end of the snippet. Variables are defined with <c>$name</c> and
    /// <c>${name:default value}</c>. Also see
    /// [the full snippet syntax](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_create-your-own-snippets).
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SnippetString =
        /// <summary>
        /// The snippet string.
        /// </summary>
        abstract member value: string with get, set
        /// <summary>
        /// Builder-function that appends the given string to
        /// the {@linkcode SnippetString.valuevalue} of this snippet string.
        /// </summary>
        /// <param name="string">
        /// A value to append 'as given'. The string will be escaped.
        /// </param>
        /// <returns>
        /// This snippet string.
        /// </returns>
        abstract member appendText: string: string -> SnippetString
        /// <summary>
        /// Builder-function that appends a tabstop (<c>$1</c>, <c>$2</c> etc) to
        /// the {@linkcode SnippetString.valuevalue} of this snippet string.
        /// </summary>
        /// <param name="number">
        /// The number of this tabstop, defaults to an auto-increment
        /// value starting at 1.
        /// </param>
        /// <returns>
        /// This snippet string.
        /// </returns>
        abstract member appendTabstop: ?number: float -> SnippetString
        /// <summary>
        /// Builder-function that appends a placeholder (<c>${1:value}</c>) to
        /// the {@linkcode SnippetString.valuevalue} of this snippet string.
        /// </summary>
        /// <param name="value">
        /// The value of this placeholder - either a string or a function
        /// with which a nested snippet can be created.
        /// </param>
        /// <param name="number">
        /// The number of this tabstop, defaults to an auto-increment
        /// value starting at 1.
        /// </param>
        /// <returns>
        /// This snippet string.
        /// </returns>
        abstract member appendPlaceholder: value: U2<string, (SnippetString -> obj)> * ?number: float -> SnippetString
        /// <summary>
        /// Builder-function that appends a choice (<c>${1|a,b,c|}</c>) to
        /// the {@linkcode SnippetString.valuevalue} of this snippet string.
        /// </summary>
        /// <param name="values">
        /// The values for choices - the array of strings
        /// </param>
        /// <param name="number">
        /// The number of this tabstop, defaults to an auto-increment
        /// value starting at 1.
        /// </param>
        /// <returns>
        /// This snippet string.
        /// </returns>
        abstract member appendChoice: values: ReadonlyArray<string> * ?number: float -> SnippetString
        /// <summary>
        /// Builder-function that appends a variable (<c>${VAR}</c>) to
        /// the {@linkcode SnippetString.valuevalue} of this snippet string.
        /// </summary>
        /// <param name="name">
        /// The name of the variable - excluding the <c>$</c>.
        /// </param>
        /// <param name="defaultValue">
        /// The default value which is used when the variable name cannot
        /// be resolved - either a string or a function with which a nested snippet can be created.
        /// </param>
        /// <returns>
        /// This snippet string.
        /// </returns>
        abstract member appendVariable: name: string * defaultValue: U2<string, (SnippetString -> obj)> -> SnippetString

    [<AllowNullLiteral>]
    [<Interface>]
    type RenameProvider =
        /// <summary>
        /// Provide an edit that describes changes that have to be made to one
        /// or many resources to rename a symbol to a different name.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="newName">
        /// The new name of the symbol. If the given name is not valid, the provider must return a rejected promise.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A workspace edit or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideRenameEdits: document: TextDocument * position: Position * newName: string * token: CancellationToken -> ProviderResult<WorkspaceEdit>
        /// <summary>
        /// Optional function for resolving and validating a position *before* running rename. The result can
        /// be a range or a range and a placeholder text. The placeholder text should be the identifier of the symbol
        /// which is being renamed - when omitted the text in the returned range is used.
        ///
        /// *Note:* This function should throw an error or return a rejected thenable when the provided location
        /// doesn't allow for a rename.
        /// </summary>
        /// <param name="document">
        /// The document in which rename will be invoked.
        /// </param>
        /// <param name="position">
        /// The position at which rename will be invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The range or range and placeholder text of the identifier that is to be renamed. The lack of a result can signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member prepareRename: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<U2<Range, RenameProvider.prepareRename.U2.Case2>>

    /// <summary>
    /// A semantic tokens legend contains the needed information to decipher
    /// the integer encoded representation of semantic tokens.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SemanticTokensLegend =
        /// <summary>
        /// The possible token types.
        /// </summary>
        abstract member tokenTypes: ResizeArray<string> with get
        /// <summary>
        /// The possible token modifiers.
        /// </summary>
        abstract member tokenModifiers: ResizeArray<string> with get

    /// <summary>
    /// A semantic tokens builder can help with creating a <c>SemanticTokens</c> instance
    /// which contains delta encoded semantic tokens.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SemanticTokensBuilder =
        /// <summary>
        /// Add another token.
        /// Add another token. Use only when providing a legend.
        /// </summary>
        /// <param name="line">
        /// The token start line number (absolute value).
        /// </param>
        /// <param name="char">
        /// The token start character (absolute value).
        /// </param>
        /// <param name="length">
        /// The token length in characters.
        /// </param>
        /// <param name="tokenType">
        /// The encoded token type.
        /// </param>
        /// <param name="tokenModifiers">
        /// The encoded token modifiers.
        /// </param>
        abstract member push: line: float * char: float * length: float * tokenType: float * ?tokenModifiers: float -> unit
        /// <summary>
        /// Add another token.
        /// Add another token. Use only when providing a legend.
        /// </summary>
        /// <param name="range">
        /// The range of the token. Must be single-line.
        /// </param>
        /// <param name="tokenType">
        /// The token type.
        /// </param>
        /// <param name="tokenModifiers">
        /// The token modifiers.
        /// </param>
        abstract member push: range: Range * tokenType: string * ?tokenModifiers: ReadonlyArray<string> -> unit
        /// <summary>
        /// Finish and create a <c>SemanticTokens</c> instance.
        /// </summary>
        abstract member build: ?resultId: string -> SemanticTokens

    /// <summary>
    /// Represents semantic tokens, either in a range or in an entire document.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SemanticTokens =
        /// <summary>
        /// The result id of the tokens.
        ///
        /// This is the id that will be passed to <c>DocumentSemanticTokensProvider.provideDocumentSemanticTokensEdits</c> (if implemented).
        /// </summary>
        abstract member resultId: string option with get
        /// <summary>
        /// The actual tokens data.
        /// </summary>
        abstract member data: JS.Uint32Array with get

    /// <summary>
    /// Represents edits to semantic tokens.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SemanticTokensEdits =
        /// <summary>
        /// The result id of the tokens.
        ///
        /// This is the id that will be passed to <c>DocumentSemanticTokensProvider.provideDocumentSemanticTokensEdits</c> (if implemented).
        /// </summary>
        abstract member resultId: string option with get
        /// <summary>
        /// The edits to the tokens data.
        /// All edits refer to the initial data state.
        /// </summary>
        abstract member edits: ResizeArray<SemanticTokensEdit> with get

    /// <summary>
    /// Represents an edit to semantic tokens.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SemanticTokensEdit =
        /// <summary>
        /// The start offset of the edit.
        /// </summary>
        abstract member start: float with get
        /// <summary>
        /// The count of elements to remove.
        /// </summary>
        abstract member deleteCount: float with get
        /// <summary>
        /// The elements to insert.
        /// </summary>
        abstract member data: JS.Uint32Array option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentSemanticTokensProvider =
        /// <summary>
        /// An optional event to signal that the semantic tokens from this provider have changed.
        /// </summary>
        abstract member onDidChangeSemanticTokens: Event<unit> option with get, set
        /// <summary>
        /// Tokens in a file are represented as an array of integers. The position of each token is expressed relative to
        /// the token before it, because most tokens remain stable relative to each other when edits are made in a file.
        ///
        /// ---
        /// In short, each token takes 5 integers to represent, so a specific token <c>i</c> in the file consists of the following array indices:
        ///  - at index <c>5*i</c>   - <c>deltaLine</c>: token line number, relative to the previous token
        ///  - at index <c>5*i+1</c> - <c>deltaStart</c>: token start character, relative to the previous token (relative to 0 or the previous token's start if they are on the same line)
        ///  - at index <c>5*i+2</c> - <c>length</c>: the length of the token. A token cannot be multiline.
        ///  - at index <c>5*i+3</c> - <c>tokenType</c>: will be looked up in <c>SemanticTokensLegend.tokenTypes</c>. We currently ask that <c>tokenType</c> < 65536.
        ///  - at index <c>5*i+4</c> - <c>tokenModifiers</c>: each set bit will be looked up in <c>SemanticTokensLegend.tokenModifiers</c>
        ///
        /// ---
        /// ### How to encode tokens
        ///
        /// Here is an example for encoding a file with 3 tokens in a uint32 array:
        /// <code>
        ///    { line: 2, startChar:  5, length: 3, tokenType: "property",  tokenModifiers: ["private", "static"] },
        ///    { line: 2, startChar: 10, length: 4, tokenType: "type",      tokenModifiers: [] },
        ///    { line: 5, startChar:  2, length: 7, tokenType: "class",     tokenModifiers: [] }
        /// </code>
        ///
        /// 1. First of all, a legend must be devised. This legend must be provided up-front and capture all possible token types.
        /// For this example, we will choose the following legend which must be passed in when registering the provider:
        /// <code>
        ///    tokenTypes: ['property', 'type', 'class'],
        ///    tokenModifiers: ['private', 'static']
        /// </code>
        ///
        /// 2. The first transformation step is to encode <c>tokenType</c> and <c>tokenModifiers</c> as integers using the legend. Token types are looked
        /// up by index, so a <c>tokenType</c> value of <c>1</c> means <c>tokenTypes[1]</c>. Multiple token modifiers can be set by using bit flags,
        /// so a <c>tokenModifier</c> value of <c>3</c> is first viewed as binary <c>0b00000011</c>, which means <c>[tokenModifiers[0], tokenModifiers[1]]</c> because
        /// bits 0 and 1 are set. Using this legend, the tokens now are:
        /// <code>
        ///    { line: 2, startChar:  5, length: 3, tokenType: 0, tokenModifiers: 3 },
        ///    { line: 2, startChar: 10, length: 4, tokenType: 1, tokenModifiers: 0 },
        ///    { line: 5, startChar:  2, length: 7, tokenType: 2, tokenModifiers: 0 }
        /// </code>
        ///
        /// 3. The next step is to represent each token relative to the previous token in the file. In this case, the second token
        /// is on the same line as the first token, so the <c>startChar</c> of the second token is made relative to the <c>startChar</c>
        /// of the first token, so it will be <c>10 - 5</c>. The third token is on a different line than the second token, so the
        /// <c>startChar</c> of the third token will not be altered:
        /// <code>
        ///    { deltaLine: 2, deltaStartChar: 5, length: 3, tokenType: 0, tokenModifiers: 3 },
        ///    { deltaLine: 0, deltaStartChar: 5, length: 4, tokenType: 1, tokenModifiers: 0 },
        ///    { deltaLine: 3, deltaStartChar: 2, length: 7, tokenType: 2, tokenModifiers: 0 }
        /// </code>
        ///
        /// 4. Finally, the last step is to inline each of the 5 fields for a token in a single array, which is a memory friendly representation:
        /// <code>
        ///    // 1st token,  2nd token,  3rd token
        ///    [  2,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ]
        /// </code>
        /// </summary>
        abstract member provideDocumentSemanticTokens: document: TextDocument * token: CancellationToken -> ProviderResult<SemanticTokens>
        /// <summary>
        /// Instead of always returning all the tokens in a file, it is possible for a <c>DocumentSemanticTokensProvider</c> to implement
        /// this method (<c>provideDocumentSemanticTokensEdits</c>) and then return incremental updates to the previously provided semantic tokens.
        ///
        /// ---
        /// ### How tokens change when the document changes
        ///
        /// Suppose that <c>provideDocumentSemanticTokens</c> has previously returned the following semantic tokens:
        /// <code>
        ///    // 1st token,  2nd token,  3rd token
        ///    [  2,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ]
        /// </code>
        ///
        /// Also suppose that after some edits, the new semantic tokens in a file are:
        /// <code>
        ///    // 1st token,  2nd token,  3rd token
        ///    [  3,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ]
        /// </code>
        /// It is possible to express these new tokens in terms of an edit applied to the previous tokens:
        /// <code>
        ///    [  2,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ] // old tokens
        ///    [  3,5,3,0,3,  0,5,4,1,0,  3,2,7,2,0 ] // new tokens
        ///
        ///    edit: { start:  0, deleteCount: 1, data: [3] } // replace integer at offset 0 with 3
        /// </code>
        ///
        /// *NOTE*: If the provider cannot compute <c>SemanticTokensEdits</c>, it can "give up" and return all the tokens in the document again.
        /// *NOTE*: All edits in <c>SemanticTokensEdits</c> contain indices in the old integers array, so they all refer to the previous result state.
        /// </summary>
        abstract member provideDocumentSemanticTokensEdits: document: TextDocument * previousResultId: string * token: CancellationToken -> ProviderResult<U2<SemanticTokens, SemanticTokensEdits>>

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentRangeSemanticTokensProvider =
        /// <summary>
        /// An optional event to signal that the semantic tokens from this provider have changed.
        /// </summary>
        abstract member onDidChangeSemanticTokens: Event<unit> option with get, set
        abstract member provideDocumentRangeSemanticTokens: document: TextDocument * range: Range * token: CancellationToken -> ProviderResult<SemanticTokens>

    [<AllowNullLiteral>]
    [<Interface>]
    type FormattingOptions =
        /// <summary>
        /// Size of a tab in spaces.
        /// </summary>
        abstract member tabSize: float with get, set
        /// <summary>
        /// Prefer spaces over tabs.
        /// </summary>
        abstract member insertSpaces: bool with get, set
        [<EmitIndexer>]
        abstract member Item: key: string -> U3<bool, float, string> with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentFormattingEditProvider =
        /// <summary>
        /// Provide formatting edits for a whole document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="options">
        /// Options controlling formatting.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A set of text edits or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideDocumentFormattingEdits: document: TextDocument * options: FormattingOptions * token: CancellationToken -> ProviderResult<ResizeArray<TextEdit>>

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentRangeFormattingEditProvider =
        /// <summary>
        /// Provide formatting edits for a range in a document.
        ///
        /// The given range is a hint and providers can decide to format a smaller
        /// or larger range. Often this is done by adjusting the start and end
        /// of the range to full syntax nodes.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="range">
        /// The range which should be formatted.
        /// </param>
        /// <param name="options">
        /// Options controlling formatting.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A set of text edits or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideDocumentRangeFormattingEdits: document: TextDocument * range: Range * options: FormattingOptions * token: CancellationToken -> ProviderResult<ResizeArray<TextEdit>>
        /// <summary>
        /// Provide formatting edits for multiple ranges in a document.
        ///
        /// This function is optional but allows a formatter to perform faster when formatting only modified ranges or when
        /// formatting a large number of selections.
        ///
        /// The given ranges are hints and providers can decide to format a smaller
        /// or larger range. Often this is done by adjusting the start and end
        /// of the range to full syntax nodes.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="ranges">
        /// The ranges which should be formatted.
        /// </param>
        /// <param name="options">
        /// Options controlling formatting.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A set of text edits or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideDocumentRangesFormattingEdits: document: TextDocument * ranges: ResizeArray<Range> * options: FormattingOptions * token: CancellationToken -> ProviderResult<ResizeArray<TextEdit>>

    [<AllowNullLiteral>]
    [<Interface>]
    type OnTypeFormattingEditProvider =
        /// <summary>
        /// Provide formatting edits after a character has been typed.
        ///
        /// The given position and character should hint to the provider
        /// what range the position to expand to, like find the matching <c>{</c>
        /// when <c>}</c> has been entered.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="ch">
        /// The character that has been typed.
        /// </param>
        /// <param name="options">
        /// Options controlling formatting.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A set of text edits or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideOnTypeFormattingEdits: document: TextDocument * position: Position * ch: string * options: FormattingOptions * token: CancellationToken -> ProviderResult<ResizeArray<TextEdit>>

    /// <summary>
    /// Represents a parameter of a callable-signature. A parameter can
    /// have a label and a doc-comment.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ParameterInformation =
        /// <summary>
        /// The label of this signature.
        ///
        /// Either a string or inclusive start and exclusive end offsets within its containing
        /// <see href="SignatureInformation.labelsignature">label</see>". *Note*: A label of type string must be
        /// a substring of its containing signature information's <see href="SignatureInformation.labellabel">SignatureInformation.labellabel</see>.
        /// </summary>
        abstract member label: U2<string, float * float> with get, set
        /// <summary>
        /// The human-readable doc-comment of this signature. Will be shown
        /// in the UI but can be omitted.
        /// </summary>
        abstract member documentation: U2<string, MarkdownString> option with get, set

    /// <summary>
    /// Represents the signature of something callable. A signature
    /// can have a label, like a function-name, a doc-comment, and
    /// a set of parameters.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SignatureInformation =
        /// <summary>
        /// The label of this signature. Will be shown in
        /// the UI.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// The human-readable doc-comment of this signature. Will be shown
        /// in the UI but can be omitted.
        /// </summary>
        abstract member documentation: U2<string, MarkdownString> option with get, set
        /// <summary>
        /// The parameters of this signature.
        /// </summary>
        abstract member parameters: ResizeArray<ParameterInformation> with get, set
        /// <summary>
        /// The index of the active parameter.
        ///
        /// If provided, this is used in place of {@linkcode SignatureHelp.activeParameter}.
        /// </summary>
        abstract member activeParameter: float option with get, set

    /// <summary>
    /// Signature help represents the signature of something
    /// callable. There can be multiple signatures but only one
    /// active and only one active parameter.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SignatureHelp =
        /// <summary>
        /// One or more signatures.
        /// </summary>
        abstract member signatures: ResizeArray<SignatureInformation> with get, set
        /// <summary>
        /// The active signature.
        /// </summary>
        abstract member activeSignature: float with get, set
        /// <summary>
        /// The active parameter of the active signature.
        /// </summary>
        abstract member activeParameter: float with get, set

    [<RequireQualifiedAccess>]
    type SignatureHelpTriggerKind =
        | Invoke = 1
        | TriggerCharacter = 2
        | ContentChange = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type SignatureHelpContext =
        /// <summary>
        /// Action that caused signature help to be triggered.
        /// </summary>
        abstract member triggerKind: SignatureHelpTriggerKind with get
        /// <summary>
        /// Character that caused signature help to be triggered.
        ///
        /// This is <c>undefined</c> when signature help is not triggered by typing, such as when manually invoking
        /// signature help or when moving the cursor.
        /// </summary>
        abstract member triggerCharacter: string option with get
        /// <summary>
        /// <c>true</c> if signature help was already showing when it was triggered.
        ///
        /// Retriggers occur when the signature help is already active and can be caused by actions such as
        /// typing a trigger character, a cursor move, or document content changes.
        /// </summary>
        abstract member isRetrigger: bool with get
        /// <summary>
        /// The currently active {@linkcode SignatureHelp}.
        ///
        /// The <c>activeSignatureHelp</c> has its {@linkcode SignatureHelp.activeSignatureactiveSignature} field updated based on
        /// the user arrowing through available signatures.
        /// </summary>
        abstract member activeSignatureHelp: SignatureHelp option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type SignatureHelpProvider =
        /// <summary>
        /// Provide help for the signature at the given position and document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <param name="context">
        /// Information about how signature help was triggered.
        /// </param>
        /// <returns>
        /// Signature help or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideSignatureHelp: document: TextDocument * position: Position * token: CancellationToken * context: SignatureHelpContext -> ProviderResult<SignatureHelp>

    [<AllowNullLiteral>]
    [<Interface>]
    type SignatureHelpProviderMetadata =
        /// <summary>
        /// List of characters that trigger signature help.
        /// </summary>
        abstract member triggerCharacters: ReadonlyArray<string> with get
        /// <summary>
        /// List of characters that re-trigger signature help.
        ///
        /// These trigger characters are only active when signature help is already showing. All trigger characters
        /// are also counted as re-trigger characters.
        /// </summary>
        abstract member retriggerCharacters: ReadonlyArray<string> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type CompletionItemLabel =
        /// <summary>
        /// The label of this completion item.
        ///
        /// By default this is also the text that is inserted when this completion is selected.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// An optional string which is rendered less prominently directly after <see href="CompletionItemLabel.labellabel">CompletionItemLabel.labellabel</see>,
        /// without any spacing. Should be used for function signatures or type annotations.
        /// </summary>
        abstract member detail: string option with get, set
        /// <summary>
        /// An optional string which is rendered less prominently after <see href="CompletionItemLabel.detail">CompletionItemLabel.detail</see>. Should be used
        /// for fully qualified names or file path.
        /// </summary>
        abstract member description: string option with get, set

    [<RequireQualifiedAccess>]
    type CompletionItemKind =
        | Text = 0
        | Method = 1
        | Function = 2
        | Constructor = 3
        | Field = 4
        | Variable = 5
        | Class = 6
        | Interface = 7
        | Module = 8
        | Property = 9
        | Unit = 10
        | Value = 11
        | Enum = 12
        | Keyword = 13
        | Snippet = 14
        | Color = 15
        | Reference = 17
        | File = 16
        | Folder = 18
        | EnumMember = 19
        | Constant = 20
        | Struct = 21
        | Event = 22
        | Operator = 23
        | TypeParameter = 24
        | User = 25
        | Issue = 26

    [<RequireQualifiedAccess>]
    type CompletionItemTag =
        | Deprecated = 1

    /// <summary>
    /// A completion item represents a text snippet that is proposed to complete text that is being typed.
    ///
    /// It is sufficient to create a completion item from just a <see href="CompletionItem.labellabel">CompletionItem.labellabel</see>. In that
    /// case the completion item will replace the <see href="TextDocument.getWordRangeAtPositionword">TextDocument.getWordRangeAtPositionword</see>
    /// until the cursor with the given label or <see href="CompletionItem.insertTextinsertText">CompletionItem.insertTextinsertText</see>. Otherwise the
    /// given <see href="CompletionItem.textEditedit">CompletionItem.textEditedit</see> is used.
    ///
    /// When selecting a completion item in the editor its defined or synthesized text edit will be applied
    /// to *all* cursors/selections whereas <see href="CompletionItem.additionalTextEditsadditionalTextEdits">CompletionItem.additionalTextEditsadditionalTextEdits</see> will be
    /// applied as provided.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CompletionItem =
        /// <summary>
        /// The label of this completion item. By default
        /// this is also the text that is inserted when selecting
        /// this completion.
        /// </summary>
        abstract member label: U2<string, CompletionItemLabel> with get, set
        /// <summary>
        /// The kind of this completion item. Based on the kind
        /// an icon is chosen by the editor.
        /// </summary>
        abstract member kind: CompletionItemKind option with get, set
        /// <summary>
        /// Tags for this completion item.
        /// </summary>
        abstract member tags: ReadonlyArray<CompletionItemTag> option with get, set
        /// <summary>
        /// A human-readable string with additional information
        /// about this item, like type or symbol information.
        /// </summary>
        abstract member detail: string option with get, set
        /// <summary>
        /// A human-readable string that represents a doc-comment.
        /// </summary>
        abstract member documentation: U2<string, MarkdownString> option with get, set
        /// <summary>
        /// A string that should be used when comparing this item
        /// with other items. When <c>falsy</c> the <see href="CompletionItem.labellabel">CompletionItem.labellabel</see>
        /// is used.
        ///
        /// Note that <c>sortText</c> is only used for the initial ordering of completion
        /// items. When having a leading word (prefix) ordering is based on how
        /// well completions match that prefix and the initial ordering is only used
        /// when completions match equally well. The prefix is defined by the
        /// {@linkcode CompletionItem.rangerange}-property and can therefore be different
        /// for each completion.
        /// </summary>
        abstract member sortText: string option with get, set
        /// <summary>
        /// A string that should be used when filtering a set of
        /// completion items. When <c>falsy</c> the <see href="CompletionItem.labellabel">CompletionItem.labellabel</see>
        /// is used.
        ///
        /// Note that the filter text is matched against the leading word (prefix) which is defined
        /// by the {@linkcode CompletionItem.rangerange}-property.
        /// </summary>
        abstract member filterText: string option with get, set
        /// <summary>
        /// Select this item when showing. *Note* that only one completion item can be selected and
        /// that the editor decides which item that is. The rule is that the *first* item of those
        /// that match best is selected.
        /// </summary>
        abstract member preselect: bool option with get, set
        /// <summary>
        /// A string or snippet that should be inserted in a document when selecting
        /// this completion. When <c>falsy</c> the <see href="CompletionItem.labellabel">CompletionItem.labellabel</see>
        /// is used.
        /// </summary>
        abstract member insertText: U2<string, SnippetString> option with get, set
        /// <summary>
        /// A range or a insert and replace range selecting the text that should be replaced by this completion item.
        ///
        /// When omitted, the range of the <see href="TextDocument.getWordRangeAtPositioncurrent">word</see>" is used as replace-range
        /// and as insert-range the start of the <see href="TextDocument.getWordRangeAtPositioncurrent">word</see>" to the
        /// current position is used.
        ///
        /// *Note 1:* A range must be a <see href="Range.isSingleLinesingle">line</see>" and it must
        /// <see href="Range.containscontain">Range.containscontain</see> the position at which completion has been <see href="CompletionItemProvider.provideCompletionItemsrequested">CompletionItemProvider.provideCompletionItemsrequested</see>.
        /// *Note 2:* A insert range must be a prefix of a replace range, that means it must be contained and starting at the same position.
        /// </summary>
        abstract member range: U2<Range, CompletionItem.range.U2.Case2> option with get, set
        /// <summary>
        /// An optional set of characters that when pressed while this completion is active will accept it first and
        /// then type that character. *Note* that all commit characters should have <c>length=1</c> and that superfluous
        /// characters will be ignored.
        /// </summary>
        abstract member commitCharacters: ResizeArray<string> option with get, set
        /// <summary>
        /// Keep whitespace of the <see href="CompletionItem.insertTextinsertText">CompletionItem.insertTextinsertText</see> as is. By default, the editor adjusts leading
        /// whitespace of new lines so that they match the indentation of the line for which the item is accepted - setting
        /// this to <c>true</c> will prevent that.
        /// </summary>
        abstract member keepWhitespace: bool option with get, set
        [<Obsolete("""Use `CompletionItem.insertText` and `CompletionItem.range` instead.

An {@link TextEdit edit} which is applied to a document when selecting
this completion. When an edit is provided the value of
{@link CompletionItem.insertText insertText} is ignored.

The {@link Range } of the edit must be single-line and on the same
line completions were {@link CompletionItemProvider.provideCompletionItems requested} at.""")>]
        abstract member textEdit: TextEdit option with get, set
        /// <summary>
        /// An optional array of additional <see href="TextEdittext">edits</see>" that are applied when
        /// selecting this completion. Edits must not overlap with the main <see href="CompletionItem.textEditedit">CompletionItem.textEditedit</see>
        /// nor with themselves.
        /// </summary>
        abstract member additionalTextEdits: ResizeArray<TextEdit> option with get, set
        /// <summary>
        /// An optional <see href="Command">Command</see> that is executed *after* inserting this completion. *Note* that
        /// additional modifications to the current document should be described with the
        /// <see href="CompletionItem.additionalTextEditsadditionalTextEdits">CompletionItem.additionalTextEditsadditionalTextEdits</see>-property.
        /// </summary>
        abstract member command: Command option with get, set

    /// <summary>
    /// Represents a collection of <see href="CompletionItemcompletion">items</see>" to be presented
    /// in the editor.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CompletionList<'T when 'T :> CompletionItem> =
        /// <summary>
        /// This list is not complete. Further typing should result in recomputing
        /// this list.
        /// </summary>
        abstract member isIncomplete: bool option with get, set
        /// <summary>
        /// The completion items.
        /// </summary>
        abstract member items: ResizeArray<'T> with get, set

    type CompletionList =
        CompletionList<CompletionItem>

    [<RequireQualifiedAccess>]
    type CompletionTriggerKind =
        | Invoke = 0
        | TriggerCharacter = 1
        | TriggerForIncompleteCompletions = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type CompletionContext =
        /// <summary>
        /// How the completion was triggered.
        /// </summary>
        abstract member triggerKind: CompletionTriggerKind with get
        /// <summary>
        /// Character that triggered the completion item provider.
        ///
        /// <c>undefined</c> if the provider was not triggered by a character.
        ///
        /// The trigger character is already in the document when the completion provider is triggered.
        /// </summary>
        abstract member triggerCharacter: string option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type CompletionItemProvider<'T when 'T :> CompletionItem> =
        /// <summary>
        /// Provide completion items for the given position and document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <param name="context">
        /// How the completion was triggered.
        /// </param>
        /// <returns>
        /// An array of completions, a <see href="CompletionList">completion list</see>", or a thenable that resolves to either.
        /// The lack of a result can be signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideCompletionItems: document: TextDocument * position: Position * token: CancellationToken * context: CompletionContext -> ProviderResult<U2<ResizeArray<'T>, CompletionList<'T>>>
        /// <summary>
        /// Given a completion item fill in more data, like <see href="CompletionItem.documentationdoc-comment">CompletionItem.documentationdoc-comment</see>
        /// or <see href="CompletionItem.detaildetails">CompletionItem.detaildetails</see>.
        ///
        /// The editor will only resolve a completion item once.
        ///
        /// *Note* that this function is called when completion items are already showing in the UI or when an item has been
        /// selected for insertion. Because of that, no property that changes the presentation (label, sorting, filtering etc)
        /// or the (primary) insert behaviour (<see href="CompletionItem.insertTextinsertText">CompletionItem.insertTextinsertText</see>) can be changed.
        ///
        /// This function may fill in <see href="CompletionItem.additionalTextEditsadditionalTextEdits">CompletionItem.additionalTextEditsadditionalTextEdits</see>. However, that means an item might be
        /// inserted *before* resolving is done and in that case the editor will do a best effort to still apply those additional
        /// text edits.
        /// </summary>
        /// <param name="item">
        /// A completion item currently active in the UI.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved completion item or a thenable that resolves to of such. It is OK to return the given
        /// <c>item</c>. When no result is returned, the given <c>item</c> will be used.
        /// </returns>
        abstract member resolveCompletionItem: item: 'T * token: CancellationToken -> ProviderResult<'T>

    [<AllowNullLiteral>]
    [<Interface>]
    type InlineCompletionItemProvider =
        /// <summary>
        /// Provides inline completion items for the given position and document.
        /// If inline completions are enabled, this method will be called whenever the user stopped typing.
        /// It will also be called when the user explicitly triggers inline completions or explicitly asks for the next or previous inline completion.
        /// In that case, all available inline completions should be returned.
        /// <c>context.triggerKind</c> can be used to distinguish between these scenarios.
        /// </summary>
        /// <param name="document">
        /// The document inline completions are requested for.
        /// </param>
        /// <param name="position">
        /// The position inline completions are requested for.
        /// </param>
        /// <param name="context">
        /// A context object with additional information.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of completion items or a thenable that resolves to an array of completion items.
        /// </returns>
        abstract member provideInlineCompletionItems: document: TextDocument * position: Position * context: InlineCompletionContext * token: CancellationToken -> ProviderResult<U2<ResizeArray<InlineCompletionItem>, InlineCompletionList>>

    /// <summary>
    /// Represents a collection of <see href="InlineCompletionIteminline">completion items</see>" to be presented
    /// in the editor.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type InlineCompletionList =
        /// <summary>
        /// The inline completion items.
        /// </summary>
        abstract member items: ResizeArray<InlineCompletionItem> with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type InlineCompletionContext =
        /// <summary>
        /// Describes how the inline completion was triggered.
        /// </summary>
        abstract member triggerKind: InlineCompletionTriggerKind with get
        /// <summary>
        /// Provides information about the currently selected item in the autocomplete widget if it is visible.
        ///
        /// If set, provided inline completions must extend the text of the selected item
        /// and use the same range, otherwise they are not shown as preview.
        /// As an example, if the document text is <c>console.</c> and the selected item is <c>.log</c> replacing the <c>.</c> in the document,
        /// the inline completion must also replace <c>.</c> and start with <c>.log</c>, for example <c>.log()</c>.
        ///
        /// Inline completion providers are requested again whenever the selected item changes.
        /// </summary>
        abstract member selectedCompletionInfo: SelectedCompletionInfo option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type SelectedCompletionInfo =
        /// <summary>
        /// The range that will be replaced if this completion item is accepted.
        /// </summary>
        abstract member range: Range with get
        /// <summary>
        /// The text the range will be replaced with if this completion is accepted.
        /// </summary>
        abstract member text: string with get

    [<RequireQualifiedAccess>]
    type InlineCompletionTriggerKind =
        | Invoke = 0
        | Automatic = 1

    /// <summary>
    /// An inline completion item represents a text snippet that is proposed inline to complete text that is being typed.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type InlineCompletionItem =
        /// <summary>
        /// The text to replace the range with. Must be set.
        /// Is used both for the preview and the accept operation.
        /// </summary>
        abstract member insertText: U2<string, SnippetString> with get, set
        /// <summary>
        /// A text that is used to decide if this inline completion should be shown. When <c>falsy</c>
        /// the <see href="InlineCompletionItem.insertText">InlineCompletionItem.insertText</see> is used.
        ///
        /// An inline completion is shown if the text to replace is a prefix of the filter text.
        /// </summary>
        abstract member filterText: string option with get, set
        /// <summary>
        /// The range to replace.
        /// Must begin and end on the same line.
        ///
        /// Prefer replacements over insertions to provide a better experience when the user deletes typed text.
        /// </summary>
        abstract member range: Range option with get, set
        /// <summary>
        /// An optional <see href="Command">Command</see> that is executed *after* inserting this completion.
        /// </summary>
        abstract member command: Command option with get, set

    /// <summary>
    /// A document link is a range in a text document that links to an internal or external resource, like another
    /// text document or a web site.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentLink =
        /// <summary>
        /// The range this link applies to.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The uri this link points to.
        /// </summary>
        abstract member target: Uri option with get, set
        /// <summary>
        /// The tooltip text when you hover over this link.
        ///
        /// If a tooltip is provided, is will be displayed in a string that includes instructions on how to
        /// trigger the link, such as <c>{0} (ctrl + click)</c>. The specific instructions vary depending on OS,
        /// user settings, and localization.
        /// </summary>
        abstract member tooltip: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentLinkProvider<'T when 'T :> DocumentLink> =
        /// <summary>
        /// Provide links for the given document. Note that the editor ships with a default provider that detects
        /// <c>http(s)</c> and <c>file</c> links.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of <see href="DocumentLink">document links</see>" or a thenable that resolves to such. The lack of a result
        /// can be signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideDocumentLinks: document: TextDocument * token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// Given a link fill in its <see href="DocumentLink.targettarget">DocumentLink.targettarget</see>. This method is called when an incomplete
        /// link is selected in the UI. Providers can implement this method and return incomplete links
        /// (without target) from the {@linkcode DocumentLinkProvider.provideDocumentLinksprovideDocumentLinks} method which
        /// often helps to improve performance.
        /// </summary>
        /// <param name="link">
        /// The link that is to be resolved.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        abstract member resolveDocumentLink: link: 'T * token: CancellationToken -> ProviderResult<'T>

    /// <summary>
    /// Represents a color in RGBA space.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Color =
        /// <summary>
        /// The red component of this color in the range <c>[0-1]</c>.
        /// </summary>
        abstract member red: float with get
        /// <summary>
        /// The green component of this color in the range <c>[0-1]</c>.
        /// </summary>
        abstract member green: float with get
        /// <summary>
        /// The blue component of this color in the range <c>[0-1]</c>.
        /// </summary>
        abstract member blue: float with get
        /// <summary>
        /// The alpha component of this color in the range <c>[0-1]</c>.
        /// </summary>
        abstract member alpha: float with get

    /// <summary>
    /// Represents a color range from a document.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ColorInformation =
        /// <summary>
        /// The range in the document where this color appears.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The actual color value for this color range.
        /// </summary>
        abstract member color: Color with get, set

    /// <summary>
    /// A color presentation object describes how a {@linkcode Color} should be represented as text and what
    /// edits are required to refer to it from source code.
    ///
    /// For some languages one color can have multiple presentations, e.g. css can represent the color red with
    /// the constant <c>Red</c>, the hex-value <c>#ff0000</c>, or in rgba and hsla forms. In csharp other representations
    /// apply, e.g. <c>System.Drawing.Color.Red</c>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ColorPresentation =
        /// <summary>
        /// The label of this color presentation. It will be shown on the color
        /// picker header. By default this is also the text that is inserted when selecting
        /// this color presentation.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// An <see href="TextEditedit">TextEditedit</see> which is applied to a document when selecting
        /// this presentation for the color.  When <c>falsy</c> the <see href="ColorPresentation.labellabel">ColorPresentation.labellabel</see>
        /// is used.
        /// </summary>
        abstract member textEdit: TextEdit option with get, set
        /// <summary>
        /// An optional array of additional <see href="TextEdittext">edits</see>" that are applied when
        /// selecting this color presentation. Edits must not overlap with the main <see href="ColorPresentation.textEditedit">ColorPresentation.textEditedit</see> nor with themselves.
        /// </summary>
        abstract member additionalTextEdits: ResizeArray<TextEdit> option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentColorProvider =
        /// <summary>
        /// Provide colors for the given document.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of <see href="ColorInformation">color information</see>" or a thenable that resolves to such. The lack of a result
        /// can be signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideDocumentColors: document: TextDocument * token: CancellationToken -> ProviderResult<ResizeArray<ColorInformation>>
        /// <summary>
        /// Provide <see href="ColorPresentationrepresentations">ColorPresentationrepresentations</see> for a color.
        /// </summary>
        /// <param name="color">
        /// The color to show and insert.
        /// </param>
        /// <param name="context">
        /// A context object with additional information
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of color presentations or a thenable that resolves to such. The lack of a result
        /// can be signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member provideColorPresentations: color: Color * context: DocumentColorProvider.provideColorPresentations.context * token: CancellationToken -> ProviderResult<ResizeArray<ColorPresentation>>

    [<RequireQualifiedAccess>]
    type InlayHintKind =
        | Type = 1
        | Parameter = 2

    /// <summary>
    /// An inlay hint label part allows for interactive and composite labels of inlay hints.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type InlayHintLabelPart =
        /// <summary>
        /// The value of this label part.
        /// </summary>
        abstract member value: string with get, set
        /// <summary>
        /// The tooltip text when you hover over this label part.
        ///
        /// *Note* that this property can be set late during
        /// <see href="InlayHintsProvider.resolveInlayHintresolving">InlayHintsProvider.resolveInlayHintresolving</see> of inlay hints.
        /// </summary>
        abstract member tooltip: U2<string, MarkdownString> option option with get, set
        /// <summary>
        /// An optional <see href="Locationsource">code location</see>" that represents this label
        /// part.
        ///
        /// The editor will use this location for the hover and for code navigation features: This
        /// part will become a clickable link that resolves to the definition of the symbol at the
        /// given location (not necessarily the location itself), it shows the hover that shows at
        /// the given location, and it shows a context menu with further code navigation commands.
        ///
        /// *Note* that this property can be set late during
        /// <see href="InlayHintsProvider.resolveInlayHintresolving">InlayHintsProvider.resolveInlayHintresolving</see> of inlay hints.
        /// </summary>
        abstract member location: Location option with get, set
        /// <summary>
        /// An optional command for this label part.
        ///
        /// The editor renders parts with commands as clickable links. The command is added to the context menu
        /// when a label part defines <see href="InlayHintLabelPart.locationlocation">InlayHintLabelPart.locationlocation</see> and <see href="InlayHintLabelPart.commandcommand">InlayHintLabelPart.commandcommand</see> .
        ///
        /// *Note* that this property can be set late during
        /// <see href="InlayHintsProvider.resolveInlayHintresolving">InlayHintsProvider.resolveInlayHintresolving</see> of inlay hints.
        /// </summary>
        abstract member command: Command option with get, set

    /// <summary>
    /// Inlay hint information.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type InlayHint =
        /// <summary>
        /// The position of this hint.
        /// </summary>
        abstract member position: Position with get, set
        /// <summary>
        /// The label of this hint. A human readable string or an array of <see href="InlayHintLabelPartlabel">parts</see>".
        ///
        /// *Note* that neither the string nor the label part can be empty.
        /// </summary>
        abstract member label: U2<string, ResizeArray<InlayHintLabelPart>> with get, set
        /// <summary>
        /// The tooltip text when you hover over this item.
        ///
        /// *Note* that this property can be set late during
        /// <see href="InlayHintsProvider.resolveInlayHintresolving">InlayHintsProvider.resolveInlayHintresolving</see> of inlay hints.
        /// </summary>
        abstract member tooltip: U2<string, MarkdownString> option option with get, set
        /// <summary>
        /// The kind of this hint. The inlay hint kind defines the appearance of this inlay hint.
        /// </summary>
        abstract member kind: InlayHintKind option with get, set
        /// <summary>
        /// Optional <see href="TextEdittext">edits</see>" that are performed when accepting this inlay hint. The default
        /// gesture for accepting an inlay hint is the double click.
        ///
        /// *Note* that edits are expected to change the document so that the inlay hint (or its nearest variant) is
        /// now part of the document and the inlay hint itself is now obsolete.
        ///
        /// *Note* that this property can be set late during
        /// <see href="InlayHintsProvider.resolveInlayHintresolving">InlayHintsProvider.resolveInlayHintresolving</see> of inlay hints.
        /// </summary>
        abstract member textEdits: ResizeArray<TextEdit> option with get, set
        /// <summary>
        /// Render padding before the hint. Padding will use the editor's background color,
        /// not the background color of the hint itself. That means padding can be used to visually
        /// align/separate an inlay hint.
        /// </summary>
        abstract member paddingLeft: bool option with get, set
        /// <summary>
        /// Render padding after the hint. Padding will use the editor's background color,
        /// not the background color of the hint itself. That means padding can be used to visually
        /// align/separate an inlay hint.
        /// </summary>
        abstract member paddingRight: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type InlayHintsProvider<'T when 'T :> InlayHint> =
        /// <summary>
        /// An optional event to signal that inlay hints from this provider have changed.
        /// </summary>
        abstract member onDidChangeInlayHints: Event<unit> option with get, set
        /// <summary>
        /// Provide inlay hints for the given range and document.
        ///
        /// *Note* that inlay hints that are not <see href="Range.containscontained">Range.containscontained</see> by the given range are ignored.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="range">
        /// The range for which inlay hints should be computed.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of inlay hints or a thenable that resolves to such.
        /// </returns>
        abstract member provideInlayHints: document: TextDocument * range: Range * token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// Given an inlay hint fill in <see href="InlayHint.tooltiptooltip">InlayHint.tooltiptooltip</see>, <see href="InlayHint.textEditstext">edits</see>",
        /// or complete label <see href="InlayHintLabelPartparts">InlayHintLabelPartparts</see>.
        ///
        /// *Note* that the editor will resolve an inlay hint at most once.
        /// </summary>
        /// <param name="hint">
        /// An inlay hint.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved inlay hint or a thenable that resolves to such. It is OK to return the given <c>item</c>. When no result is returned, the given <c>item</c> will be used.
        /// </returns>
        abstract member resolveInlayHint: hint: 'T * token: CancellationToken -> ProviderResult<'T>

    /// <summary>
    /// A line based folding range. To be valid, start and end line must be bigger than zero and smaller than the number of lines in the document.
    /// Invalid ranges will be ignored.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type FoldingRange =
        /// <summary>
        /// The zero-based start line of the range to fold. The folded area starts after the line's last character.
        /// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
        /// </summary>
        abstract member start: float with get, set
        /// <summary>
        /// The zero-based end line of the range to fold. The folded area ends with the line's last character.
        /// To be valid, the end must be zero or larger and smaller than the number of lines in the document.
        /// </summary>
        abstract member ``end``: float with get, set
        /// <summary>
        /// Describes the <see href="FoldingRangeKindKind">FoldingRangeKindKind</see> of the folding range such as <see href="FoldingRangeKind.CommentComment">FoldingRangeKind.CommentComment</see> or
        /// <see href="FoldingRangeKind.RegionRegion">FoldingRangeKind.RegionRegion</see>. The kind is used to categorize folding ranges and used by commands
        /// like 'Fold all comments'. See
        /// <see href="FoldingRangeKind">FoldingRangeKind</see> for an enumeration of all kinds.
        /// If not set, the range is originated from a syntax element.
        /// </summary>
        abstract member kind: FoldingRangeKind option with get, set

    [<RequireQualifiedAccess>]
    type FoldingRangeKind =
        | Comment = 1
        | Imports = 2
        | Region = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type FoldingContext =
        interface end

    [<AllowNullLiteral>]
    [<Interface>]
    type FoldingRangeProvider =
        /// <summary>
        /// An optional event to signal that the folding ranges from this provider have changed.
        /// </summary>
        abstract member onDidChangeFoldingRanges: Event<unit> option with get, set
        /// <summary>
        /// Returns a list of folding ranges or null and undefined if the provider
        /// does not want to participate or was cancelled.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="context">
        /// Additional context information (for future use)
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        abstract member provideFoldingRanges: document: TextDocument * context: FoldingContext * token: CancellationToken -> ProviderResult<ResizeArray<FoldingRange>>

    /// <summary>
    /// A selection range represents a part of a selection hierarchy. A selection range
    /// may have a parent selection range that contains it.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SelectionRange =
        /// <summary>
        /// The <see href="Range">Range</see> of this selection range.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The parent selection range containing this range.
        /// </summary>
        abstract member parent: SelectionRange option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type SelectionRangeProvider =
        /// <summary>
        /// Provide selection ranges for the given positions.
        ///
        /// Selection ranges should be computed individually and independent for each position. The editor will merge
        /// and deduplicate ranges but providers must return hierarchies of selection ranges so that a range
        /// is <see href="Range.containscontained">Range.containscontained</see> by its parent.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="positions">
        /// The positions at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// Selection ranges or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideSelectionRanges: document: TextDocument * positions: ReadonlyArray<Position> * token: CancellationToken -> ProviderResult<ResizeArray<SelectionRange>>

    /// <summary>
    /// Represents programming constructs like functions or constructors in the context
    /// of call hierarchy.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CallHierarchyItem =
        /// <summary>
        /// The name of this item.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The kind of this item.
        /// </summary>
        abstract member kind: SymbolKind with get, set
        /// <summary>
        /// Tags for this item.
        /// </summary>
        abstract member tags: ReadonlyArray<SymbolTag> option with get, set
        /// <summary>
        /// More detail for this item, e.g. the signature of a function.
        /// </summary>
        abstract member detail: string option with get, set
        /// <summary>
        /// The resource identifier of this item.
        /// </summary>
        abstract member uri: Uri with get, set
        /// <summary>
        /// The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
        /// Must be contained by the {@linkcode CallHierarchyItem.rangerange}.
        /// </summary>
        abstract member selectionRange: Range with get, set

    /// <summary>
    /// Represents an incoming call, e.g. a caller of a method or constructor.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CallHierarchyIncomingCall =
        /// <summary>
        /// The item that makes the call.
        /// </summary>
        abstract member from: CallHierarchyItem with get, set
        /// <summary>
        /// The range at which at which the calls appears. This is relative to the caller
        /// denoted by {@linkcode CallHierarchyIncomingCall.fromthis.from}.
        /// </summary>
        abstract member fromRanges: ResizeArray<Range> with get, set

    /// <summary>
    /// Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CallHierarchyOutgoingCall =
        /// <summary>
        /// The item that is called.
        /// </summary>
        abstract member ``to``: CallHierarchyItem with get, set
        /// <summary>
        /// The range at which this item is called. This is the range relative to the caller, e.g the item
        /// passed to {@linkcode CallHierarchyProvider.provideCallHierarchyOutgoingCallsprovideCallHierarchyOutgoingCalls}
        /// and not {@linkcode CallHierarchyOutgoingCall.tothis.to}.
        /// </summary>
        abstract member fromRanges: ResizeArray<Range> with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type CallHierarchyProvider =
        /// <summary>
        /// Bootstraps call hierarchy by returning the item that is denoted by the given document
        /// and position. This item will be used as entry into the call graph. Providers should
        /// return <c>undefined</c> or <c>null</c> when there is no item at the given location.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// One or multiple call hierarchy items or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member prepareCallHierarchy: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<U2<CallHierarchyItem, ResizeArray<CallHierarchyItem>>>
        /// <summary>
        /// Provide all incoming calls for an item, e.g all callers for a method. In graph terms this describes directed
        /// and annotated edges inside the call graph, e.g the given item is the starting node and the result is the nodes
        /// that can be reached.
        /// </summary>
        /// <param name="item">
        /// The hierarchy item for which incoming calls should be computed.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A set of incoming calls or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideCallHierarchyIncomingCalls: item: CallHierarchyItem * token: CancellationToken -> ProviderResult<ResizeArray<CallHierarchyIncomingCall>>
        /// <summary>
        /// Provide all outgoing calls for an item, e.g call calls to functions, methods, or constructors from the given item. In
        /// graph terms this describes directed and annotated edges inside the call graph, e.g the given item is the starting
        /// node and the result is the nodes that can be reached.
        /// </summary>
        /// <param name="item">
        /// The hierarchy item for which outgoing calls should be computed.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A set of outgoing calls or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideCallHierarchyOutgoingCalls: item: CallHierarchyItem * token: CancellationToken -> ProviderResult<ResizeArray<CallHierarchyOutgoingCall>>

    /// <summary>
    /// Represents an item of a type hierarchy, like a class or an interface.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TypeHierarchyItem =
        /// <summary>
        /// The name of this item.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The kind of this item.
        /// </summary>
        abstract member kind: SymbolKind with get, set
        /// <summary>
        /// Tags for this item.
        /// </summary>
        abstract member tags: ReadonlyArray<SymbolTag> option with get, set
        /// <summary>
        /// More detail for this item, e.g. the signature of a function.
        /// </summary>
        abstract member detail: string option with get, set
        /// <summary>
        /// The resource identifier of this item.
        /// </summary>
        abstract member uri: Uri with get, set
        /// <summary>
        /// The range enclosing this symbol not including leading/trailing whitespace
        /// but everything else, e.g. comments and code.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The range that should be selected and revealed when this symbol is being
        /// picked, e.g. the name of a class. Must be contained by the <see href="TypeHierarchyItem.rangerange">TypeHierarchyItem.rangerange</see>-property.
        /// </summary>
        abstract member selectionRange: Range with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TypeHierarchyProvider =
        /// <summary>
        /// Bootstraps type hierarchy by returning the item that is denoted by the given document
        /// and position. This item will be used as entry into the type graph. Providers should
        /// return <c>undefined</c> or <c>null</c> when there is no item at the given location.
        /// </summary>
        /// <param name="document">
        /// The document in which the command was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the command was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// One or multiple type hierarchy items or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c>, <c>null</c>, or an empty array.
        /// </returns>
        abstract member prepareTypeHierarchy: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<U2<TypeHierarchyItem, ResizeArray<TypeHierarchyItem>>>
        /// <summary>
        /// Provide all supertypes for an item, e.g all types from which a type is derived/inherited. In graph terms this describes directed
        /// and annotated edges inside the type graph, e.g the given item is the starting node and the result is the nodes
        /// that can be reached.
        /// </summary>
        /// <param name="item">
        /// The hierarchy item for which super types should be computed.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A set of direct supertypes or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideTypeHierarchySupertypes: item: TypeHierarchyItem * token: CancellationToken -> ProviderResult<ResizeArray<TypeHierarchyItem>>
        /// <summary>
        /// Provide all subtypes for an item, e.g all types which are derived/inherited from the given item. In
        /// graph terms this describes directed and annotated edges inside the type graph, e.g the given item is the starting
        /// node and the result is the nodes that can be reached.
        /// </summary>
        /// <param name="item">
        /// The hierarchy item for which subtypes should be computed.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A set of direct subtypes or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideTypeHierarchySubtypes: item: TypeHierarchyItem * token: CancellationToken -> ProviderResult<ResizeArray<TypeHierarchyItem>>

    /// <summary>
    /// Represents a list of ranges that can be edited together along with a word pattern to describe valid range contents.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type LinkedEditingRanges =
        /// <summary>
        /// A list of ranges that can be edited together. The ranges must have
        /// identical length and text content. The ranges cannot overlap.
        /// </summary>
        abstract member ranges: ResizeArray<Range> with get
        /// <summary>
        /// An optional word pattern that describes valid contents for the given ranges.
        /// If no pattern is provided, the language configuration's word pattern will be used.
        /// </summary>
        abstract member wordPattern: RegExp option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type LinkedEditingRangeProvider =
        /// <summary>
        /// For a given position in a document, returns the range of the symbol at the position and all ranges
        /// that have the same content. A change to one of the ranges can be applied to all other ranges if the new content
        /// is valid. An optional word pattern can be returned with the result to describe valid contents.
        /// If no result-specific word pattern is provided, the word pattern from the language configuration is used.
        /// </summary>
        /// <param name="document">
        /// The document in which the provider was invoked.
        /// </param>
        /// <param name="position">
        /// The position at which the provider was invoked.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A list of ranges that can be edited together
        /// </returns>
        abstract member provideLinkedEditingRanges: document: TextDocument * position: Position * token: CancellationToken -> ProviderResult<LinkedEditingRanges>

    /// <summary>
    /// Identifies a {@linkcode DocumentDropEdit} or {@linkcode DocumentPasteEdit}
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentDropOrPasteEditKind =
        static member inline Empty
            with get () : DocumentDropOrPasteEditKind =
                emitJsExpr () $$"""
import { DocumentDropOrPasteEditKind } from "vscode";
DocumentDropOrPasteEditKind.Empty"""
        /// <summary>
        /// The root kind for basic text edits.
        ///
        /// This kind should be used for edits that insert basic text into the document. A good example of this is
        /// an edit that pastes the clipboard text while also updating imports in the file based on the pasted text.
        /// For this we could use a kind such as <c>text.updateImports.someLanguageId</c>.
        ///
        /// Even though most drop/paste edits ultimately insert text, you should not use {@linkcode Text} as the base kind
        /// for every edit as this is redundant. Instead a more specific kind that describes the type of content being
        /// inserted should be used instead. For example, if the edit adds a Markdown link, use <c>markdown.link</c> since even
        /// though the content being inserted is text, it's more important to know that the edit inserts Markdown syntax.
        /// </summary>
        static member inline Text
            with get () : DocumentDropOrPasteEditKind =
                emitJsExpr () $$"""
import { DocumentDropOrPasteEditKind } from "vscode";
DocumentDropOrPasteEditKind.Text"""
        /// <summary>
        /// Root kind for edits that update imports in a document in addition to inserting text.
        /// </summary>
        static member inline TextUpdateImports
            with get () : DocumentDropOrPasteEditKind =
                emitJsExpr () $$"""
import { DocumentDropOrPasteEditKind } from "vscode";
DocumentDropOrPasteEditKind.TextUpdateImports"""
        /// <summary>
        /// The raw string value of the kind.
        /// </summary>
        abstract member value: string with get
        /// <summary>
        /// Create a new kind by appending additional scopes to the current kind.
        ///
        /// Does not modify the current kind.
        /// </summary>
        abstract member append: [<ParamArray>] parts: string [] -> DocumentDropOrPasteEditKind
        /// <summary>
        /// Checks if this kind intersects <c>other</c>.
        ///
        /// The kind <c>"text.plain"</c> for example intersects <c>text</c>, <c>"text.plain"</c> and <c>"text.plain.list"</c>,
        /// but not <c>"unicorn"</c>, or <c>"textUnicorn.plain"</c>.
        /// </summary>
        /// <param name="other">
        /// Kind to check.
        /// </param>
        abstract member intersects: other: DocumentDropOrPasteEditKind -> bool
        /// <summary>
        /// Checks if <c>other</c> is a sub-kind of this <c>DocumentDropOrPasteEditKind</c>.
        ///
        /// The kind <c>"text.plain"</c> for example contains <c>"text.plain"</c> and <c>"text.plain.list"</c>,
        /// but not <c>"text"</c> or <c>"unicorn.text.plain"</c>.
        /// </summary>
        /// <param name="other">
        /// Kind to check.
        /// </param>
        abstract member contains: other: DocumentDropOrPasteEditKind -> bool

    /// <summary>
    /// An edit operation applied <see href="DocumentDropEditProvideron">drop</see>".
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentDropEdit =
        /// <summary>
        /// Human readable label that describes the edit.
        /// </summary>
        abstract member title: string option with get, set
        /// <summary>
        /// <see href="DocumentDropOrPasteEditKindKind">DocumentDropOrPasteEditKindKind</see> of the edit.
        /// </summary>
        abstract member kind: DocumentDropOrPasteEditKind option with get, set
        /// <summary>
        /// Controls the ordering or multiple edits. If this provider yield to edits, it will be shown lower in the list.
        /// </summary>
        abstract member yieldTo: ReadonlyArray<DocumentDropOrPasteEditKind> option with get, set
        /// <summary>
        /// The text or snippet to insert at the drop location.
        /// </summary>
        abstract member insertText: U2<string, SnippetString> with get, set
        /// <summary>
        /// An optional additional edit to apply on drop.
        /// </summary>
        abstract member additionalEdit: WorkspaceEdit option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentDropEditProvider<'T when 'T :> DocumentDropEdit> =
        /// <summary>
        /// Provide edits which inserts the content being dragged and dropped into the document.
        /// </summary>
        /// <param name="document">
        /// The document in which the drop occurred.
        /// </param>
        /// <param name="position">
        /// The position in the document where the drop occurred.
        /// </param>
        /// <param name="dataTransfer">
        /// A <see href="DataTransfer">DataTransfer</see> object that holds data about what is being dragged and dropped.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A <see href="DocumentDropEdit">DocumentDropEdit</see> or a thenable that resolves to such. The lack of a result can be
        /// signaled by returning <c>undefined</c> or <c>null</c>.
        /// </returns>
        abstract member provideDocumentDropEdits: document: TextDocument * position: Position * dataTransfer: DataTransfer * token: CancellationToken -> ProviderResult<U2<'T, ResizeArray<'T>>>
        /// <summary>
        /// Optional method which fills in the {@linkcode DocumentDropEdit.additionalEdit} before the edit is applied.
        ///
        /// This is called once per edit and should be used if generating the complete edit may take a long time.
        /// Resolve can only be used to change <see href="DocumentDropEdit.additionalEdit">DocumentDropEdit.additionalEdit</see>.
        /// </summary>
        /// <param name="edit">
        /// The {@linkcode DocumentDropEdit } to resolve.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved edit or a thenable that resolves to such. It is OK to return the given
        /// <c>edit</c>. If no result is returned, the given <c>edit</c> is used.
        /// </returns>
        abstract member resolveDocumentDropEdit: edit: 'T * token: CancellationToken -> ProviderResult<'T>

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentDropEditProviderMetadata =
        /// <summary>
        /// List of <see href="DocumentDropOrPasteEditKindkinds">DocumentDropOrPasteEditKindkinds</see> that the provider may return in {@linkcode DocumentDropEditProvider.provideDocumentDropEditsprovideDocumentDropEdits}.
        ///
        /// This is used to filter out providers when a specific <see href="DocumentDropOrPasteEditKindkind">DocumentDropOrPasteEditKindkind</see> of edit is requested.
        /// </summary>
        abstract member providedDropEditKinds: ReadonlyArray<DocumentDropOrPasteEditKind> option with get
        /// <summary>
        /// List of <see href="DataTransfer">DataTransfer</see> mime types that the provider can handle.
        ///
        /// This can either be an exact mime type such as <c>image/png</c>, or a wildcard pattern such as <c>image/*</c>.
        ///
        /// Use <c>text/uri-list</c> for resources dropped from the explorer or other tree views in the workbench.
        ///
        /// Use <c>files</c> to indicate that the provider should be invoked if any <see href="DataTransferFilefiles">DataTransferFilefiles</see> are present in the <see href="DataTransfer">DataTransfer</see>.
        /// Note that <see href="DataTransferFile">DataTransferFile</see> entries are only created when dropping content from outside the editor, such as
        /// from the operating system.
        /// </summary>
        abstract member dropMimeTypes: ReadonlyArray<string> with get

    [<RequireQualifiedAccess>]
    type DocumentPasteTriggerKind =
        | Automatic = 0
        | PasteAs = 1

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentPasteEditContext =
        /// <summary>
        /// Requested kind of paste edits to return.
        ///
        /// When a explicit kind if requested by {@linkcode DocumentPasteTriggerKind.PasteAsPasteAs}, providers are
        /// encourage to be more flexible when generating an edit of the requested kind.
        /// </summary>
        abstract member only: DocumentDropOrPasteEditKind option with get
        /// <summary>
        /// The reason why paste edits were requested.
        /// </summary>
        abstract member triggerKind: DocumentPasteTriggerKind with get

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentPasteEditProvider<'T when 'T :> DocumentPasteEdit> =
        /// <summary>
        /// Optional method invoked after the user copies from a <see href="TextEditortext">editor</see>".
        ///
        /// This allows the provider to attach metadata about the copied text to the <see href="DataTransfer">DataTransfer</see>. This data
        /// transfer is then passed back to providers in {@linkcode provideDocumentPasteEdits}.
        ///
        /// Note that currently any changes to the {@linkcode DataTransfer} are isolated to the current editor window.
        /// This means that any added metadata cannot be seen by other editor windows or by other applications.
        /// </summary>
        /// <param name="document">
        /// Text document where the copy took place.
        /// </param>
        /// <param name="ranges">
        /// Ranges being copied in {@linkcode document }.
        /// </param>
        /// <param name="dataTransfer">
        /// The data transfer associated with the copy. You can store additional values on this for
        /// later use in {@linkcode provideDocumentPasteEdits }. This object is only valid for the duration of this method.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// Optional thenable that resolves when all changes to the <c>dataTransfer</c> are complete.
        /// </returns>
        abstract member prepareDocumentPaste: document: TextDocument * ranges: ReadonlyArray<Range> * dataTransfer: DataTransfer * token: CancellationToken -> U2<unit, Thenable<unit>>
        /// <summary>
        /// Invoked before the user pastes into a <see href="TextEditortext">editor</see>".
        ///
        /// Returned edits can replace the standard pasting behavior.
        /// </summary>
        /// <param name="document">
        /// Document being pasted into
        /// </param>
        /// <param name="ranges">
        /// Range in the {@linkcode document } to paste into.
        /// </param>
        /// <param name="dataTransfer">
        /// The <see href="DataTransfer">data transfer</see>" associated with the paste. This object is only
        /// valid for the duration of the paste operation.
        /// </param>
        /// <param name="context">
        /// Additional context for the paste.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// Set of potential <see href="DocumentPasteEdit">edits</see>" that can apply the paste. Only a single returned
        /// {@linkcode DocumentPasteEdit } is applied at a time. If multiple edits are returned from all providers, then
        /// the first is automatically applied and a widget is shown that lets the user switch to the other edits.
        /// </returns>
        abstract member provideDocumentPasteEdits: document: TextDocument * ranges: ReadonlyArray<Range> * dataTransfer: DataTransfer * context: DocumentPasteEditContext * token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// Optional method which fills in the {@linkcode DocumentPasteEdit.additionalEdit} before the edit is applied.
        ///
        /// This is called once per edit and should be used if generating the complete edit may take a long time.
        /// Resolve can only be used to change {@linkcode DocumentPasteEdit.insertText} or {@linkcode DocumentPasteEdit.additionalEdit}.
        /// </summary>
        /// <param name="pasteEdit">
        /// The {@linkcode DocumentPasteEdit } to resolve.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved paste edit or a thenable that resolves to such. It is OK to return the given
        /// <c>pasteEdit</c>. If no result is returned, the given <c>pasteEdit</c> is used.
        /// </returns>
        abstract member resolveDocumentPasteEdit: pasteEdit: 'T * token: CancellationToken -> ProviderResult<'T>

    /// <summary>
    /// An edit the applies a paste operation.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentPasteEdit =
        /// <summary>
        /// Human readable label that describes the edit.
        /// </summary>
        abstract member title: string with get, set
        /// <summary>
        /// <see href="DocumentDropOrPasteEditKindKind">DocumentDropOrPasteEditKindKind</see> of the edit.
        /// </summary>
        abstract member kind: DocumentDropOrPasteEditKind with get, set
        /// <summary>
        /// The text or snippet to insert at the pasted locations.
        ///
        /// If your edit requires more advanced insertion logic, set this to an empty string and provide an <see href="DocumentPasteEdit.additionalEditadditional">edit</see>" instead.
        /// </summary>
        abstract member insertText: U2<string, SnippetString> with get, set
        /// <summary>
        /// An optional additional edit to apply on paste.
        /// </summary>
        abstract member additionalEdit: WorkspaceEdit option with get, set
        /// <summary>
        /// Controls ordering when multiple paste edits can potentially be applied.
        ///
        /// If this edit yields to another, it will be shown lower in the list of possible paste edits shown to the user.
        /// </summary>
        abstract member yieldTo: ReadonlyArray<DocumentDropOrPasteEditKind> option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DocumentPasteProviderMetadata =
        /// <summary>
        /// List of <see href="DocumentDropOrPasteEditKindkinds">DocumentDropOrPasteEditKindkinds</see> that the provider may return in {@linkcode DocumentPasteEditProvider.provideDocumentPasteEditsprovideDocumentPasteEdits}.
        ///
        /// This is used to filter out providers when a specific <see href="DocumentDropOrPasteEditKindkind">DocumentDropOrPasteEditKindkind</see> of edit is requested.
        /// </summary>
        abstract member providedPasteEditKinds: ReadonlyArray<DocumentDropOrPasteEditKind> with get
        /// <summary>
        /// Mime types that {@linkcode DocumentPasteEditProvider.prepareDocumentPasteprepareDocumentPaste} may add on copy.
        /// </summary>
        abstract member copyMimeTypes: ReadonlyArray<string> option with get
        /// <summary>
        /// Mime types that {@linkcode DocumentPasteEditProvider.provideDocumentPasteEditsprovideDocumentPasteEdits} should be invoked for.
        ///
        /// This can either be an exact mime type such as <c>image/png</c>, or a wildcard pattern such as <c>image/*</c>.
        ///
        /// Use <c>text/uri-list</c> for resources dropped from the explorer or other tree views in the workbench.
        ///
        /// Use <c>files</c> to indicate that the provider should be invoked if any <see href="DataTransferFilefiles">DataTransferFilefiles</see> are present in the {@linkcode DataTransfer}.
        /// Note that {@linkcode DataTransferFile} entries are only created when pasting content from outside the editor, such as
        /// from the operating system.
        /// </summary>
        abstract member pasteMimeTypes: ReadonlyArray<string> option with get

    /// <summary>
    /// A tuple of two characters, like a pair of
    /// opening and closing brackets.
    /// </summary>
    type CharacterPair =
        string * string

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentRule =
        /// <summary>
        /// The line comment token, like <c>// this is a comment</c>
        /// </summary>
        abstract member lineComment: string option with get, set
        /// <summary>
        /// The block comment character pair, like <c>/* block comment *&#47;</c>
        /// </summary>
        abstract member blockComment: CharacterPair option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type IndentationRule =
        /// <summary>
        /// If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
        /// </summary>
        abstract member decreaseIndentPattern: RegExp with get, set
        /// <summary>
        /// If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
        /// </summary>
        abstract member increaseIndentPattern: RegExp with get, set
        /// <summary>
        /// If a line matches this pattern, then **only the next line** after it should be indented once.
        /// </summary>
        abstract member indentNextLinePattern: RegExp option with get, set
        /// <summary>
        /// If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
        /// </summary>
        abstract member unIndentedLinePattern: RegExp option with get, set

    [<RequireQualifiedAccess>]
    type IndentAction =
        | None = 0
        | Indent = 1
        | IndentOutdent = 2
        | Outdent = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type EnterAction =
        /// <summary>
        /// Describe what to do with the indentation.
        /// </summary>
        abstract member indentAction: IndentAction with get, set
        /// <summary>
        /// Describes text to be appended after the new line and after the indentation.
        /// </summary>
        abstract member appendText: string option with get, set
        /// <summary>
        /// Describes the number of characters to remove from the new line's indentation.
        /// </summary>
        abstract member removeText: float option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type OnEnterRule =
        /// <summary>
        /// This rule will only execute if the text before the cursor matches this regular expression.
        /// </summary>
        abstract member beforeText: RegExp with get, set
        /// <summary>
        /// This rule will only execute if the text after the cursor matches this regular expression.
        /// </summary>
        abstract member afterText: RegExp option with get, set
        /// <summary>
        /// This rule will only execute if the text above the current line matches this regular expression.
        /// </summary>
        abstract member previousLineText: RegExp option with get, set
        /// <summary>
        /// The action to execute.
        /// </summary>
        abstract member action: EnterAction with get, set

    [<RequireQualifiedAccess>]
    type SyntaxTokenType =
        | Other = 0
        | Comment = 1
        | String = 2
        | RegEx = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type AutoClosingPair =
        /// <summary>
        /// The string that will trigger the automatic insertion of the closing string.
        /// </summary>
        abstract member ``open``: string with get, set
        /// <summary>
        /// The closing string that will be automatically inserted when typing the opening string.
        /// </summary>
        abstract member close: string with get, set
        /// <summary>
        /// A set of tokens where the pair should not be auto closed.
        /// </summary>
        abstract member notIn: ResizeArray<SyntaxTokenType> option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageConfiguration =
        /// <summary>
        /// The language's comment settings.
        /// </summary>
        abstract member comments: CommentRule option with get, set
        /// <summary>
        /// The language's brackets.
        /// This configuration implicitly affects pressing Enter around these brackets.
        /// </summary>
        abstract member brackets: ResizeArray<CharacterPair> option with get, set
        /// <summary>
        /// The language's word definition.
        /// If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
        /// to provide a word definition that uses exclusion of known separators.
        /// e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
        /// <c></c><c>
        /// /(-?\d*\.\d\w*)|([^\</c>\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
        /// <c></c>`
        /// </summary>
        abstract member wordPattern: RegExp option with get, set
        /// <summary>
        /// The language's indentation settings.
        /// </summary>
        abstract member indentationRules: IndentationRule option with get, set
        /// <summary>
        /// The language's rules to be evaluated when pressing Enter.
        /// </summary>
        abstract member onEnterRules: ResizeArray<OnEnterRule> option with get, set
        /// <summary>
        /// The language's auto closing pairs.
        /// </summary>
        abstract member autoClosingPairs: ResizeArray<AutoClosingPair> option with get, set
        /// <summary>
        /// **Deprecated** Do not use.
        /// </summary>
        [<Obsolete("Will be replaced by a better API soon.")>]
        abstract member __electricCharacterSupport: LanguageConfiguration.__electricCharacterSupport option with get, set
        /// <summary>
        /// **Deprecated** Do not use.
        /// </summary>
        [<Obsolete("* Use the autoClosingPairs property in the language configuration file instead.")>]
        abstract member __characterPairSupport: LanguageConfiguration.__characterPairSupport option with get, set

    [<RequireQualifiedAccess>]
    type ConfigurationTarget =
        | Global = 1
        | Workspace = 2
        | WorkspaceFolder = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type WorkspaceConfiguration =
        /// <summary>
        /// Return a value from this configuration.
        /// </summary>
        /// <param name="section">
        /// Configuration name, supports _dotted_ names.
        /// </param>
        /// <returns>
        /// The value <c>section</c> denotes or <c>undefined</c>.
        /// </returns>
        abstract member get: section: string -> 'T option
        /// <summary>
        /// Return a value from this configuration.
        /// </summary>
        /// <param name="section">
        /// Configuration name, supports _dotted_ names.
        /// </param>
        /// <param name="defaultValue">
        /// A value should be returned when no value could be found, is <c>undefined</c>.
        /// </param>
        /// <returns>
        /// The value <c>section</c> denotes or the default.
        /// </returns>
        abstract member get: section: string * defaultValue: 'T -> 'T
        /// <summary>
        /// Check if this configuration has a certain value.
        /// </summary>
        /// <param name="section">
        /// Configuration name, supports _dotted_ names.
        /// </param>
        /// <returns>
        /// <c>true</c> if the section doesn't resolve to <c>undefined</c>.
        /// </returns>
        abstract member has: section: string -> bool
        /// <summary>
        /// Retrieve all information about a configuration setting. A configuration value
        /// often consists of a *default* value, a global or installation-wide value,
        /// a workspace-specific value, folder-specific value
        /// and language-specific values (if <see href="WorkspaceConfiguration">WorkspaceConfiguration</see> is scoped to a language).
        ///
        /// Also provides all language ids under which the given configuration setting is defined.
        ///
        /// *Note:* The configuration name must denote a leaf in the configuration tree
        /// (<c>editor.fontSize</c> vs <c>editor</c>) otherwise no result is returned.
        /// </summary>
        /// <param name="section">
        /// Configuration name, supports _dotted_ names.
        /// </param>
        /// <returns>
        /// Information about a configuration setting or <c>undefined</c>.
        /// </returns>
        abstract member inspect: section: string -> WorkspaceConfiguration.inspect<'T> option
        /// <summary>
        /// Update a configuration value. The updated configuration values are persisted.
        ///
        /// A value can be changed in
        ///
        /// - <see href="ConfigurationTarget.GlobalGlobal">settings</see>": Changes the value for all instances of the editor.
        /// - <see href="ConfigurationTarget.WorkspaceWorkspace">settings</see>": Changes the value for current workspace, if available.
        /// - <see href="ConfigurationTarget.WorkspaceFolderWorkspace">folder settings</see>": Changes the value for settings from one of the <see href="workspace.workspaceFoldersWorkspace">Folders</see>" under which the requested resource belongs to.
        /// - Language settings: Changes the value for the requested languageId.
        ///
        /// *Note:* To remove a configuration value use <c>undefined</c>, like so: <c>config.update('somekey', undefined)</c>
        /// </summary>
        /// <remarks>
        /// Throws:
        /// -------
        ///
        /// error while updating
        /// - configuration which is not registered.
        /// - window configuration to workspace folder
        /// - configuration to workspace or workspace folder when no workspace is opened.
        /// - configuration to workspace folder when there is no workspace folder settings.
        /// - configuration to workspace folder when <see href="WorkspaceConfiguration">WorkspaceConfiguration</see> is not scoped to a resource.
        /// </remarks>
        /// <param name="section">
        /// Configuration name, supports _dotted_ names.
        /// </param>
        /// <param name="value">
        /// The new value.
        /// </param>
        /// <param name="configurationTarget">
        /// The <see href="ConfigurationTarget">configuration target</see>" or a boolean value.
        /// - If <c>true</c> updates <see href="ConfigurationTarget.Global">Global settings</see>".
        /// - If <c>false</c> updates <see href="ConfigurationTarget.Workspace">Workspace settings</see>".
        /// - If <c>undefined</c> or <c>null</c> updates to <see href="ConfigurationTarget.WorkspaceFolder">Workspace folder settings</see>" if configuration is resource specific,
        /// otherwise to <see href="ConfigurationTarget.Workspace">Workspace settings</see>".
        /// </param>
        /// <param name="overrideInLanguage">
        /// Whether to update the value in the scope of requested languageId or not.
        /// - If <c>true</c> updates the value under the requested languageId.
        /// - If <c>undefined</c> updates the value under the requested languageId only if the configuration is defined for the language.
        /// </param>
        abstract member update: section: string * value: obj * ?configurationTarget: U2<ConfigurationTarget, bool> option * ?overrideInLanguage: bool -> Thenable<unit>
        [<EmitIndexer>]
        abstract member Item: key: string -> obj with get

    /// <summary>
    /// Represents a location inside a resource, such as a line
    /// inside a text file.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Location =
        /// <summary>
        /// The resource identifier of this location.
        /// </summary>
        abstract member uri: Uri with get, set
        /// <summary>
        /// The document range of this location.
        /// </summary>
        abstract member range: Range with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type LocationLink =
        /// <summary>
        /// Span of the origin of this link.
        ///
        /// Used as the underlined span for mouse definition hover. Defaults to the word range at
        /// the definition position.
        /// </summary>
        abstract member originSelectionRange: Range option with get, set
        /// <summary>
        /// The target resource identifier of this link.
        /// </summary>
        abstract member targetUri: Uri with get, set
        /// <summary>
        /// The full target range of this link.
        /// </summary>
        abstract member targetRange: Range with get, set
        /// <summary>
        /// The span of this link.
        /// </summary>
        abstract member targetSelectionRange: Range option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DiagnosticChangeEvent =
        /// <summary>
        /// An array of resources for which diagnostics have changed.
        /// </summary>
        abstract member uris: ReadonlyArray<Uri> with get

    [<RequireQualifiedAccess>]
    type DiagnosticSeverity =
        | Error = 0
        | Warning = 1
        | Information = 2
        | Hint = 3

    /// <summary>
    /// Represents a related message and source code location for a diagnostic. This should be
    /// used to point to code locations that cause or related to a diagnostics, e.g. when duplicating
    /// a symbol in a scope.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DiagnosticRelatedInformation =
        /// <summary>
        /// The location of this related diagnostic information.
        /// </summary>
        abstract member location: Location with get, set
        /// <summary>
        /// The message of this related diagnostic information.
        /// </summary>
        abstract member message: string with get, set

    [<RequireQualifiedAccess>]
    type DiagnosticTag =
        | Unnecessary = 1
        | Deprecated = 2

    /// <summary>
    /// Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
    /// are only valid in the scope of a file.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Diagnostic =
        /// <summary>
        /// The range to which this diagnostic applies.
        /// </summary>
        abstract member range: Range with get, set
        /// <summary>
        /// The human-readable message.
        /// </summary>
        abstract member message: string with get, set
        /// <summary>
        /// The severity, default is <see href="DiagnosticSeverity.Errorerror">DiagnosticSeverity.Errorerror</see>.
        /// </summary>
        abstract member severity: DiagnosticSeverity with get, set
        /// <summary>
        /// A human-readable string describing the source of this
        /// diagnostic, e.g. 'typescript' or 'super lint'.
        /// </summary>
        abstract member source: string option with get, set
        /// <summary>
        /// A code or identifier for this diagnostic.
        /// Should be used for later processing, e.g. when providing <see href="CodeActionContextcode">actions</see>".
        /// </summary>
        abstract member code: U3<string, float, Diagnostic.code.U3.Case3> option with get, set
        /// <summary>
        /// An array of related diagnostic information, e.g. when symbol-names within
        /// a scope collide all definitions can be marked via this property.
        /// </summary>
        abstract member relatedInformation: ResizeArray<DiagnosticRelatedInformation> option with get, set
        /// <summary>
        /// Additional metadata about the diagnostic.
        /// </summary>
        abstract member tags: ResizeArray<DiagnosticTag> option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DiagnosticCollection =
        inherit Iterable<Uri * ReadonlyArray<Diagnostic>>
        /// <summary>
        /// The name of this diagnostic collection, for instance <c>typescript</c>. Every diagnostic
        /// from this collection will be associated with this name. Also, the task framework uses this
        /// name when defining [problem matchers](https://code.visualstudio.com/docs/editor/tasks#_defining-a-problem-matcher).
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// Assign diagnostics for given resource. Will replace
        /// existing diagnostics for that resource.
        /// Replace diagnostics for multiple resources in this collection.
        ///
        ///  _Note_ that multiple tuples of the same uri will be merged, e.g
        /// <c>[[file1, [d1]], [file1, [d2]]]</c> is equivalent to <c>[[file1, [d1, d2]]]</c>.
        /// If a diagnostics item is <c>undefined</c> as in <c>[file1, undefined]</c>
        /// all previous but not subsequent diagnostics are removed.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <param name="diagnostics">
        /// Array of diagnostics or <c>undefined</c>
        /// </param>
        abstract member set: uri: Uri * diagnostics: ReadonlyArray<Diagnostic> option -> unit
        /// <summary>
        /// Assign diagnostics for given resource. Will replace
        /// existing diagnostics for that resource.
        /// Replace diagnostics for multiple resources in this collection.
        ///
        ///  _Note_ that multiple tuples of the same uri will be merged, e.g
        /// <c>[[file1, [d1]], [file1, [d2]]]</c> is equivalent to <c>[[file1, [d1, d2]]]</c>.
        /// If a diagnostics item is <c>undefined</c> as in <c>[file1, undefined]</c>
        /// all previous but not subsequent diagnostics are removed.
        /// </summary>
        /// <param name="entries">
        /// An array of tuples, like <c>[[file1, [d1, d2]], [file2, [d3, d4, d5]]]</c>, or <c>undefined</c>.
        /// </param>
        abstract member set: entries: ReadonlyArray<Uri * ReadonlyArray<Diagnostic> option> -> unit
        /// <summary>
        /// Remove all diagnostics from this collection that belong
        /// to the provided <c>uri</c>. The same as <c>#set(uri, undefined)</c>.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        abstract member delete: uri: Uri -> unit
        /// <summary>
        /// Remove all diagnostics from this collection. The same
        /// as calling <c>#set(undefined)</c>;
        /// </summary>
        abstract member clear: unit -> unit
        /// <summary>
        /// Iterate over each entry in this collection.
        /// </summary>
        /// <param name="callback">
        /// Function to execute for each entry.
        /// </param>
        /// <param name="thisArg">
        /// The <c>this</c> context used when invoking the handler function.
        /// </param>
        abstract member forEach: callback: DiagnosticCollection.forEach.callback * ?thisArg: obj -> unit
        /// <summary>
        /// Get the diagnostics for a given resource. *Note* that you cannot
        /// modify the diagnostics-array returned from this call.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <returns>
        /// An immutable array of <see href="Diagnostic">diagnostics</see>" or <c>undefined</c>.
        /// </returns>
        abstract member get: uri: Uri -> ReadonlyArray<Diagnostic> option
        /// <summary>
        /// Check if this collection contains diagnostics for a
        /// given resource.
        /// </summary>
        /// <param name="uri">
        /// A resource identifier.
        /// </param>
        /// <returns>
        /// <c>true</c> if this collection has diagnostic for the given resource.
        /// </returns>
        abstract member has: uri: Uri -> bool
        /// <summary>
        /// Dispose and free associated resources. Calls
        /// <see href="DiagnosticCollection.clearclear">DiagnosticCollection.clearclear</see>.
        /// </summary>
        abstract member dispose: unit -> unit

    [<RequireQualifiedAccess>]
    type LanguageStatusSeverity =
        | Information = 0
        | Warning = 1
        | Error = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageStatusItem =
        /// <summary>
        /// The identifier of this item.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The short name of this item, like 'Java Language Status', etc.
        /// </summary>
        abstract member name: string option with get, set
        /// <summary>
        /// A <see href="DocumentSelectorselector">DocumentSelectorselector</see> that defines for what editors
        /// this item shows.
        /// </summary>
        abstract member selector: DocumentSelector with get, set
        /// <summary>
        /// The severity of this item.
        ///
        /// Defaults to <see href="LanguageStatusSeverity.Informationinformation">LanguageStatusSeverity.Informationinformation</see>. You can use this property to
        /// signal to users that there is a problem that needs attention, like a missing executable or an
        /// invalid configuration.
        /// </summary>
        abstract member severity: LanguageStatusSeverity with get, set
        /// <summary>
        /// The text to show for the entry. You can embed icons in the text by leveraging the syntax:
        ///
        /// <c>My text $(icon-name) contains icons like $(icon-name) this one.</c>
        ///
        /// Where the icon-name is taken from the ThemeIcon [icon set](https://code.visualstudio.com/api/references/icons-in-labels#icon-listing), e.g.
        /// <c>light-bulb</c>, <c>thumbsup</c>, <c>zap</c> etc.
        /// </summary>
        abstract member text: string with get, set
        /// <summary>
        /// Optional, human-readable details for this item.
        /// </summary>
        abstract member detail: string option with get, set
        /// <summary>
        /// Controls whether the item is shown as "busy". Defaults to <c>false</c>.
        /// </summary>
        abstract member busy: bool with get, set
        /// <summary>
        /// A {@linkcode Commandcommand} for this item.
        /// </summary>
        abstract member command: Command option with get, set
        /// <summary>
        /// Accessibility information used when a screen reader interacts with this item
        /// </summary>
        abstract member accessibilityInformation: AccessibilityInformation option with get, set
        /// <summary>
        /// Dispose and free associated resources.
        /// </summary>
        abstract member dispose: unit -> unit

    [<RequireQualifiedAccess>]
    type ViewColumn =
        | Active = -1
        | Beside = -2
        | One = 1
        | Two = 2
        | Three = 3
        | Four = 4
        | Five = 5
        | Six = 6
        | Seven = 7
        | Eight = 8
        | Nine = 9

    [<AllowNullLiteral>]
    [<Interface>]
    type OutputChannel =
        /// <summary>
        /// The human-readable name of this output channel.
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// Append the given value to the channel.
        /// </summary>
        /// <param name="value">
        /// A string, falsy values will not be printed.
        /// </param>
        abstract member append: value: string -> unit
        /// <summary>
        /// Append the given value and a line feed character
        /// to the channel.
        /// </summary>
        /// <param name="value">
        /// A string, falsy values will be printed.
        /// </param>
        abstract member appendLine: value: string -> unit
        /// <summary>
        /// Replaces all output from the channel with the given value.
        /// </summary>
        /// <param name="value">
        /// A string, falsy values will not be printed.
        /// </param>
        abstract member replace: value: string -> unit
        /// <summary>
        /// Removes all output from the channel.
        /// </summary>
        abstract member clear: unit -> unit
        /// <summary>
        /// Reveal this channel in the UI.
        /// </summary>
        /// <param name="preserveFocus">
        /// When <c>true</c> the channel will not take focus.
        /// </param>
        abstract member show: ?preserveFocus: bool -> unit
        /// <summary>
        /// Reveal this channel in the UI.
        /// </summary>
        /// <param name="column">
        /// This argument is **deprecated** and will be ignored.
        /// </param>
        /// <param name="preserveFocus">
        /// When <c>true</c> the channel will not take focus.
        /// </param>
        [<Obsolete("Use the overload with just one parameter (`show(preserveFocus?: boolean): void`).")>]
        abstract member show: ?column: ViewColumn * ?preserveFocus: bool -> unit
        /// <summary>
        /// Hide this channel from the UI.
        /// </summary>
        abstract member hide: unit -> unit
        /// <summary>
        /// Dispose and free associated resources.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type LogOutputChannel =
        inherit OutputChannel
        /// <summary>
        /// The current log level of the channel. Defaults to <see href="env.logLeveleditor">log level</see>".
        /// </summary>
        abstract member logLevel: LogLevel with get
        /// <summary>
        /// An <see href="Event">Event</see> which fires when the log level of the channel changes.
        /// </summary>
        abstract member onDidChangeLogLevel: Event<LogLevel> with get
        /// <summary>
        /// Outputs the given trace message to the channel. Use this method to log verbose information.
        ///
        /// The message is only logged if the channel is configured to display <see href="LogLevel.Tracetrace">LogLevel.Tracetrace</see> log level.
        /// </summary>
        /// <param name="message">
        /// trace message to log
        /// </param>
        abstract member trace: message: string * [<ParamArray>] args: obj [] -> unit
        /// <summary>
        /// Outputs the given debug message to the channel.
        ///
        /// The message is only logged if the channel is configured to display <see href="LogLevel.Debugdebug">LogLevel.Debugdebug</see> log level or lower.
        /// </summary>
        /// <param name="message">
        /// debug message to log
        /// </param>
        abstract member debug: message: string * [<ParamArray>] args: obj [] -> unit
        /// <summary>
        /// Outputs the given information message to the channel.
        ///
        /// The message is only logged if the channel is configured to display <see href="LogLevel.Infoinfo">LogLevel.Infoinfo</see> log level or lower.
        /// </summary>
        /// <param name="message">
        /// info message to log
        /// </param>
        abstract member info: message: string * [<ParamArray>] args: obj [] -> unit
        /// <summary>
        /// Outputs the given warning message to the channel.
        ///
        /// The message is only logged if the channel is configured to display <see href="LogLevel.Warningwarning">LogLevel.Warningwarning</see> log level or lower.
        /// </summary>
        /// <param name="message">
        /// warning message to log
        /// </param>
        abstract member warn: message: string * [<ParamArray>] args: obj [] -> unit
        /// <summary>
        /// Outputs the given error or error message to the channel.
        ///
        /// The message is only logged if the channel is configured to display <see href="LogLevel.Errorerror">LogLevel.Errorerror</see> log level or lower.
        /// </summary>
        /// <param name="error">
        /// Error or error message to log
        /// </param>
        abstract member error: error: U2<string, Exception> * [<ParamArray>] args: obj [] -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type AccessibilityInformation =
        /// <summary>
        /// Label to be read out by a screen reader once the item has focus.
        /// </summary>
        abstract member label: string with get
        /// <summary>
        /// Role of the widget which defines how a screen reader interacts with it.
        /// The role should be set in special cases when for example a tree-like element behaves like a checkbox.
        /// If role is not specified the editor will pick the appropriate role automatically.
        /// More about aria roles can be found here https://w3c.github.io/aria/#widget_roles
        /// </summary>
        abstract member role: string option with get

    [<RequireQualifiedAccess>]
    type StatusBarAlignment =
        | Left = 1
        | Right = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type StatusBarItem =
        /// <summary>
        /// The identifier of this item.
        ///
        /// *Note*: if no identifier was provided by the {@linkcode window.createStatusBarItem}
        /// method, the identifier will match the <see href="Extension.idextension">identifier</see>".
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The alignment of this item.
        /// </summary>
        abstract member alignment: StatusBarAlignment with get
        /// <summary>
        /// The priority of this item. Higher value means the item should
        /// be shown more to the left.
        /// </summary>
        abstract member priority: float option with get
        /// <summary>
        /// The name of the entry, like 'Python Language Indicator', 'Git Status' etc.
        /// Try to keep the length of the name short, yet descriptive enough that
        /// users can understand what the status bar item is about.
        /// </summary>
        abstract member name: string option with get, set
        /// <summary>
        /// The text to show for the entry. You can embed icons in the text by leveraging the syntax:
        ///
        /// <c>My text $(icon-name) contains icons like $(icon-name) this one.</c>
        ///
        /// Where the icon-name is taken from the ThemeIcon [icon set](https://code.visualstudio.com/api/references/icons-in-labels#icon-listing), e.g.
        /// <c>light-bulb</c>, <c>thumbsup</c>, <c>zap</c> etc.
        /// </summary>
        abstract member text: string with get, set
        /// <summary>
        /// The tooltip text when you hover over this entry.
        /// </summary>
        abstract member tooltip: U2<string, MarkdownString> option with get, set
        /// <summary>
        /// The foreground color for this entry.
        /// </summary>
        abstract member color: U2<string, ThemeColor> option with get, set
        /// <summary>
        /// The background color for this entry.
        ///
        /// *Note*: only the following colors are supported:
        /// * <c>new ThemeColor('statusBarItem.errorBackground')</c>
        /// * <c>new ThemeColor('statusBarItem.warningBackground')</c>
        ///
        /// More background colors may be supported in the future.
        ///
        /// *Note*: when a background color is set, the statusbar may override
        /// the <c>color</c> choice to ensure the entry is readable in all themes.
        /// </summary>
        abstract member backgroundColor: ThemeColor option with get, set
        /// <summary>
        /// {@linkcode Command} or identifier of a command to run on click.
        ///
        /// The command must be <see href="commands.getCommandsknown">commands.getCommandsknown</see>.
        ///
        /// Note that if this is a {@linkcode Command} object, only the {@linkcode Command.commandcommand} and {@linkcode Command.argumentsarguments}
        /// are used by the editor.
        /// </summary>
        abstract member command: U2<string, Command> option with get, set
        /// <summary>
        /// Accessibility information used when a screen reader interacts with this StatusBar item
        /// </summary>
        abstract member accessibilityInformation: AccessibilityInformation option with get, set
        /// <summary>
        /// Shows the entry in the status bar.
        /// </summary>
        abstract member show: unit -> unit
        /// <summary>
        /// Hide the entry in the status bar.
        /// </summary>
        abstract member hide: unit -> unit
        /// <summary>
        /// Dispose and free associated resources. Call
        /// <see href="StatusBarItem.hidehide">StatusBarItem.hidehide</see>.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type Progress<'T> =
        /// <summary>
        /// Report a progress update.
        /// </summary>
        /// <param name="value">
        /// A progress item, like a message and/or an
        /// report on how much work finished
        /// </param>
        abstract member report: value: 'T -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type Terminal =
        /// <summary>
        /// The name of the terminal.
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// The process ID of the shell process.
        /// </summary>
        abstract member processId: Thenable<float option> with get
        /// <summary>
        /// The object used to initialize the terminal, this is useful for example to detecting the
        /// shell type of when the terminal was not launched by this extension or for detecting what
        /// folder the shell was launched in.
        /// </summary>
        abstract member creationOptions: U2<Terminal.creationOptions.U2.ReadOnlyTerminalOptions, Terminal.creationOptions.U2.ReadOnlyExtensionTerminalOptions> with get
        /// <summary>
        /// The exit status of the terminal, this will be undefined while the terminal is active.
        ///
        /// **Example:** Show a notification with the exit code when the terminal exits with a
        /// non-zero exit code.
        /// <c></c><c>typescript
        /// window.onDidCloseTerminal(t => {
        ///   if (t.exitStatus && t.exitStatus.code) {
        ///   	vscode.window.showInformationMessage(</c>Exit code: ${t.exitStatus.code}<c>);
        ///   }
        /// });
        /// </c><c></c>
        /// </summary>
        abstract member exitStatus: TerminalExitStatus option with get
        /// <summary>
        /// The current state of the <see href="Terminal">Terminal</see>.
        /// </summary>
        abstract member state: TerminalState with get
        /// <summary>
        /// An object that contains [shell integration](https://code.visualstudio.com/docs/terminal/shell-integration)-powered
        /// features for the terminal. This will always be <c>undefined</c> immediately after the terminal
        /// is created. Listen to <see href="window.onDidChangeTerminalShellIntegration">window.onDidChangeTerminalShellIntegration</see> to be notified
        /// when shell integration is activated for a terminal.
        ///
        /// Note that this object may remain undefined if shell integration never activates. For
        /// example Command Prompt does not support shell integration and a user's shell setup could
        /// conflict with the automatic shell integration activation.
        /// </summary>
        abstract member shellIntegration: TerminalShellIntegration option with get
        /// <summary>
        /// Send text to the terminal. The text is written to the stdin of the underlying pty process
        /// (shell) of the terminal.
        /// </summary>
        /// <param name="text">
        /// The text to send.
        /// </param>
        /// <param name="shouldExecute">
        /// Indicates that the text being sent should be executed rather than just inserted in the terminal.
        /// The character(s) added are <c>\n</c> or <c>\r\n</c>, depending on the platform. This defaults to <c>true</c>.
        /// </param>
        abstract member sendText: text: string * ?shouldExecute: bool -> unit
        /// <summary>
        /// Show the terminal panel and reveal this terminal in the UI.
        /// </summary>
        /// <param name="preserveFocus">
        /// When <c>true</c> the terminal will not take focus.
        /// </param>
        abstract member show: ?preserveFocus: bool -> unit
        /// <summary>
        /// Hide the terminal panel if this terminal is currently showing.
        /// </summary>
        abstract member hide: unit -> unit
        /// <summary>
        /// Dispose and free associated resources.
        /// </summary>
        abstract member dispose: unit -> unit

    [<RequireQualifiedAccess>]
    type TerminalLocation =
        | Panel = 1
        | Editor = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalEditorLocationOptions =
        /// <summary>
        /// A view column in which the <see href="Terminalterminal">Terminalterminal</see> should be shown in the editor area.
        /// The default is the <see href="ViewColumn.Activeactive">ViewColumn.Activeactive</see>. Columns that do not exist
        /// will be created as needed up to the maximum of {@linkcode ViewColumn.Nine}.
        /// Use {@linkcode ViewColumn.Beside} to open the editor to the side of the currently
        /// active one.
        /// </summary>
        abstract member viewColumn: ViewColumn with get, set
        /// <summary>
        /// An optional flag that when <c>true</c> will stop the <see href="Terminal">Terminal</see> from taking focus.
        /// </summary>
        abstract member preserveFocus: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalSplitLocationOptions =
        /// <summary>
        /// The parent terminal to split this terminal beside. This works whether the parent terminal
        /// is in the panel or the editor area.
        /// </summary>
        abstract member parentTerminal: Terminal with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalState =
        /// <summary>
        /// Whether the <see href="Terminal">Terminal</see> has been interacted with. Interaction means that the
        /// terminal has sent data to the process which depending on the terminal's _mode_. By
        /// default input is sent when a key is pressed or when a command or extension sends text,
        /// but based on the terminal's mode it can also happen on:
        ///
        /// - a pointer click event
        /// - a pointer scroll event
        /// - a pointer move event
        /// - terminal focus in/out
        ///
        /// For more information on events that can send data see "DEC Private Mode Set (DECSET)" on
        /// https://invisible-island.net/xterm/ctlseqs/ctlseqs.html
        /// </summary>
        abstract member isInteractedWith: bool with get
        /// <summary>
        /// The detected shell type of the <see href="Terminal">Terminal</see>. This will be <c>undefined</c> when there is
        /// not a clear signal as to what the shell is, or the shell is not supported yet. This
        /// value should change to the shell type of a sub-shell when launched (for example, running
        /// <c>bash</c> inside <c>zsh</c>).
        ///
        /// Note that the possible values are currently defined as any of the following:
        /// 'bash', 'cmd', 'csh', 'fish', 'gitbash', 'julia', 'ksh', 'node', 'nu', 'pwsh', 'python',
        /// 'sh', 'wsl', 'xonsh', 'zsh'.
        /// </summary>
        abstract member shell: string option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalShellIntegration =
        /// <summary>
        /// The current working directory of the terminal. This <see href="Uri">Uri</see> may represent a file on
        /// another machine (eg. ssh into another machine). This requires the shell integration to
        /// support working directory reporting.
        /// </summary>
        abstract member cwd: Uri option with get
        /// <summary>
        /// Execute a command, sending ^C as necessary to interrupt any running command if needed.
        /// Execute a command, sending ^C as necessary to interrupt any running command if needed.
        ///
        /// *Note* This is not guaranteed to work as [shell integration](https://code.visualstudio.com/docs/terminal/shell-integration)
        /// must be activated. Check whether <see href="TerminalShellExecution.exitCode">TerminalShellExecution.exitCode</see> is rejected to
        /// verify whether it was successful.
        /// </summary>
        /// <remarks>
        /// Throws:
        /// -------
        ///
        /// When run on a terminal doesn't support this API, such as task terminals.
        /// </remarks>
        /// <example>
        /// // Execute a command in a terminal immediately after being created
        /// const myTerm = window.createTerminal();
        /// window.onDidChangeTerminalShellIntegration(async ({ terminal, shellIntegration }) => {
        ///   if (terminal === myTerm) {
        ///     const execution = shellIntegration.executeCommand('echo "Hello world"');
        ///     window.onDidEndTerminalShellExecution(event => {
        ///       if (event.execution === execution) {
        ///         console.log(<c>Command exited with code ${event.exitCode}</c>);
        ///       }
        ///     });
        ///   }
        /// }));
        /// // Fallback to sendText if there is no shell integration within 3 seconds of launching
        /// setTimeout(() => {
        ///   if (!myTerm.shellIntegration) {
        ///     myTerm.sendText('echo "Hello world"');
        ///     // Without shell integration, we can't know when the command has finished or what the
        ///     // exit code was.
        ///   }
        /// }, 3000);
        /// </example>
        /// <example>
        /// // Send command to terminal that has been alive for a while
        /// const commandLine = 'echo "Hello world"';
        /// if (term.shellIntegration) {
        ///   const execution = shellIntegration.executeCommand({ commandLine });
        ///   window.onDidEndTerminalShellExecution(event => {
        ///     if (event.execution === execution) {
        ///       console.log(<c>Command exited with code ${event.exitCode}</c>);
        ///     }
        ///   });
        /// } else {
        ///   term.sendText(commandLine);
        ///   // Without shell integration, we can't know when the command has finished or what the
        ///   // exit code was.
        /// }
        /// </example>
        /// <param name="commandLine">
        /// The command line to execute, this is the exact text that will be sent
        /// to the terminal.
        /// </param>
        abstract member executeCommand: commandLine: string -> TerminalShellExecution
        /// <summary>
        /// Execute a command, sending ^C as necessary to interrupt any running command if needed.
        /// Execute a command, sending ^C as necessary to interrupt any running command if needed.
        ///
        /// *Note* This is not guaranteed to work as [shell integration](https://code.visualstudio.com/docs/terminal/shell-integration)
        /// must be activated. Check whether <see href="TerminalShellExecution.exitCode">TerminalShellExecution.exitCode</see> is rejected to
        /// verify whether it was successful.
        /// </summary>
        /// <example>
        /// // Execute a command in a terminal immediately after being created
        /// const myTerm = window.createTerminal();
        /// window.onDidChangeTerminalShellIntegration(async ({ terminal, shellIntegration }) => {
        ///   if (terminal === myTerm) {
        ///     const command = shellIntegration.executeCommand({
        ///       command: 'echo',
        ///       args: ['Hello world']
        ///     });
        ///     const code = await command.exitCode;
        ///     console.log(<c>Command exited with code ${code}</c>);
        ///   }
        /// }));
        /// // Fallback to sendText if there is no shell integration within 3 seconds of launching
        /// setTimeout(() => {
        ///   if (!myTerm.shellIntegration) {
        ///     myTerm.sendText('echo "Hello world"');
        ///     // Without shell integration, we can't know when the command has finished or what the
        ///     // exit code was.
        ///   }
        /// }, 3000);
        /// </example>
        /// <example>
        /// // Send command to terminal that has been alive for a while
        /// const commandLine = 'echo "Hello world"';
        /// if (term.shellIntegration) {
        ///   const command = term.shellIntegration.executeCommand({
        ///     command: 'echo',
        ///     args: ['Hello world']
        ///   });
        ///   const code = await command.exitCode;
        ///   console.log(<c>Command exited with code ${code}</c>);
        /// } else {
        ///   term.sendText(commandLine);
        ///   // Without shell integration, we can't know when the command has finished or what the
        ///   // exit code was.
        /// }
        /// </example>
        /// <param name="executable">
        /// A command to run.
        /// </param>
        /// <param name="args">
        /// Arguments to launch the executable with. The arguments will be escaped such
        /// that they are interpreted as single arguments when the argument both contains whitespace
        /// and does not include any single quote, double quote or backtick characters.
        ///
        /// Note that this escaping is not intended to be a security measure, be careful when passing
        /// untrusted data to this API as strings like <c>$(...)</c> can often be used in shells to
        /// execute code within a string.
        /// </param>
        abstract member executeCommand: executable: string * args: ResizeArray<string> -> TerminalShellExecution

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalShellExecution =
        /// <summary>
        /// The command line that was executed. The <see href="TerminalShellExecutionCommandLineConfidenceconfidence">TerminalShellExecutionCommandLineConfidenceconfidence</see>
        /// of this value depends on the specific shell's shell integration implementation. This
        /// value may become more accurate after <see href="window.onDidEndTerminalShellExecution">window.onDidEndTerminalShellExecution</see> is
        /// fired.
        /// </summary>
        /// <example>
        /// // Log the details of the command line on start and end
        /// window.onDidStartTerminalShellExecution(event => {
        ///   const commandLine = event.execution.commandLine;
        ///   console.log(<c>Command started\n${summarizeCommandLine(commandLine)}</c>);
        /// });
        /// window.onDidEndTerminalShellExecution(event => {
        ///   const commandLine = event.execution.commandLine;
        ///   console.log(<c>Command ended\n${summarizeCommandLine(commandLine)}</c>);
        /// });
        /// function summarizeCommandLine(commandLine: TerminalShellExecutionCommandLine) {
        ///   return [
        ///     <c>  Command line: ${command.commandLine.value}</c>,
        ///     <c>  Confidence: ${command.commandLine.confidence}</c>,
        ///     `  Trusted: ${command.commandLine.isTrusted}
        ///   ].join('\n');
        /// }
        /// </example>
        abstract member commandLine: TerminalShellExecutionCommandLine with get
        /// <summary>
        /// The working directory that was reported by the shell when this command executed. This
        /// <see href="Uri">Uri</see> may represent a file on another machine (eg. ssh into another machine). This
        /// requires the shell integration to support working directory reporting.
        /// </summary>
        abstract member cwd: Uri option with get
        /// <summary>
        /// Creates a stream of raw data (including escape sequences) that is written to the
        /// terminal. This will only include data that was written after <c>read</c> was called for
        /// the first time, ie. you must call <c>read</c> immediately after the command is executed via
        /// <see href="TerminalShellIntegration.executeCommand">TerminalShellIntegration.executeCommand</see> or
        /// <see href="window.onDidStartTerminalShellExecution">window.onDidStartTerminalShellExecution</see> to not miss any data.
        /// </summary>
        /// <example>
        /// // Log all data written to the terminal for a command
        /// const command = term.shellIntegration.executeCommand({ commandLine: 'echo "Hello world"' });
        /// const stream = command.read();
        /// for await (const data of stream) {
        ///   console.log(data);
        /// }
        /// </example>
        abstract member read: unit -> AsyncIterable<string>

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalShellExecutionCommandLine =
        /// <summary>
        /// The full command line that was executed, including both the command and its arguments.
        /// </summary>
        abstract member value: string with get
        /// <summary>
        /// Whether the command line value came from a trusted source and is therefore safe to
        /// execute without user additional confirmation, such as a notification that asks "Do you
        /// want to execute (command)?". This verification is likely only needed if you are going to
        /// execute the command again.
        ///
        /// This is <c>true</c> only when the command line was reported explicitly by the shell
        /// integration script (ie. <see href="TerminalShellExecutionCommandLineConfidence.Highhigh">confidence</see>")
        /// and it used a nonce for verification.
        /// </summary>
        abstract member isTrusted: bool with get
        /// <summary>
        /// The confidence of the command line value which is determined by how the value was
        /// obtained. This depends upon the implementation of the shell integration script.
        /// </summary>
        abstract member confidence: TerminalShellExecutionCommandLineConfidence with get

    [<RequireQualifiedAccess>]
    type TerminalShellExecutionCommandLineConfidence =
        | Low = 0
        | Medium = 1
        | High = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalShellIntegrationChangeEvent =
        /// <summary>
        /// The terminal that shell integration has been activated in.
        /// </summary>
        abstract member terminal: Terminal with get
        /// <summary>
        /// The shell integration object.
        /// </summary>
        abstract member shellIntegration: TerminalShellIntegration with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalShellExecutionStartEvent =
        /// <summary>
        /// The terminal that shell integration has been activated in.
        /// </summary>
        abstract member terminal: Terminal with get
        /// <summary>
        /// The shell integration object.
        /// </summary>
        abstract member shellIntegration: TerminalShellIntegration with get
        /// <summary>
        /// The terminal shell execution that has ended.
        /// </summary>
        abstract member execution: TerminalShellExecution with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalShellExecutionEndEvent =
        /// <summary>
        /// The terminal that shell integration has been activated in.
        /// </summary>
        abstract member terminal: Terminal with get
        /// <summary>
        /// The shell integration object.
        /// </summary>
        abstract member shellIntegration: TerminalShellIntegration with get
        /// <summary>
        /// The terminal shell execution that has ended.
        /// </summary>
        abstract member execution: TerminalShellExecution with get
        /// <summary>
        /// The exit code reported by the shell.
        ///
        /// When this is <c>undefined</c> it can mean several things:
        ///
        /// - The shell either did not report an exit  code (ie. the shell integration script is
        ///   misbehaving)
        /// - The shell reported a command started before the command finished (eg. a sub-shell was
        ///   opened).
        /// - The user canceled the command via ctrl+c.
        /// - The user pressed enter when there was no input.
        ///
        /// Generally this should not happen. Depending on the use case, it may be best to treat this
        /// as a failure.
        /// </summary>
        /// <example>
        /// const execution = shellIntegration.executeCommand({
        ///   command: 'echo',
        ///   args: ['Hello world']
        /// });
        /// window.onDidEndTerminalShellExecution(event => {
        ///   if (event.execution === execution) {
        ///     if (event.exitCode === undefined) {
        /// 	     console.log('Command finished but exit code is unknown');
        ///     } else if (event.exitCode === 0) {
        /// 	     console.log('Command succeeded');
        ///     } else {
        /// 	     console.log('Command failed');
        ///     }
        ///   }
        /// });
        /// </example>
        abstract member exitCode: float option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalLinkContext =
        /// <summary>
        /// This is the text from the unwrapped line in the terminal.
        /// </summary>
        abstract member line: string with get, set
        /// <summary>
        /// The terminal the link belongs to.
        /// </summary>
        abstract member terminal: Terminal with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalLinkProvider<'T when 'T :> TerminalLink> =
        /// <summary>
        /// Provide terminal links for the given context. Note that this can be called multiple times
        /// even before previous calls resolve, make sure to not share global objects (eg. <c>RegExp</c>)
        /// that could have problems when asynchronous usage may overlap.
        /// </summary>
        /// <param name="context">
        /// Information about what links are being provided for.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A list of terminal links for the given line.
        /// </returns>
        abstract member provideTerminalLinks: context: TerminalLinkContext * token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// Handle an activated terminal link.
        /// </summary>
        /// <param name="link">
        /// The link to handle.
        /// </param>
        abstract member handleTerminalLink: link: 'T -> ProviderResult<unit>

    /// <summary>
    /// A link on a terminal line.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalLink =
        /// <summary>
        /// The start index of the link on <see href="TerminalLinkContext.line">TerminalLinkContext.line</see>.
        /// </summary>
        abstract member startIndex: float with get, set
        /// <summary>
        /// The length of the link on <see href="TerminalLinkContext.line">TerminalLinkContext.line</see>.
        /// </summary>
        abstract member length: float with get, set
        /// <summary>
        /// The tooltip text when you hover over this link.
        ///
        /// If a tooltip is provided, is will be displayed in a string that includes instructions on
        /// how to trigger the link, such as <c>{0} (ctrl + click)</c>. The specific instructions vary
        /// depending on OS, user settings, and localization.
        /// </summary>
        abstract member tooltip: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalProfileProvider =
        /// <summary>
        /// Provide the terminal profile.
        /// </summary>
        /// <param name="token">
        /// A cancellation token that indicates the result is no longer needed.
        /// </param>
        /// <returns>
        /// The terminal profile.
        /// </returns>
        abstract member provideTerminalProfile: token: CancellationToken -> ProviderResult<TerminalProfile>

    /// <summary>
    /// A terminal profile defines how a terminal will be launched.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalProfile =
        /// <summary>
        /// The options that the terminal will launch with.
        /// </summary>
        abstract member options: U2<TerminalOptions, ExtensionTerminalOptions> with get, set

    /// <summary>
    /// A file decoration represents metadata that can be rendered with a file.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type FileDecoration =
        /// <summary>
        /// A very short string that represents this decoration.
        /// </summary>
        abstract member badge: string option with get, set
        /// <summary>
        /// A human-readable tooltip for this decoration.
        /// </summary>
        abstract member tooltip: string option with get, set
        /// <summary>
        /// The color of this decoration.
        /// </summary>
        abstract member color: ThemeColor option with get, set
        /// <summary>
        /// A flag expressing that this decoration should be
        /// propagated to its parents.
        /// </summary>
        abstract member propagate: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type FileDecorationProvider =
        /// <summary>
        /// An optional event to signal that decorations for one or many files have changed.
        ///
        /// *Note* that this event should be used to propagate information about children.
        /// </summary>
        abstract member onDidChangeFileDecorations: Event<U2<Uri, ResizeArray<Uri>> option> option with get, set
        /// <summary>
        /// Provide decorations for a given uri.
        ///
        /// *Note* that this function is only called when a file gets rendered in the UI.
        /// This means a decoration from a descendent that propagates upwards must be signaled
        /// to the editor via the <see href="FileDecorationProvider.onDidChangeFileDecorationsonDidChangeFileDecorations">FileDecorationProvider.onDidChangeFileDecorationsonDidChangeFileDecorations</see>-event.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file to provide a decoration for.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A decoration or a thenable that resolves to such.
        /// </returns>
        abstract member provideFileDecoration: uri: Uri * token: CancellationToken -> ProviderResult<FileDecoration>

    [<RequireQualifiedAccess>]
    type ExtensionKind =
        | UI = 1
        | Workspace = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type Extension<'T> =
        /// <summary>
        /// The canonical extension identifier in the form of: <c>publisher.name</c>.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The uri of the directory containing the extension.
        /// </summary>
        abstract member extensionUri: Uri with get
        /// <summary>
        /// The absolute file path of the directory containing this extension. Shorthand
        /// notation for <see href="Extension.extensionUriExtension.extensionUri.fsPath">Extension.extensionUriExtension.extensionUri.fsPath</see> (independent of the uri scheme).
        /// </summary>
        abstract member extensionPath: string with get
        /// <summary>
        /// <c>true</c> if the extension has been activated.
        /// </summary>
        abstract member isActive: bool with get
        /// <summary>
        /// The parsed contents of the extension's package.json.
        /// </summary>
        abstract member packageJSON: obj with get
        /// <summary>
        /// The extension kind describes if an extension runs where the UI runs
        /// or if an extension runs where the remote extension host runs. The extension kind
        /// is defined in the <c>package.json</c>-file of extensions but can also be refined
        /// via the <c>remote.extensionKind</c>-setting. When no remote extension host exists,
        /// the value is {@linkcode ExtensionKind.UI}.
        /// </summary>
        abstract member extensionKind: ExtensionKind with get, set
        /// <summary>
        /// The public API exported by this extension (return value of <c>activate</c>).
        /// It is an invalid action to access this field before this extension has been activated.
        /// </summary>
        abstract member exports: 'T with get
        /// <summary>
        /// Activates this extension and returns its public API.
        /// </summary>
        /// <returns>
        /// A promise that will resolve when this extension has been activated.
        /// </returns>
        abstract member activate: unit -> Thenable<'T>

    [<RequireQualifiedAccess>]
    type ExtensionMode =
        | Production = 1
        | Development = 2
        | Test = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type ExtensionContext =
        /// <summary>
        /// An array to which disposables can be added. When this
        /// extension is deactivated the disposables will be disposed.
        ///
        /// *Note* that asynchronous dispose-functions aren't awaited.
        /// </summary>
        abstract member subscriptions: ResizeArray<ExtensionContext.subscriptions> with get
        /// <summary>
        /// A memento object that stores state in the context
        /// of the currently opened <see href="workspace.workspaceFoldersworkspace">workspace.workspaceFoldersworkspace</see>.
        /// </summary>
        abstract member workspaceState: Memento with get
        /// <summary>
        /// A memento object that stores state independent
        /// of the current opened <see href="workspace.workspaceFoldersworkspace">workspace.workspaceFoldersworkspace</see>.
        /// </summary>
        abstract member globalState: obj with get
        /// <summary>
        /// A secret storage object that stores state independent
        /// of the current opened <see href="workspace.workspaceFoldersworkspace">workspace.workspaceFoldersworkspace</see>.
        /// </summary>
        abstract member secrets: SecretStorage with get
        /// <summary>
        /// The uri of the directory containing the extension.
        /// </summary>
        abstract member extensionUri: Uri with get
        /// <summary>
        /// The absolute file path of the directory containing the extension. Shorthand
        /// notation for <see href="TextDocument.uriExtensionContext.extensionUri.fsPath">TextDocument.uriExtensionContext.extensionUri.fsPath</see> (independent of the uri scheme).
        /// </summary>
        abstract member extensionPath: string with get
        /// <summary>
        /// Gets the extension's global environment variable collection for this workspace, enabling changes to be
        /// applied to terminal environment variables.
        /// </summary>
        abstract member environmentVariableCollection: GlobalEnvironmentVariableCollection with get
        /// <summary>
        /// Get the absolute path of a resource contained in the extension.
        ///
        /// *Note* that an absolute uri can be constructed via {@linkcode Uri.joinPath} and
        /// {@linkcode ExtensionContext.extensionUriextensionUri}, e.g. <c>vscode.Uri.joinPath(context.extensionUri, relativePath);</c>
        /// </summary>
        /// <param name="relativePath">
        /// A relative path to a resource contained in the extension.
        /// </param>
        /// <returns>
        /// The absolute path of the resource.
        /// </returns>
        abstract member asAbsolutePath: relativePath: string -> string
        /// <summary>
        /// The uri of a workspace specific directory in which the extension
        /// can store private state. The directory might not exist and creation is
        /// up to the extension. However, the parent directory is guaranteed to be existent.
        /// The value is <c>undefined</c> when no workspace nor folder has been opened.
        ///
        /// Use {@linkcode ExtensionContext.workspaceStateworkspaceState} or
        /// {@linkcode ExtensionContext.globalStateglobalState} to store key value data.
        /// </summary>
        abstract member storageUri: Uri option with get
        /// <summary>
        /// An absolute file path of a workspace specific directory in which the extension
        /// can store private state. The directory might not exist on disk and creation is
        /// up to the extension. However, the parent directory is guaranteed to be existent.
        ///
        /// Use {@linkcode ExtensionContext.workspaceStateworkspaceState} or
        /// {@linkcode ExtensionContext.globalStateglobalState} to store key value data.
        /// </summary>
        [<Obsolete("Use {@link ExtensionContext.storageUri storageUri} instead.")>]
        abstract member storagePath: string option with get
        /// <summary>
        /// The uri of a directory in which the extension can store global state.
        /// The directory might not exist on disk and creation is
        /// up to the extension. However, the parent directory is guaranteed to be existent.
        ///
        /// Use {@linkcode ExtensionContext.globalStateglobalState} to store key value data.
        /// </summary>
        abstract member globalStorageUri: Uri with get
        /// <summary>
        /// An absolute file path in which the extension can store global state.
        /// The directory might not exist on disk and creation is
        /// up to the extension. However, the parent directory is guaranteed to be existent.
        ///
        /// Use {@linkcode ExtensionContext.globalStateglobalState} to store key value data.
        /// </summary>
        [<Obsolete("Use {@link ExtensionContext.globalStorageUri globalStorageUri} instead.")>]
        abstract member globalStoragePath: string with get
        /// <summary>
        /// The uri of a directory in which the extension can create log files.
        /// The directory might not exist on disk and creation is up to the extension. However,
        /// the parent directory is guaranteed to be existent.
        /// </summary>
        abstract member logUri: Uri with get
        /// <summary>
        /// An absolute file path of a directory in which the extension can create log files.
        /// The directory might not exist on disk and creation is up to the extension. However,
        /// the parent directory is guaranteed to be existent.
        /// </summary>
        [<Obsolete("Use {@link ExtensionContext.logUri logUri} instead.")>]
        abstract member logPath: string with get
        /// <summary>
        /// The mode the extension is running in. See <see href="ExtensionMode">ExtensionMode</see>
        /// for possible values and scenarios.
        /// </summary>
        abstract member extensionMode: ExtensionMode with get
        /// <summary>
        /// The current <c>Extension</c> instance.
        /// </summary>
        abstract member extension: Extension<obj> with get
        /// <summary>
        /// An object that keeps information about how this extension can use language models.
        /// </summary>
        abstract member languageModelAccessInformation: LanguageModelAccessInformation with get

    [<AllowNullLiteral>]
    [<Interface>]
    type Memento =
        /// <summary>
        /// Returns the stored keys.
        /// </summary>
        /// <returns>
        /// The stored keys.
        /// </returns>
        abstract member keys: unit -> ReadonlyArray<string>
        /// <summary>
        /// Return a value.
        /// </summary>
        /// <param name="key">
        /// A string.
        /// </param>
        /// <returns>
        /// The stored value or <c>undefined</c>.
        /// </returns>
        abstract member get: key: string -> 'T option
        /// <summary>
        /// Return a value.
        /// </summary>
        /// <param name="key">
        /// A string.
        /// </param>
        /// <param name="defaultValue">
        /// A value that should be returned when there is no
        /// value (<c>undefined</c>) with the given key.
        /// </param>
        /// <returns>
        /// The stored value or the defaultValue.
        /// </returns>
        abstract member get: key: string * defaultValue: 'T -> 'T
        /// <summary>
        /// Store a value. The value must be JSON-stringifyable.
        ///
        /// *Note* that using <c>undefined</c> as value removes the key from the underlying
        /// storage.
        /// </summary>
        /// <param name="key">
        /// A string.
        /// </param>
        /// <param name="value">
        /// A value. MUST not contain cyclic references.
        /// </param>
        abstract member update: key: string * value: obj -> Thenable<unit>

    [<AllowNullLiteral>]
    [<Interface>]
    type SecretStorageChangeEvent =
        /// <summary>
        /// The key of the secret that has changed.
        /// </summary>
        abstract member key: string with get

    [<AllowNullLiteral>]
    [<Interface>]
    type SecretStorage =
        /// <summary>
        /// Retrieve the keys of all the secrets stored by this extension.
        /// </summary>
        abstract member keys: unit -> Thenable<ResizeArray<string>>
        /// <summary>
        /// Retrieve a secret that was stored with key. Returns undefined if there
        /// is no password matching that key.
        /// </summary>
        /// <param name="key">
        /// The key the secret was stored under.
        /// </param>
        /// <returns>
        /// The stored value or <c>undefined</c>.
        /// </returns>
        abstract member get: key: string -> Thenable<string option>
        /// <summary>
        /// Store a secret under a given key.
        /// </summary>
        /// <param name="key">
        /// The key to store the secret under.
        /// </param>
        /// <param name="value">
        /// The secret.
        /// </param>
        abstract member store: key: string * value: string -> Thenable<unit>
        /// <summary>
        /// Remove a secret from storage.
        /// </summary>
        /// <param name="key">
        /// The key the secret was stored under.
        /// </param>
        abstract member delete: key: string -> Thenable<unit>
        /// <summary>
        /// Fires when a secret is stored or deleted.
        /// </summary>
        abstract member onDidChange: Event<SecretStorageChangeEvent> with get

    [<RequireQualifiedAccess>]
    type ColorThemeKind =
        | Light = 1
        | Dark = 2
        | HighContrast = 3
        | HighContrastLight = 4

    [<AllowNullLiteral>]
    [<Interface>]
    type ColorTheme =
        /// <summary>
        /// The kind of this color theme: light, dark, high contrast dark and high contrast light.
        /// </summary>
        abstract member kind: ColorThemeKind with get

    [<RequireQualifiedAccess>]
    type TaskRevealKind =
        | Always = 1
        | Silent = 2
        | Never = 3

    [<RequireQualifiedAccess>]
    type TaskPanelKind =
        | Shared = 1
        | Dedicated = 2
        | New = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskPresentationOptions =
        /// <summary>
        /// Controls whether the task output is reveal in the user interface.
        /// Defaults to <c>RevealKind.Always</c>.
        /// </summary>
        abstract member reveal: TaskRevealKind option with get, set
        /// <summary>
        /// Controls whether the command associated with the task is echoed
        /// in the user interface.
        /// </summary>
        abstract member echo: bool option with get, set
        /// <summary>
        /// Controls whether the panel showing the task output is taking focus.
        /// </summary>
        abstract member focus: bool option with get, set
        /// <summary>
        /// Controls if the task panel is used for this task only (dedicated),
        /// shared between tasks (shared) or if a new panel is created on
        /// every task execution (new). Defaults to <c>TaskInstanceKind.Shared</c>
        /// </summary>
        abstract member panel: TaskPanelKind option with get, set
        /// <summary>
        /// Controls whether to show the "Terminal will be reused by tasks, press any key to close it" message.
        /// </summary>
        abstract member showReuseMessage: bool option with get, set
        /// <summary>
        /// Controls whether the terminal is cleared before executing the task.
        /// </summary>
        abstract member clear: bool option with get, set
        /// <summary>
        /// Controls whether the terminal is closed after executing the task.
        /// </summary>
        abstract member close: bool option with get, set

    /// <summary>
    /// A grouping for tasks. The editor by default supports the
    /// 'Clean', 'Build', 'RebuildAll' and 'Test' group.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TaskGroup =
        /// <summary>
        /// The clean task group;
        /// </summary>
        static member inline Clean
            with get () : TaskGroup =
                emitJsExpr () $$"""
import { TaskGroup } from "vscode";
TaskGroup.Clean"""
            and set (value: TaskGroup) =
                emitJsExpr (value) $$"""
import { TaskGroup } from "vscode";
TaskGroup.Clean = $0"""
        /// <summary>
        /// The build task group;
        /// </summary>
        static member inline Build
            with get () : TaskGroup =
                emitJsExpr () $$"""
import { TaskGroup } from "vscode";
TaskGroup.Build"""
            and set (value: TaskGroup) =
                emitJsExpr (value) $$"""
import { TaskGroup } from "vscode";
TaskGroup.Build = $0"""
        /// <summary>
        /// The rebuild all task group;
        /// </summary>
        static member inline Rebuild
            with get () : TaskGroup =
                emitJsExpr () $$"""
import { TaskGroup } from "vscode";
TaskGroup.Rebuild"""
            and set (value: TaskGroup) =
                emitJsExpr (value) $$"""
import { TaskGroup } from "vscode";
TaskGroup.Rebuild = $0"""
        /// <summary>
        /// The test all task group;
        /// </summary>
        static member inline Test
            with get () : TaskGroup =
                emitJsExpr () $$"""
import { TaskGroup } from "vscode";
TaskGroup.Test"""
            and set (value: TaskGroup) =
                emitJsExpr (value) $$"""
import { TaskGroup } from "vscode";
TaskGroup.Test = $0"""
        /// <summary>
        /// Whether the task that is part of this group is the default for the group.
        /// This property cannot be set through API, and is controlled by a user's task configurations.
        /// </summary>
        abstract member isDefault: bool option with get
        /// <summary>
        /// The ID of the task group. Is one of TaskGroup.Clean.id, TaskGroup.Build.id, TaskGroup.Rebuild.id, or TaskGroup.Test.id.
        /// </summary>
        abstract member id: string with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskDefinition =
        /// <summary>
        /// The task definition describing the task provided by an extension.
        /// Usually a task provider defines more properties to identify
        /// a task. They need to be defined in the package.json of the
        /// extension under the 'taskDefinitions' extension point. The npm
        /// task definition for example looks like this
        /// <code lang="typescript">
        /// interface NpmTaskDefinition extends TaskDefinition {
        ///     script: string;
        /// }
        /// </code>
        ///
        /// Note that type identifier starting with a '$' are reserved for internal
        /// usages and shouldn't be used by extensions.
        /// </summary>
        abstract member ``type``: string with get
        [<EmitIndexer>]
        abstract member Item: name: string -> obj with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ProcessExecutionOptions =
        /// <summary>
        /// The current working directory of the executed program or shell.
        /// If omitted the tools current workspace root is used.
        /// </summary>
        abstract member cwd: string option with get, set
        /// <summary>
        /// The additional environment of the executed program or shell. If omitted
        /// the parent process' environment is used. If provided it is merged with
        /// the parent process' environment.
        /// </summary>
        abstract member env: ProcessExecutionOptions.env option with get, set

    /// <summary>
    /// The execution of a task happens as an external process
    /// without shell interaction.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ProcessExecution =
        /// <summary>
        /// The process to be executed.
        /// </summary>
        abstract member ``process``: string with get, set
        /// <summary>
        /// The arguments passed to the process. Defaults to an empty array.
        /// </summary>
        abstract member args: ResizeArray<string> with get, set
        /// <summary>
        /// The process options used when the process is executed.
        /// Defaults to undefined.
        /// </summary>
        abstract member options: ProcessExecutionOptions option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ShellQuotingOptions =
        /// <summary>
        /// The character used to do character escaping. If a string is provided only spaces
        /// are escaped. If a <c>{ escapeChar, charsToEscape }</c> literal is provide all characters
        /// in <c>charsToEscape</c> are escaped using the <c>escapeChar</c>.
        /// </summary>
        abstract member escape: U2<string, ShellQuotingOptions.escape.U2.Case2> option with get, set
        /// <summary>
        /// The character used for strong quoting. The string's length must be 1.
        /// </summary>
        abstract member strong: string option with get, set
        /// <summary>
        /// The character used for weak quoting. The string's length must be 1.
        /// </summary>
        abstract member weak: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ShellExecutionOptions =
        /// <summary>
        /// The shell executable.
        /// </summary>
        abstract member executable: string option with get, set
        /// <summary>
        /// The arguments to be passed to the shell executable used to run the task. Most shells
        /// require special arguments to execute a command. For  example <c>bash</c> requires the <c>-c</c>
        /// argument to execute a command, <c>PowerShell</c> requires <c>-Command</c> and <c>cmd</c> requires both
        /// <c>/d</c> and <c>/c</c>.
        /// </summary>
        abstract member shellArgs: ResizeArray<string> option with get, set
        /// <summary>
        /// The shell quotes supported by this shell.
        /// </summary>
        abstract member shellQuoting: ShellQuotingOptions option with get, set
        /// <summary>
        /// The current working directory of the executed shell.
        /// If omitted the tools current workspace root is used.
        /// </summary>
        abstract member cwd: string option with get, set
        /// <summary>
        /// The additional environment of the executed shell. If omitted
        /// the parent process' environment is used. If provided it is merged with
        /// the parent process' environment.
        /// </summary>
        abstract member env: ShellExecutionOptions.env option with get, set

    [<RequireQualifiedAccess>]
    type ShellQuoting =
        | Escape = 1
        | Strong = 2
        | Weak = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type ShellQuotedString =
        /// <summary>
        /// The actual string value.
        /// </summary>
        abstract member value: string with get, set
        /// <summary>
        /// The quoting style to use.
        /// </summary>
        abstract member quoting: ShellQuoting with get, set

    /// <summary>
    /// Represents a task execution that happens inside a shell.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ShellExecution =
        /// <summary>
        /// The shell command line. Is <c>undefined</c> if created with a command and arguments.
        /// </summary>
        abstract member commandLine: string option with get, set
        /// <summary>
        /// The shell command. Is <c>undefined</c> if created with a full command line.
        /// </summary>
        abstract member command: U2<string, ShellQuotedString> option with get, set
        /// <summary>
        /// The shell args. Is <c>undefined</c> if created with a full command line.
        /// </summary>
        abstract member args: ResizeArray<U2<string, ShellQuotedString>> option with get, set
        /// <summary>
        /// The shell options used when the command line is executed in a shell.
        /// Defaults to undefined.
        /// </summary>
        abstract member options: ShellExecutionOptions option with get, set

    /// <summary>
    /// Class used to execute an extension callback as a task.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type CustomExecution =
        interface end

    [<RequireQualifiedAccess>]
    type TaskScope =
        | Global = 1
        | Workspace = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type RunOptions =
        /// <summary>
        /// Controls whether task variables are re-evaluated on rerun.
        /// </summary>
        abstract member reevaluateOnRerun: bool option with get, set

    /// <summary>
    /// A task to execute
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Task =
        /// <summary>
        /// The task's definition.
        /// </summary>
        abstract member definition: TaskDefinition with get, set
        /// <summary>
        /// The task's scope.
        /// </summary>
        abstract member scope: U3<TaskScope, TaskScope, WorkspaceFolder> option with get
        /// <summary>
        /// The task's name
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// A human-readable string which is rendered less prominently on a separate line in places
        /// where the task's name is displayed. Supports rendering of <see href="ThemeIcontheme">icons</see>"
        /// via the <c>$(<name>)</c>-syntax.
        /// </summary>
        abstract member detail: string option with get, set
        /// <summary>
        /// The task's execution engine
        /// </summary>
        abstract member execution: U3<ProcessExecution, ShellExecution, CustomExecution> option with get, set
        /// <summary>
        /// Whether the task is a background task or not.
        /// </summary>
        abstract member isBackground: bool with get, set
        /// <summary>
        /// A human-readable string describing the source of this shell task, e.g. 'gulp'
        /// or 'npm'. Supports rendering of <see href="ThemeIcontheme">icons</see>" via the <c>$(<name>)</c>-syntax.
        /// </summary>
        abstract member source: string with get, set
        /// <summary>
        /// The task group this tasks belongs to. See TaskGroup
        /// for a predefined set of available groups.
        /// Defaults to undefined meaning that the task doesn't
        /// belong to any special group.
        /// </summary>
        abstract member group: TaskGroup option with get, set
        /// <summary>
        /// The presentation options. Defaults to an empty literal.
        /// </summary>
        abstract member presentationOptions: TaskPresentationOptions with get, set
        /// <summary>
        /// The problem matchers attached to the task. Defaults to an empty
        /// array.
        /// </summary>
        abstract member problemMatchers: ResizeArray<string> with get, set
        /// <summary>
        /// Run options for the task
        /// </summary>
        abstract member runOptions: RunOptions with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskProvider<'T when 'T :> Task> =
        /// <summary>
        /// Provides tasks.
        /// </summary>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// an array of tasks
        /// </returns>
        abstract member provideTasks: token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// Resolves a task that has no {@linkcode Task.executionexecution} set. Tasks are
        /// often created from information found in the <c>tasks.json</c>-file. Such tasks miss
        /// the information on how to execute them and a task provider must fill in
        /// the missing information in the <c>resolveTask</c>-method. This method will not be
        /// called for tasks returned from the above <c>provideTasks</c> method since those
        /// tasks are always fully resolved. A valid default implementation for the
        /// <c>resolveTask</c> method is to return <c>undefined</c>.
        ///
        /// Note that when filling in the properties of <c>task</c>, you _must_ be sure to
        /// use the exact same <c>TaskDefinition</c> and not create a new one. Other properties
        /// may be changed.
        /// </summary>
        /// <param name="task">
        /// The task to resolve.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved task
        /// </returns>
        abstract member resolveTask: task: 'T * token: CancellationToken -> ProviderResult<'T>

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskExecution =
        /// <summary>
        /// The task that got started.
        /// </summary>
        abstract member task: Task with get, set
        /// <summary>
        /// Terminates the task execution.
        /// </summary>
        abstract member terminate: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskStartEvent =
        /// <summary>
        /// The task item representing the task that got started.
        /// </summary>
        abstract member execution: TaskExecution with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskEndEvent =
        /// <summary>
        /// The task item representing the task that finished.
        /// </summary>
        abstract member execution: TaskExecution with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskProcessStartEvent =
        /// <summary>
        /// The task execution for which the process got started.
        /// </summary>
        abstract member execution: TaskExecution with get
        /// <summary>
        /// The underlying process id.
        /// </summary>
        abstract member processId: float with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskProcessEndEvent =
        /// <summary>
        /// The task execution for which the process got started.
        /// </summary>
        abstract member execution: TaskExecution with get
        /// <summary>
        /// The process's exit code. Will be <c>undefined</c> when the task is terminated.
        /// </summary>
        abstract member exitCode: float option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TaskFilter =
        /// <summary>
        /// The task version as used in the tasks.json file.
        /// The string support the package.json semver notation.
        /// </summary>
        abstract member version: string option with get, set
        /// <summary>
        /// The task type to return;
        /// </summary>
        abstract member ``type``: string option with get, set

    module tasks =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Register a task provider.
            /// </summary>
            /// <param name="type">
            /// The task kind type this provider is registered for.
            /// </param>
            /// <param name="provider">
            /// A task provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerTaskProvider($1...)")>]
            abstract member registerTaskProvider: ``type``: string * provider: TaskProvider -> Disposable
            /// <summary>
            /// Fetches all tasks available in the systems. This includes tasks
            /// from <c>tasks.json</c> files as well as tasks from task providers
            /// contributed through extensions.
            /// </summary>
            /// <param name="filter">
            /// Optional filter to select tasks of a certain type or version.
            /// </param>
            /// <returns>
            /// A thenable that resolves to an array of tasks.
            /// </returns>
            [<Emit("$0.fetchTasks($1...)")>]
            abstract member fetchTasks: ?filter: TaskFilter -> Thenable<ResizeArray<Task>>
            /// <summary>
            /// Executes a task that is managed by the editor. The returned
            /// task execution can be used to terminate the task.
            /// </summary>
            /// <remarks>
            /// Throws:
            /// -------
            ///
            /// When running a ShellExecution or a ProcessExecution
            /// task in an environment where a new process cannot be started.
            /// In such an environment, only CustomExecution tasks can be run.
            /// </remarks>
            /// <param name="task">
            /// the task to execute
            /// </param>
            /// <returns>
            /// A thenable that resolves to a task execution.
            /// </returns>
            [<Emit("$0.executeTask($1...)")>]
            abstract member executeTask: task: Task -> Thenable<TaskExecution>
            /// <summary>
            /// The currently active task executions or an empty array.
            /// </summary>
            [<Emit("$0.taskExecutions")>]
            abstract member taskExecutions: ReadonlyArray<TaskExecution>
            /// <summary>
            /// Fires when a task starts.
            /// </summary>
            [<Emit("$0.onDidStartTask")>]
            abstract member onDidStartTask: Event<TaskStartEvent>
            /// <summary>
            /// Fires when a task ends.
            /// </summary>
            [<Emit("$0.onDidEndTask")>]
            abstract member onDidEndTask: Event<TaskEndEvent>
            /// <summary>
            /// Fires when the underlying process has been started.
            /// This event will not fire for tasks that don't
            /// execute an underlying process.
            /// </summary>
            [<Emit("$0.onDidStartTaskProcess")>]
            abstract member onDidStartTaskProcess: Event<TaskProcessStartEvent>
            /// <summary>
            /// Fires when the underlying process has ended.
            /// This event will not fire for tasks that don't
            /// execute an underlying process.
            /// </summary>
            [<Emit("$0.onDidEndTaskProcess")>]
            abstract member onDidEndTaskProcess: Event<TaskProcessEndEvent>

    [<RequireQualifiedAccess>]
    type FileType =
        | Unknown = 0
        | File = 1
        | Directory = 2
        | SymbolicLink = 64

    [<RequireQualifiedAccess>]
    type FilePermission =
        | Readonly = 1

    [<AllowNullLiteral>]
    [<Interface>]
    type FileStat =
        /// <summary>
        /// The type of the file, e.g. is a regular file, a directory, or symbolic link
        /// to a file.
        ///
        /// *Note:* This value might be a bitmask, e.g. <c>FileType.File | FileType.SymbolicLink</c>.
        /// </summary>
        abstract member ``type``: FileType with get, set
        /// <summary>
        /// The creation timestamp in milliseconds elapsed since January 1, 1970 00:00:00 UTC.
        /// </summary>
        abstract member ctime: float with get, set
        /// <summary>
        /// The modification timestamp in milliseconds elapsed since January 1, 1970 00:00:00 UTC.
        ///
        /// *Note:* If the file changed, it is important to provide an updated <c>mtime</c> that advanced
        /// from the previous value. Otherwise there may be optimizations in place that will not show
        /// the updated file contents in an editor for example.
        /// </summary>
        abstract member mtime: float with get, set
        /// <summary>
        /// The size in bytes.
        ///
        /// *Note:* If the file changed, it is important to provide an updated <c>size</c>. Otherwise there
        /// may be optimizations in place that will not show the updated file contents in an editor for
        /// example.
        /// </summary>
        abstract member size: float with get, set
        /// <summary>
        /// The permissions of the file, e.g. whether the file is readonly.
        ///
        /// *Note:* This value might be a bitmask, e.g. <c>FilePermission.Readonly | FilePermission.Other</c>.
        /// </summary>
        abstract member permissions: FilePermission option with get, set

    /// <summary>
    /// A type that filesystem providers should use to signal errors.
    ///
    /// This class has factory methods for common error-cases, like <c>FileNotFound</c> when
    /// a file or folder doesn't exist, use them like so: <c>throw vscode.FileSystemError.FileNotFound(someUri);</c>
    /// </summary>
    [<AllowNullLiteral>]
    [<AbstractClass>]
    type FileSystemError =
        inherit Exception
        /// <summary>
        /// Create an error to signal that a file or folder wasn't found.
        /// </summary>
        /// <param name="messageOrUri">
        /// Message or uri.
        /// </param>
        static member inline FileNotFound (?messageOrUri: U2<string, Uri>): FileSystemError =
            emitJsExpr (messageOrUri) $$"""
import { FileSystemError } from "vscode";
FileSystemError.FileNotFound($0)"""
        /// <summary>
        /// Create an error to signal that a file or folder already exists, e.g. when
        /// creating but not overwriting a file.
        /// </summary>
        /// <param name="messageOrUri">
        /// Message or uri.
        /// </param>
        static member inline FileExists (?messageOrUri: U2<string, Uri>): FileSystemError =
            emitJsExpr (messageOrUri) $$"""
import { FileSystemError } from "vscode";
FileSystemError.FileExists($0)"""
        /// <summary>
        /// Create an error to signal that a file is not a folder.
        /// </summary>
        /// <param name="messageOrUri">
        /// Message or uri.
        /// </param>
        static member inline FileNotADirectory (?messageOrUri: U2<string, Uri>): FileSystemError =
            emitJsExpr (messageOrUri) $$"""
import { FileSystemError } from "vscode";
FileSystemError.FileNotADirectory($0)"""
        /// <summary>
        /// Create an error to signal that a file is a folder.
        /// </summary>
        /// <param name="messageOrUri">
        /// Message or uri.
        /// </param>
        static member inline FileIsADirectory (?messageOrUri: U2<string, Uri>): FileSystemError =
            emitJsExpr (messageOrUri) $$"""
import { FileSystemError } from "vscode";
FileSystemError.FileIsADirectory($0)"""
        /// <summary>
        /// Create an error to signal that an operation lacks required permissions.
        /// </summary>
        /// <param name="messageOrUri">
        /// Message or uri.
        /// </param>
        static member inline NoPermissions (?messageOrUri: U2<string, Uri>): FileSystemError =
            emitJsExpr (messageOrUri) $$"""
import { FileSystemError } from "vscode";
FileSystemError.NoPermissions($0)"""
        /// <summary>
        /// Create an error to signal that the file system is unavailable or too busy to
        /// complete a request.
        /// </summary>
        /// <param name="messageOrUri">
        /// Message or uri.
        /// </param>
        static member inline Unavailable (?messageOrUri: U2<string, Uri>): FileSystemError =
            emitJsExpr (messageOrUri) $$"""
import { FileSystemError } from "vscode";
FileSystemError.Unavailable($0)"""
        /// <summary>
        /// A code that identifies this error.
        ///
        /// Possible values are names of errors, like {@linkcode FileSystemError.FileNotFoundFileNotFound},
        /// or <c>Unknown</c> for unspecified errors.
        /// </summary>
        abstract member code: string with get

    [<RequireQualifiedAccess>]
    type FileChangeType =
        | Changed = 1
        | Created = 2
        | Deleted = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type FileChangeEvent =
        /// <summary>
        /// The type of change.
        /// </summary>
        abstract member ``type``: FileChangeType with get
        /// <summary>
        /// The uri of the file that has changed.
        /// </summary>
        abstract member uri: Uri with get

    [<AllowNullLiteral>]
    [<Interface>]
    type FileSystemProvider =
        /// <summary>
        /// An event to signal that a resource has been created, changed, or deleted. This
        /// event should fire for resources that are being <see href="FileSystemProvider.watchwatched">FileSystemProvider.watchwatched</see>
        /// by clients of this provider.
        ///
        /// *Note:* It is important that the metadata of the file that changed provides an
        /// updated <c>mtime</c> that advanced from the previous value in the <see href="FileStatstat">FileStatstat</see> and a
        /// correct <c>size</c> value. Otherwise there may be optimizations in place that will not show
        /// the change in an editor for example.
        /// </summary>
        abstract member onDidChangeFile: Event<ResizeArray<FileChangeEvent>> with get
        /// <summary>
        /// Subscribes to file change events in the file or folder denoted by <c>uri</c>. For folders,
        /// the option <c>recursive</c> indicates whether subfolders, sub-subfolders, etc. should
        /// be watched for file changes as well. With <c>recursive: false</c>, only changes to the
        /// files that are direct children of the folder should trigger an event.
        ///
        /// The <c>excludes</c> array is used to indicate paths that should be excluded from file
        /// watching. It is typically derived from the <c>files.watcherExclude</c> setting that
        /// is configurable by the user. Each entry can be be:
        /// - the absolute path to exclude
        /// - a relative path to exclude (for example <c>build/output</c>)
        /// - a simple glob pattern (for example <c>**​/build</c>, <c>output/**</c>)
        ///
        /// *Note* that case-sensitivity of the <see href="excludes">excludes</see> patterns for built-in file system providers
        /// will depend on the underlying file system: on Windows and macOS the matching will be case-insensitive and
        /// on Linux it will be case-sensitive.
        ///
        /// It is the file system provider's job to call {@linkcode FileSystemProvider.onDidChangeFileonDidChangeFile}
        /// for every change given these rules. No event should be emitted for files that match any of the provided
        /// excludes.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file or folder to be watched.
        /// </param>
        /// <param name="options">
        /// Configures the watch.
        /// </param>
        /// <returns>
        /// A disposable that tells the provider to stop watching the <c>uri</c>.
        /// </returns>
        abstract member watch: uri: Uri * options: FileSystemProvider.watch.options -> Disposable
        /// <summary>
        /// Retrieve metadata about a file.
        ///
        /// Note that the metadata for symbolic links should be the metadata of the file they refer to.
        /// Still, the <see href="FileType.SymbolicLinkSymbolicLink">FileType.SymbolicLinkSymbolicLink</see>-type must be used in addition to the actual type, e.g.
        /// <c>FileType.SymbolicLink | FileType.Directory</c>.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file to retrieve metadata about.
        /// </param>
        /// <returns>
        /// The file metadata about the file.
        /// </returns>
        abstract member stat: uri: Uri -> U2<FileStat, Thenable<FileStat>>
        /// <summary>
        /// Retrieve all entries of a <see href="FileType.Directorydirectory">FileType.Directorydirectory</see>.
        /// </summary>
        /// <param name="uri">
        /// The uri of the folder.
        /// </param>
        /// <returns>
        /// An array of name/type-tuples or a thenable that resolves to such.
        /// </returns>
        abstract member readDirectory: uri: Uri -> U2<ResizeArray<string * FileType>, Thenable<ResizeArray<string * FileType>>>
        /// <summary>
        /// Create a new directory (Note, that new files are created via <c>write</c>-calls).
        /// </summary>
        /// <param name="uri">
        /// The uri of the new folder.
        /// </param>
        abstract member createDirectory: uri: Uri -> U2<unit, Thenable<unit>>
        /// <summary>
        /// Read the entire contents of a file.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file.
        /// </param>
        /// <returns>
        /// An array of bytes or a thenable that resolves to such.
        /// </returns>
        abstract member readFile: uri: Uri -> U2<JS.Uint8Array, Thenable<JS.Uint8Array>>
        /// <summary>
        /// Write data to a file, replacing its entire contents.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file.
        /// </param>
        /// <param name="content">
        /// The new content of the file.
        /// </param>
        /// <param name="options">
        /// Defines if missing files should or must be created.
        /// </param>
        abstract member writeFile: uri: Uri * content: JS.Uint8Array * options: FileSystemProvider.writeFile.options -> U2<unit, Thenable<unit>>
        /// <summary>
        /// Delete a file.
        /// </summary>
        /// <param name="uri">
        /// The resource that is to be deleted.
        /// </param>
        /// <param name="options">
        /// Defines if deletion of folders is recursive.
        /// </param>
        abstract member delete: uri: Uri * options: FileSystemProvider.delete.options -> U2<unit, Thenable<unit>>
        /// <summary>
        /// Rename a file or folder.
        /// </summary>
        /// <param name="oldUri">
        /// The existing file.
        /// </param>
        /// <param name="newUri">
        /// The new location.
        /// </param>
        /// <param name="options">
        /// Defines if existing files should be overwritten.
        /// </param>
        abstract member rename: oldUri: Uri * newUri: Uri * options: FileSystemProvider.rename.options -> U2<unit, Thenable<unit>>
        /// <summary>
        /// Copy files or folders. Implementing this function is optional but it will speedup
        /// the copy operation.
        /// </summary>
        /// <param name="source">
        /// The existing file.
        /// </param>
        /// <param name="destination">
        /// The destination location.
        /// </param>
        /// <param name="options">
        /// Defines if existing files should be overwritten.
        /// </param>
        abstract member copy: source: Uri * destination: Uri * options: FileSystemProvider.copy.options -> U2<unit, Thenable<unit>>

    [<AllowNullLiteral>]
    [<Interface>]
    type FileSystem =
        /// <summary>
        /// Retrieve metadata about a file.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file to retrieve metadata about.
        /// </param>
        /// <returns>
        /// The file metadata about the file.
        /// </returns>
        abstract member stat: uri: Uri -> Thenable<FileStat>
        /// <summary>
        /// Retrieve all entries of a <see href="FileType.Directorydirectory">FileType.Directorydirectory</see>.
        /// </summary>
        /// <param name="uri">
        /// The uri of the folder.
        /// </param>
        /// <returns>
        /// An array of name/type-tuples or a thenable that resolves to such.
        /// </returns>
        abstract member readDirectory: uri: Uri -> Thenable<ResizeArray<string * FileType>>
        /// <summary>
        /// Create a new directory (Note, that new files are created via <c>write</c>-calls).
        ///
        /// *Note* that missing directories are created automatically, e.g this call has
        /// <c>mkdirp</c> semantics.
        /// </summary>
        /// <param name="uri">
        /// The uri of the new folder.
        /// </param>
        abstract member createDirectory: uri: Uri -> Thenable<unit>
        /// <summary>
        /// Read the entire contents of a file.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file.
        /// </param>
        /// <returns>
        /// An array of bytes or a thenable that resolves to such.
        /// </returns>
        abstract member readFile: uri: Uri -> Thenable<JS.Uint8Array>
        /// <summary>
        /// Write data to a file, replacing its entire contents.
        /// </summary>
        /// <param name="uri">
        /// The uri of the file.
        /// </param>
        /// <param name="content">
        /// The new content of the file.
        /// </param>
        abstract member writeFile: uri: Uri * content: JS.Uint8Array -> Thenable<unit>
        /// <summary>
        /// Delete a file.
        /// </summary>
        /// <param name="uri">
        /// The resource that is to be deleted.
        /// </param>
        /// <param name="options">
        /// Defines if trash can should be used and if deletion of folders is recursive
        /// </param>
        abstract member delete: uri: Uri * ?options: FileSystem.delete.options -> Thenable<unit>
        /// <summary>
        /// Rename a file or folder.
        /// </summary>
        /// <param name="source">
        /// The existing file.
        /// </param>
        /// <param name="target">
        /// The new location.
        /// </param>
        /// <param name="options">
        /// Defines if existing files should be overwritten.
        /// </param>
        abstract member rename: source: Uri * target: Uri * ?options: FileSystem.rename.options -> Thenable<unit>
        /// <summary>
        /// Copy files or folders.
        /// </summary>
        /// <param name="source">
        /// The existing file.
        /// </param>
        /// <param name="target">
        /// The destination location.
        /// </param>
        /// <param name="options">
        /// Defines if existing files should be overwritten.
        /// </param>
        abstract member copy: source: Uri * target: Uri * ?options: FileSystem.copy.options -> Thenable<unit>
        /// <summary>
        /// Check if a given file system supports writing files.
        ///
        /// Keep in mind that just because a file system supports writing, that does
        /// not mean that writes will always succeed. There may be permissions issues
        /// or other errors that prevent writing a file.
        /// </summary>
        /// <param name="scheme">
        /// The scheme of the filesystem, for example <c>file</c> or <c>git</c>.
        /// </param>
        /// <returns>
        /// <c>true</c> if the file system supports writing, <c>false</c> if it does not
        /// support writing (i.e. it is readonly), and <c>undefined</c> if the editor does not
        /// know about the filesystem.
        /// </returns>
        abstract member isWritableFileSystem: scheme: string -> bool option

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewPortMapping =
        /// <summary>
        /// Localhost port to remap inside the webview.
        /// </summary>
        abstract member webviewPort: float with get
        /// <summary>
        /// Destination port. The <c>webviewPort</c> is resolved to this port.
        /// </summary>
        abstract member extensionHostPort: float with get

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewOptions =
        /// <summary>
        /// Controls whether scripts are enabled in the webview content or not.
        ///
        /// Defaults to false (scripts-disabled).
        /// </summary>
        abstract member enableScripts: bool option with get
        /// <summary>
        /// Controls whether forms are enabled in the webview content or not.
        ///
        /// Defaults to true if <see href="WebviewOptions.enableScriptsscripts">are enabled</see>". Otherwise defaults to false.
        /// Explicitly setting this property to either true or false overrides the default.
        /// </summary>
        abstract member enableForms: bool option with get
        /// <summary>
        /// Controls whether command uris are enabled in webview content or not.
        ///
        /// Defaults to <c>false</c> (command uris are disabled).
        ///
        /// If you pass in an array, only the commands in the array are allowed.
        /// </summary>
        abstract member enableCommandUris: U2<bool, ReadonlyArray<string>> option with get
        /// <summary>
        /// Root paths from which the webview can load local (filesystem) resources using uris from <c>asWebviewUri</c>
        ///
        /// Default to the root folders of the current workspace plus the extension's install directory.
        ///
        /// Pass in an empty array to disallow access to any local resources.
        /// </summary>
        abstract member localResourceRoots: ReadonlyArray<Uri> option with get
        /// <summary>
        /// Mappings of localhost ports used inside the webview.
        ///
        /// Port mapping allow webviews to transparently define how localhost ports are resolved. This can be used
        /// to allow using a static localhost port inside the webview that is resolved to random port that a service is
        /// running on.
        ///
        /// If a webview accesses localhost content, we recommend that you specify port mappings even if
        /// the <c>webviewPort</c> and <c>extensionHostPort</c> ports are the same.
        ///
        /// *Note* that port mappings only work for <c>http</c> or <c>https</c> urls. Websocket urls (e.g. <c>ws://localhost:3000</c>)
        /// cannot be mapped to another port.
        /// </summary>
        abstract member portMapping: ReadonlyArray<WebviewPortMapping> option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type Webview =
        /// <summary>
        /// Content settings for the webview.
        /// </summary>
        abstract member options: WebviewOptions with get, set
        /// <summary>
        /// HTML contents of the webview.
        ///
        /// This should be a complete, valid html document. Changing this property causes the webview to be reloaded.
        ///
        /// Webviews are sandboxed from normal extension process, so all communication with the webview must use
        /// message passing. To send a message from the extension to the webview, use {@linkcode Webview.postMessagepostMessage}.
        /// To send message from the webview back to an extension, use the <c>acquireVsCodeApi</c> function inside the webview
        /// to get a handle to the editor's api and then call <c>.postMessage()</c>:
        ///
        /// <code lang="html">
        /// <script>
        ///     const vscode = acquireVsCodeApi(); // acquireVsCodeApi can only be invoked once
        ///     vscode.postMessage({ message: 'hello!' });
        /// </script>
        /// </code>
        ///
        /// To load a resources from the workspace inside a webview, use the {@linkcode Webview.asWebviewUriasWebviewUri} method
        /// and ensure the resource's directory is listed in {@linkcode WebviewOptions.localResourceRoots}.
        ///
        /// Keep in mind that even though webviews are sandboxed, they still allow running scripts and loading arbitrary content,
        /// so extensions must follow all standard web security best practices when working with webviews. This includes
        /// properly sanitizing all untrusted input (including content from the workspace) and
        /// setting a [content security policy](https://aka.ms/vscode-api-webview-csp).
        /// </summary>
        abstract member html: string with get, set
        /// <summary>
        /// Fired when the webview content posts a message.
        ///
        /// Webview content can post strings or json serializable objects back to an extension. They cannot
        /// post <c>Blob</c>, <c>File</c>, <c>ImageData</c> and other DOM specific objects since the extension that receives the
        /// message does not run in a browser environment.
        /// </summary>
        abstract member onDidReceiveMessage: Event<obj> with get
        /// <summary>
        /// Post a message to the webview content.
        ///
        /// Messages are only delivered if the webview is live (either visible or in the
        /// background with <c>retainContextWhenHidden</c>).
        /// </summary>
        /// <param name="message">
        /// Body of the message. This must be a string or other json serializable object.
        ///
        /// For older versions of vscode, if an <c>ArrayBuffer</c> is included in <c>message</c>,
        /// it will not be serialized properly and will not be received by the webview.
        /// Similarly any TypedArrays, such as a <c>Uint8Array</c>, will be very inefficiently
        /// serialized and will also not be recreated as a typed array inside the webview.
        ///
        /// However if your extension targets vscode 1.57+ in the <c>engines</c> field of its
        /// <c>package.json</c>, any <c>ArrayBuffer</c> values that appear in <c>message</c> will be more
        /// efficiently transferred to the webview and will also be correctly recreated inside
        /// of the webview.
        /// </param>
        /// <returns>
        /// A promise that resolves when the message is posted to a webview or when it is
        /// dropped because the message was not deliverable.
        ///
        /// Returns <c>true</c> if the message was posted to the webview. Messages can only be posted to
        /// live webviews (i.e. either visible webviews or hidden webviews that set <c>retainContextWhenHidden</c>).
        ///
        /// A response of <c>true</c> does not mean that the message was actually received by the webview.
        /// For example, no message listeners may be have been hooked up inside the webview or the webview may
        /// have been destroyed after the message was posted but before it was received.
        ///
        /// If you want confirm that a message as actually received, you can try having your webview posting a
        /// confirmation message back to your extension.
        /// </returns>
        abstract member postMessage: message: obj -> Thenable<bool>
        /// <summary>
        /// Convert a uri for the local file system to one that can be used inside webviews.
        ///
        /// Webviews cannot directly load resources from the workspace or local file system using <c>file:</c> uris. The
        /// <c>asWebviewUri</c> function takes a local <c>file:</c> uri and converts it into a uri that can be used inside of
        /// a webview to load the same resource:
        ///
        /// <c></c><c>ts
        /// webview.html = </c><img src="${webview.asWebviewUri(vscode.Uri.file('/Users/codey/workspace/cat.gif'))}"><c>
        /// </c><c></c>
        /// </summary>
        abstract member asWebviewUri: localResource: Uri -> Uri
        /// <summary>
        /// Content security policy source for webview resources.
        ///
        /// This is the origin that should be used in a content security policy rule:
        ///
        /// <c></c><c>ts
        /// </c>img-src https: ${webview.cspSource} ...;<c>
        /// </c><c></c>
        /// </summary>
        abstract member cspSource: string with get

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewPanelOptions =
        /// <summary>
        /// Controls if the find widget is enabled in the panel.
        ///
        /// Defaults to <c>false</c>.
        /// </summary>
        abstract member enableFindWidget: bool option with get
        /// <summary>
        /// Controls if the webview panel's content (iframe) is kept around even when the panel
        /// is no longer visible.
        ///
        /// Normally the webview panel's html context is created when the panel becomes visible
        /// and destroyed when it is hidden. Extensions that have complex state
        /// or UI can set the <c>retainContextWhenHidden</c> to make the editor keep the webview
        /// context around, even when the webview moves to a background tab. When a webview using
        /// <c>retainContextWhenHidden</c> becomes hidden, its scripts and other dynamic content are suspended.
        /// When the panel becomes visible again, the context is automatically restored
        /// in the exact same state it was in originally. You cannot send messages to a
        /// hidden webview, even with <c>retainContextWhenHidden</c> enabled.
        ///
        /// <c>retainContextWhenHidden</c> has a high memory overhead and should only be used if
        /// your panel's context cannot be quickly saved and restored.
        /// </summary>
        abstract member retainContextWhenHidden: bool option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewPanel =
        /// <summary>
        /// Identifies the type of the webview panel, such as <c>'markdown.preview'</c>.
        /// </summary>
        abstract member viewType: string with get
        /// <summary>
        /// Title of the panel shown in UI.
        /// </summary>
        abstract member title: string with get, set
        /// <summary>
        /// Icon for the panel shown in UI.
        /// </summary>
        abstract member iconPath: IconPath option with get, set
        /// <summary>
        /// {@linkcode Webview} belonging to the panel.
        /// </summary>
        abstract member webview: Webview with get
        /// <summary>
        /// Content settings for the webview panel.
        /// </summary>
        abstract member options: WebviewPanelOptions with get
        /// <summary>
        /// Editor position of the panel. This property is only set if the webview is in
        /// one of the editor view columns.
        /// </summary>
        abstract member viewColumn: ViewColumn option with get
        /// <summary>
        /// Whether the panel is active (focused by the user).
        /// </summary>
        abstract member active: bool with get
        /// <summary>
        /// Whether the panel is visible.
        /// </summary>
        abstract member visible: bool with get
        /// <summary>
        /// Fired when the panel's view state changes.
        /// </summary>
        abstract member onDidChangeViewState: Event<WebviewPanelOnDidChangeViewStateEvent> with get
        /// <summary>
        /// Fired when the panel is disposed.
        ///
        /// This may be because the user closed the panel or because {@linkcode WebviewPanel.disposedispose} was
        /// called on it.
        ///
        /// Trying to use the panel after it has been disposed throws an exception.
        /// </summary>
        abstract member onDidDispose: Event<unit> with get
        /// <summary>
        /// Show the webview panel in a given column.
        ///
        /// A webview panel may only show in a single column at a time. If it is already showing, this
        /// method moves it to a new column.
        /// </summary>
        /// <param name="viewColumn">
        /// View column to show the panel in. Shows in the current {@linkcode WebviewPanel.viewColumn } if undefined.
        /// </param>
        /// <param name="preserveFocus">
        /// When <c>true</c>, the webview will not take focus.
        /// </param>
        abstract member reveal: ?viewColumn: ViewColumn * ?preserveFocus: bool -> unit
        /// <summary>
        /// Dispose of the webview panel.
        ///
        /// This closes the panel if it showing and disposes of the resources owned by the webview.
        /// Webview panels are also disposed when the user closes the webview panel. Both cases
        /// fire the {@linkcode onDidDispose} event.
        /// </summary>
        abstract member dispose: unit -> obj

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewPanelOnDidChangeViewStateEvent =
        /// <summary>
        /// {@linkcode WebviewPanel} whose view state changed.
        /// </summary>
        abstract member webviewPanel: WebviewPanel with get

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewPanelSerializer<'T> =
        /// <summary>
        /// Restore a webview panel from its serialized <c>state</c>.
        ///
        /// Called when a serialized webview first becomes visible.
        /// </summary>
        /// <param name="webviewPanel">
        /// Webview panel to restore. The serializer should take ownership of this panel. The
        /// serializer must restore the webview's <c>.html</c> and hook up all webview events.
        /// </param>
        /// <param name="state">
        /// Persisted state from the webview content.
        /// </param>
        /// <returns>
        /// Thenable indicating that the webview has been fully restored.
        /// </returns>
        abstract member deserializeWebviewPanel: webviewPanel: WebviewPanel * state: 'T -> Thenable<unit>

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewView =
        /// <summary>
        /// Identifies the type of the webview view, such as <c>'hexEditor.dataView'</c>.
        /// </summary>
        abstract member viewType: string with get
        /// <summary>
        /// The underlying webview for the view.
        /// </summary>
        abstract member webview: Webview with get
        /// <summary>
        /// View title displayed in the UI.
        ///
        /// The view title is initially taken from the extension <c>package.json</c> contribution.
        /// </summary>
        abstract member title: string option with get, set
        /// <summary>
        /// Human-readable string which is rendered less prominently in the title.
        /// </summary>
        abstract member description: string option with get, set
        /// <summary>
        /// The badge to display for this webview view.
        /// To remove the badge, set to undefined.
        /// </summary>
        abstract member badge: ViewBadge option with get, set
        /// <summary>
        /// Event fired when the view is disposed.
        ///
        /// Views are disposed when they are explicitly hidden by a user (this happens when a user
        /// right clicks in a view and unchecks the webview view).
        ///
        /// Trying to use the view after it has been disposed throws an exception.
        /// </summary>
        abstract member onDidDispose: Event<unit> with get
        /// <summary>
        /// Tracks if the webview is currently visible.
        ///
        /// Views are visible when they are on the screen and expanded.
        /// </summary>
        abstract member visible: bool with get
        /// <summary>
        /// Event fired when the visibility of the view changes.
        ///
        /// Actions that trigger a visibility change:
        ///
        /// - The view is collapsed or expanded.
        /// - The user switches to a different view group in the sidebar or panel.
        ///
        /// Note that hiding a view using the context menu instead disposes of the view and fires <c>onDidDispose</c>.
        /// </summary>
        abstract member onDidChangeVisibility: Event<unit> with get
        /// <summary>
        /// Reveal the view in the UI.
        ///
        /// If the view is collapsed, this will expand it.
        /// </summary>
        /// <param name="preserveFocus">
        /// When <c>true</c> the view will not take focus.
        /// </param>
        abstract member show: ?preserveFocus: bool -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewViewResolveContext<'T> =
        /// <summary>
        /// Persisted state from the webview content.
        ///
        /// To save resources, the editor normally deallocates webview documents (the iframe content) that are not visible.
        /// For example, when the user collapse a view or switches to another top level activity in the sidebar, the
        /// {@linkcode WebviewView} itself is kept alive but the webview's underlying document is deallocated. It is recreated when
        /// the view becomes visible again.
        ///
        /// You can prevent this behavior by setting {@linkcode WebviewOptions.retainContextWhenHidden retainContextWhenHidden} in the {@linkcode WebviewOptions}.
        /// However this increases resource usage and should be avoided wherever possible. Instead, you can use
        /// persisted state to save off a webview's state so that it can be quickly recreated as needed.
        ///
        /// To save off a persisted state, inside the webview call <c>acquireVsCodeApi().setState()</c> with
        /// any json serializable object. To restore the state again, call <c>getState()</c>. For example:
        ///
        /// <code lang="js">
        /// // Within the webview
        /// const vscode = acquireVsCodeApi();
        ///
        /// // Get existing state
        /// const oldState = vscode.getState() || { value: 0 };
        ///
        /// // Update state
        /// setState({ value: oldState.value + 1 })
        /// </code>
        ///
        /// The editor ensures that the persisted state is saved correctly when a webview is hidden and across
        /// editor restarts.
        /// </summary>
        abstract member state: 'T option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type WebviewViewProvider =
        /// <summary>
        /// Resolves a webview view.
        ///
        /// <c>resolveWebviewView</c> is called when a view first becomes visible. This may happen when the view is
        /// first loaded or when the user hides and then shows a view again.
        /// </summary>
        /// <param name="webviewView">
        /// Webview view to restore. The provider should take ownership of this view. The
        /// provider must set the webview's <c>.html</c> and hook up all webview events it is interested in.
        /// </param>
        /// <param name="context">
        /// Additional metadata about the view being resolved.
        /// </param>
        /// <param name="token">
        /// Cancellation token indicating that the view being provided is no longer needed.
        /// </param>
        /// <returns>
        /// Optional thenable indicating that the view has been fully resolved.
        /// </returns>
        abstract member resolveWebviewView: webviewView: WebviewView * context: WebviewViewResolveContext * token: CancellationToken -> U2<Thenable<unit>, unit>

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomTextEditorProvider =
        /// <summary>
        /// Resolve a custom editor for a given text resource.
        ///
        /// This is called when a user first opens a resource for a <c>CustomTextEditorProvider</c>, or if they reopen an
        /// existing editor using this <c>CustomTextEditorProvider</c>.
        /// </summary>
        /// <param name="document">
        /// Document for the resource to resolve.
        /// </param>
        /// <param name="webviewPanel">
        /// The webview panel used to display the editor UI for this resource.
        ///
        /// During resolve, the provider must fill in the initial html for the content webview panel and hook up all
        /// the event listeners on it that it is interested in. The provider can also hold onto the {@linkcode WebviewPanel } to
        /// use later for example in a command. See {@linkcode WebviewPanel } for additional details.
        /// </param>
        /// <param name="token">
        /// A cancellation token that indicates the result is no longer needed.
        /// </param>
        /// <returns>
        /// Thenable indicating that the custom editor has been resolved.
        /// </returns>
        abstract member resolveCustomTextEditor: document: TextDocument * webviewPanel: WebviewPanel * token: CancellationToken -> U2<Thenable<unit>, unit>

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomDocument =
        /// <summary>
        /// The associated uri for this document.
        /// </summary>
        abstract member uri: Uri with get
        /// <summary>
        /// Dispose of the custom document.
        ///
        /// This is invoked by the editor when there are no more references to a given <c>CustomDocument</c> (for example when
        /// all editors associated with the document have been closed.)
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomDocumentEditEvent<'T when 'T :> CustomDocument> =
        /// <summary>
        /// The document that the edit is for.
        /// </summary>
        abstract member document: 'T with get
        /// <summary>
        /// Undo the edit operation.
        ///
        /// This is invoked by the editor when the user undoes this edit. To implement <c>undo</c>, your
        /// extension should restore the document and editor to the state they were in just before this
        /// edit was added to the editor's internal edit stack by {@linkcode CustomEditorProvider.onDidChangeCustomDocument}.
        /// </summary>
        abstract member undo: unit -> U2<Thenable<unit>, unit>
        /// <summary>
        /// Redo the edit operation.
        ///
        /// This is invoked by the editor when the user redoes this edit. To implement <c>redo</c>, your
        /// extension should restore the document and editor to the state they were in just after this
        /// edit was added to the editor's internal edit stack by {@linkcode CustomEditorProvider.onDidChangeCustomDocument}.
        /// </summary>
        abstract member redo: unit -> U2<Thenable<unit>, unit>
        /// <summary>
        /// Display name describing the edit.
        ///
        /// This will be shown to users in the UI for undo/redo operations.
        /// </summary>
        abstract member label: string option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomDocumentContentChangeEvent<'T when 'T :> CustomDocument> =
        /// <summary>
        /// The document that the change is for.
        /// </summary>
        abstract member document: 'T with get

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomDocumentBackup =
        /// <summary>
        /// Unique identifier for the backup.
        ///
        /// This id is passed back to your extension in {@linkcode CustomReadonlyEditorProvider.openCustomDocumentopenCustomDocument} when opening a custom editor from a backup.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// Delete the current backup.
        ///
        /// This is called by the editor when it is clear the current backup is no longer needed, such as when a new backup
        /// is made or when the file is saved.
        /// </summary>
        abstract member delete: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomDocumentBackupContext =
        /// <summary>
        /// Suggested file location to write the new backup.
        ///
        /// Note that your extension is free to ignore this and use its own strategy for backup.
        ///
        /// If the editor is for a resource from the current workspace, <c>destination</c> will point to a file inside
        /// <c>ExtensionContext.storagePath</c>. The parent folder of <c>destination</c> may not exist, so make sure to created it
        /// before writing the backup to this location.
        /// </summary>
        abstract member destination: Uri with get

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomDocumentOpenContext =
        /// <summary>
        /// The id of the backup to restore the document from or <c>undefined</c> if there is no backup.
        ///
        /// If this is provided, your extension should restore the editor from the backup instead of reading the file
        /// from the user's workspace.
        /// </summary>
        abstract member backupId: string option with get
        /// <summary>
        /// If the URI is an untitled file, this will be populated with the byte data of that file
        ///
        /// If this is provided, your extension should utilize this byte data rather than executing fs APIs on the URI passed in
        /// </summary>
        abstract member untitledDocumentData: JS.Uint8Array option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomReadonlyEditorProvider<'T when 'T :> CustomDocument> =
        /// <summary>
        /// Create a new document for a given resource.
        ///
        /// <c>openCustomDocument</c> is called when the first time an editor for a given resource is opened. The opened
        /// document is then passed to <see href="resolveCustomEditor">resolveCustomEditor</see> so that the editor can be shown to the user.
        ///
        /// Already opened {@linkcode CustomDocumentCustomDocuments} are re-used if the user opened additional editors. When all editors for a
        /// given resource are closed, the {@linkcode CustomDocumentCustomDocuments} is disposed of. Opening an editor at this point will
        /// trigger another call to <c>openCustomDocument</c>.
        /// </summary>
        /// <param name="uri">
        /// Uri of the document to open.
        /// </param>
        /// <param name="openContext">
        /// Additional information about the opening custom document.
        /// </param>
        /// <param name="token">
        /// A cancellation token that indicates the result is no longer needed.
        /// </param>
        /// <returns>
        /// The custom document.
        /// </returns>
        abstract member openCustomDocument: uri: Uri * openContext: CustomDocumentOpenContext * token: CancellationToken -> U2<Thenable<'T>, 'T>
        /// <summary>
        /// Resolve a custom editor for a given resource.
        ///
        /// This is called whenever the user opens a new editor for this <c>CustomEditorProvider</c>.
        /// </summary>
        /// <param name="document">
        /// Document for the resource being resolved.
        /// </param>
        /// <param name="webviewPanel">
        /// The webview panel used to display the editor UI for this resource.
        ///
        /// During resolve, the provider must fill in the initial html for the content webview panel and hook up all
        /// the event listeners on it that it is interested in. The provider can also hold onto the <c>WebviewPanel</c> to
        /// use later for example in a command. See {@linkcode WebviewPanel } for additional details.
        /// </param>
        /// <param name="token">
        /// A cancellation token that indicates the result is no longer needed.
        /// </param>
        /// <returns>
        /// Optional thenable indicating that the custom editor has been resolved.
        /// </returns>
        abstract member resolveCustomEditor: document: 'T * webviewPanel: WebviewPanel * token: CancellationToken -> U2<Thenable<unit>, unit>

    [<AllowNullLiteral>]
    [<Interface>]
    type CustomEditorProvider<'T when 'T :> CustomDocument> =
        inherit CustomReadonlyEditorProvider<'T>
        /// <summary>
        /// Signal that an edit has occurred inside a custom editor.
        ///
        /// This event must be fired by your extension whenever an edit happens in a custom editor. An edit can be
        /// anything from changing some text, to cropping an image, to reordering a list. Your extension is free to
        /// define what an edit is and what data is stored on each edit.
        ///
        /// Firing {@linkcode CustomEditorProvider.onDidChangeCustomDocumentonDidChangeCustomDocument} causes the
        /// editors to be marked as being dirty. This is cleared when the user either saves or reverts the file.
        ///
        /// Editors that support undo/redo must fire a {@linkcode CustomDocumentEditEvent} whenever an edit happens. This allows
        /// users to undo and redo the edit using the editor's standard keyboard shortcuts. The editor will also mark
        /// the editor as no longer being dirty if the user undoes all edits to the last saved state.
        ///
        /// Editors that support editing but cannot use the editor's standard undo/redo mechanism must fire a {@linkcode CustomDocumentContentChangeEvent}.
        /// The only way for a user to clear the dirty state of an editor that does not support undo/redo is to either
        /// <c>save</c> or <c>revert</c> the file.
        ///
        /// An editor should only ever fire {@linkcode CustomDocumentEditEvent} events, or only ever fire {@linkcode CustomDocumentContentChangeEvent} events.
        /// </summary>
        abstract member onDidChangeCustomDocument: U2<Event<CustomDocumentEditEvent<'T>>, Event<CustomDocumentContentChangeEvent<'T>>> with get
        /// <summary>
        /// Save a custom document.
        ///
        /// This method is invoked by the editor when the user saves a custom editor. This can happen when the user
        /// triggers save while the custom editor is active, by commands such as <c>save all</c>, or by auto save if enabled.
        ///
        /// The implementer must persist the custom editor. This usually means writing the
        /// file data for the custom document to disk. After {@linkcode saveCustomDocument} completes, any associated
        /// editor instances will no longer be marked as dirty.
        /// </summary>
        /// <param name="document">
        /// Document to save.
        /// </param>
        /// <param name="cancellation">
        /// Token that signals the save is no longer required (for example, if another save was triggered).
        /// </param>
        /// <returns>
        /// A {@linkcode Thenable } that saving has completed.
        /// </returns>
        abstract member saveCustomDocument: document: 'T * cancellation: CancellationToken -> Thenable<unit>
        /// <summary>
        /// Save a custom document to a different location.
        ///
        /// This method is invoked by the editor when the user triggers 'save as' on a custom editor. The implementer must
        /// persist the custom editor to {@linkcode destination}.
        ///
        /// When the user accepts save as, the current editor is be replaced by an non-dirty editor for the newly saved file.
        /// </summary>
        /// <param name="document">
        /// Document to save.
        /// </param>
        /// <param name="destination">
        /// Location to save to.
        /// </param>
        /// <param name="cancellation">
        /// Token that signals the save is no longer required.
        /// </param>
        /// <returns>
        /// A {@linkcode Thenable } signaling that saving has completed.
        /// </returns>
        abstract member saveCustomDocumentAs: document: 'T * destination: Uri * cancellation: CancellationToken -> Thenable<unit>
        /// <summary>
        /// Revert a custom document to its last saved state.
        ///
        /// This method is invoked by the editor when the user triggers <c>File: Revert File</c> in a custom editor. (Note that
        /// this is only used using the editor's <c>File: Revert File</c> command and not on a <c>git revert</c> of the file).
        ///
        /// The implementer must make sure all editor instances (webviews) for {@linkcode document}
        /// are displaying the document in the same state is saved in. This usually means reloading the file from the
        /// workspace.
        /// </summary>
        /// <param name="document">
        /// Document to revert.
        /// </param>
        /// <param name="cancellation">
        /// Token that signals the revert is no longer required.
        /// </param>
        /// <returns>
        /// A {@linkcode Thenable } signaling that the revert has completed.
        /// </returns>
        abstract member revertCustomDocument: document: 'T * cancellation: CancellationToken -> Thenable<unit>
        /// <summary>
        /// Back up a dirty custom document.
        ///
        /// Backups are used for hot exit and to prevent data loss. Your {@linkcode backupCustomDocument} method should persist the resource in
        /// its current state, i.e. with the edits applied. Most commonly this means saving the resource to disk in
        /// the <c>ExtensionContext.storagePath</c>. When the editor reloads and your custom editor is opened for a resource,
        /// your extension should first check to see if any backups exist for the resource. If there is a backup, your
        /// extension should load the file contents from there instead of from the resource in the workspace.
        ///
        /// {@linkcode backupCustomDocument} is triggered approximately one second after the user stops editing the document. If the user
        /// rapidly edits the document, {@linkcode backupCustomDocument} will not be invoked until the editing stops.
        ///
        /// {@linkcode backupCustomDocument} is not invoked when <c>auto save</c> is enabled (since auto save already persists the resource).
        /// </summary>
        /// <param name="document">
        /// Document to backup.
        /// </param>
        /// <param name="context">
        /// Information that can be used to backup the document.
        /// </param>
        /// <param name="cancellation">
        /// Token that signals the current backup since a new backup is coming in. It is up to your
        /// extension to decided how to respond to cancellation. If for example your extension is backing up a large file
        /// in an operation that takes time to complete, your extension may decide to finish the ongoing backup rather
        /// than cancelling it to ensure that the editor has some valid backup.
        /// </param>
        /// <returns>
        /// A {@linkcode Thenable } signaling that the backup has completed.
        /// </returns>
        abstract member backupCustomDocument: document: 'T * context: CustomDocumentBackupContext * cancellation: CancellationToken -> Thenable<CustomDocumentBackup>

    [<AllowNullLiteral>]
    [<Interface>]
    type Clipboard =
        /// <summary>
        /// Read the current clipboard contents as text.
        /// </summary>
        /// <returns>
        /// A thenable that resolves to a string.
        /// </returns>
        abstract member readText: unit -> Thenable<string>
        /// <summary>
        /// Writes text into the clipboard.
        /// </summary>
        /// <returns>
        /// A thenable that resolves when writing happened.
        /// </returns>
        abstract member writeText: value: string -> Thenable<unit>

    [<RequireQualifiedAccess>]
    type UIKind =
        | Desktop = 1
        | Web = 2

    [<RequireQualifiedAccess>]
    type LogLevel =
        | Off = 0
        | Trace = 1
        | Debug = 2
        | Info = 3
        | Warning = 4
        | Error = 5

    module env =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// The application name of the editor, like 'VS Code'.
            /// </summary>
            [<Emit("$0.appName")>]
            abstract member appName: string
            /// <summary>
            /// The application root folder from which the editor is running.
            ///
            /// *Note* that the value is the empty string when running in an
            /// environment that has no representation of an application root folder.
            /// </summary>
            [<Emit("$0.appRoot")>]
            abstract member appRoot: string
            /// <summary>
            /// The hosted location of the application
            /// On desktop this is 'desktop'
            /// In the web this is the specified embedder i.e. 'github.dev', 'codespaces', or 'web' if the embedder
            /// does not provide that information
            /// </summary>
            [<Emit("$0.appHost")>]
            abstract member appHost: string
            /// <summary>
            /// The custom uri scheme the editor registers to in the operating system.
            /// </summary>
            [<Emit("$0.uriScheme")>]
            abstract member uriScheme: string
            /// <summary>
            /// Represents the preferred user-language, like <c>de-CH</c>, <c>fr</c>, or <c>en-US</c>.
            /// </summary>
            [<Emit("$0.language")>]
            abstract member language: string
            /// <summary>
            /// The system clipboard.
            /// </summary>
            [<Emit("$0.clipboard")>]
            abstract member clipboard: Clipboard
            /// <summary>
            /// A unique identifier for the computer.
            /// </summary>
            [<Emit("$0.machineId")>]
            abstract member machineId: string
            /// <summary>
            /// A unique identifier for the current session.
            /// Changes each time the editor is started.
            /// </summary>
            [<Emit("$0.sessionId")>]
            abstract member sessionId: string
            /// <summary>
            /// Indicates that this is a fresh install of the application.
            /// <c>true</c> if within the first day of installation otherwise <c>false</c>.
            /// </summary>
            [<Emit("$0.isNewAppInstall")>]
            abstract member isNewAppInstall: bool
            /// <summary>
            /// Indicates whether the users has telemetry enabled.
            /// Can be observed to determine if the extension should send telemetry.
            /// </summary>
            [<Emit("$0.isTelemetryEnabled")>]
            abstract member isTelemetryEnabled: bool
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the user enabled or disables telemetry.
            /// <c>true</c> if the user has enabled telemetry or <c>false</c> if the user has disabled telemetry.
            /// </summary>
            [<Emit("$0.onDidChangeTelemetryEnabled")>]
            abstract member onDidChangeTelemetryEnabled: Event<bool>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the default shell changes. This fires with the new
            /// shell path.
            /// </summary>
            [<Emit("$0.onDidChangeShell")>]
            abstract member onDidChangeShell: Event<string>
            /// <summary>
            /// Creates a new <see href="TelemetryLoggertelemetry">logger</see>".
            /// </summary>
            /// <param name="sender">
            /// The telemetry sender that is used by the telemetry logger.
            /// </param>
            /// <param name="options">
            /// Options for the telemetry logger.
            /// </param>
            /// <returns>
            /// A new telemetry logger
            /// </returns>
            [<Emit("$0.createTelemetryLogger($1...)")>]
            abstract member createTelemetryLogger: sender: TelemetrySender * ?options: TelemetryLoggerOptions -> TelemetryLogger
            /// <summary>
            /// The name of a remote. Defined by extensions, popular samples are <c>wsl</c> for the Windows
            /// Subsystem for Linux or <c>ssh-remote</c> for remotes using a secure shell.
            ///
            /// *Note* that the value is <c>undefined</c> when there is no remote extension host but that the
            /// value is defined in all extension hosts (local and remote) in case a remote extension host
            /// exists. Use <see href="Extension.extensionKind">Extension.extensionKind</see> to know if
            /// a specific extension runs remote or not.
            /// </summary>
            [<Emit("$0.remoteName")>]
            abstract member remoteName: string option
            /// <summary>
            /// The detected default shell for the extension host, this is overridden by the
            /// <c>terminal.integrated.defaultProfile</c> setting for the extension host's platform. Note that in
            /// environments that do not support a shell the value is the empty string.
            /// </summary>
            [<Emit("$0.shell")>]
            abstract member shell: string
            /// <summary>
            /// The UI kind property indicates from which UI extensions
            /// are accessed from. For example, extensions could be accessed
            /// from a desktop application or a web browser.
            /// </summary>
            [<Emit("$0.uiKind")>]
            abstract member uiKind: UIKind
            /// <summary>
            /// Opens a link externally using the default application. Depending on the
            /// used scheme this can be:
            /// * a browser (<c>http:</c>, <c>https:</c>)
            /// * a mail client (<c>mailto:</c>)
            /// * VSCode itself (<c>vscode:</c> from <c>vscode.env.uriScheme</c>)
            ///
            /// *Note* that {@linkcode window.showTextDocumentshowTextDocument} is the right
            /// way to open a text document inside the editor, not this function.
            /// </summary>
            /// <param name="target">
            /// The uri that should be opened.
            /// </param>
            /// <returns>
            /// A promise indicating if open was successful.
            /// </returns>
            [<Emit("$0.openExternal($1...)")>]
            abstract member openExternal: target: Uri -> Thenable<bool>
            /// <summary>
            /// Resolves a uri to a form that is accessible externally.
            ///
            /// #### <c>http:</c> or <c>https:</c> scheme
            ///
            /// Resolves an *external* uri, such as a <c>http:</c> or <c>https:</c> link, from where the extension is running to a
            /// uri to the same resource on the client machine.
            ///
            /// This is a no-op if the extension is running on the client machine.
            ///
            /// If the extension is running remotely, this function automatically establishes a port forwarding tunnel
            /// from the local machine to <c>target</c> on the remote and returns a local uri to the tunnel. The lifetime of
            /// the port forwarding tunnel is managed by the editor and the tunnel can be closed by the user.
            ///
            /// *Note* that uris passed through <c>openExternal</c> are automatically resolved and you should not call <c>asExternalUri</c> on them.
            ///
            /// #### <c>vscode.env.uriScheme</c>
            ///
            /// Creates a uri that - if opened in a browser (e.g. via <c>openExternal</c>) - will result in a registered <see href="UriHandler">UriHandler</see>
            /// to trigger.
            ///
            /// Extensions should not make any assumptions about the resulting uri and should not alter it in any way.
            /// Rather, extensions can e.g. use this uri in an authentication flow, by adding the uri as callback query
            /// argument to the server to authenticate to.
            ///
            /// *Note* that if the server decides to add additional query parameters to the uri (e.g. a token or secret), it
            /// will appear in the uri that is passed to the <see href="UriHandler">UriHandler</see>.
            ///
            /// **Example** of an authentication flow:
            /// <code lang="typescript">
            /// vscode.window.registerUriHandler({
            ///   handleUri(uri: vscode.Uri): vscode.ProviderResult<void> {
            ///     if (uri.path === '/did-authenticate') {
            ///       console.log(uri.toString());
            ///     }
            ///   }
            /// });
            ///
            /// const callableUri = await vscode.env.asExternalUri(vscode.Uri.parse(vscode.env.uriScheme + '://my.extension/did-authenticate'));
            /// await vscode.env.openExternal(callableUri);
            /// </code>
            ///
            /// *Note* that extensions should not cache the result of <c>asExternalUri</c> as the resolved uri may become invalid due to
            /// a system or user action — for example, in remote cases, a user may close a port forwarding tunnel that was opened by
            /// <c>asExternalUri</c>.
            ///
            /// #### Any other scheme
            ///
            /// Any other scheme will be handled as if the provided URI is a workspace URI. In that case, the method will return
            /// a URI which, when handled, will make the editor open the workspace.
            /// </summary>
            /// <returns>
            /// A uri that can be used on the client machine.
            /// </returns>
            [<Emit("$0.asExternalUri($1...)")>]
            abstract member asExternalUri: target: Uri -> Thenable<Uri>
            /// <summary>
            /// The current log level of the editor.
            /// </summary>
            [<Emit("$0.logLevel")>]
            abstract member logLevel: LogLevel
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the log level of the editor changes.
            /// </summary>
            [<Emit("$0.onDidChangeLogLevel")>]
            abstract member onDidChangeLogLevel: Event<LogLevel>

    module commands =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Registers a command that can be invoked via a keyboard shortcut,
            /// a menu item, an action, or directly.
            ///
            /// Registering a command with an existing command identifier twice
            /// will cause an error.
            /// </summary>
            /// <param name="command">
            /// A unique identifier for the command.
            /// </param>
            /// <param name="callback">
            /// A command handler function.
            /// </param>
            /// <param name="thisArg">
            /// The <c>this</c> context used when invoking the handler function.
            /// </param>
            /// <returns>
            /// Disposable which unregisters this command on disposal.
            /// </returns>
            [<Emit("$0.registerCommand($1...)")>]
            abstract member registerCommand: command: string * callback: System.Delegate * ?thisArg: obj -> Disposable
            /// <summary>
            /// Registers a text editor command that can be invoked via a keyboard shortcut,
            /// a menu item, an action, or directly.
            ///
            /// Text editor commands are different from ordinary <see href="commands.registerCommandcommands">commands.registerCommandcommands</see> as
            /// they only execute when there is an active editor when the command is called. Also, the
            /// command handler of an editor command has access to the active editor and to an
            /// <see href="TextEditorEditedit">TextEditorEditedit</see>-builder. Note that the edit-builder is only valid while the
            /// callback executes.
            /// </summary>
            /// <param name="command">
            /// A unique identifier for the command.
            /// </param>
            /// <param name="callback">
            /// A command handler function with access to an <see href="TextEditor">editor</see>" and an <see href="TextEditorEdit">edit</see>".
            /// </param>
            /// <param name="thisArg">
            /// The <c>this</c> context used when invoking the handler function.
            /// </param>
            /// <returns>
            /// Disposable which unregisters this command on disposal.
            /// </returns>
            [<Emit("$0.registerTextEditorCommand($1...)")>]
            abstract member registerTextEditorCommand: command: string * callback: Exports.registerTextEditorCommand.callback * ?thisArg: obj -> Disposable
            /// <summary>
            /// Executes the command denoted by the given command identifier.
            ///
            /// * *Note 1:* When executing an editor command not all types are allowed to
            /// be passed as arguments. Allowed are the primitive types <c>string</c>, <c>boolean</c>,
            /// <c>number</c>, <c>undefined</c>, and <c>null</c>, as well as {@linkcode Position}, {@linkcode Range}, {@linkcode Uri} and {@linkcode Location}.
            /// * *Note 2:* There are no restrictions when executing commands that have been contributed
            /// by extensions.
            /// </summary>
            /// <param name="command">
            /// Identifier of the command to execute.
            /// </param>
            /// <param name="rest">
            /// Parameters passed to the command function.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the returned value of the given command. Returns <c>undefined</c> when
            /// the command handler function doesn't return anything.
            /// </returns>
            [<Emit("$0.executeCommand($1...)")>]
            abstract member executeCommand<'T>: command: string * [<ParamArray>] rest: obj [] -> Thenable<'T>
            /// <summary>
            /// Retrieve the list of all available commands. Commands starting with an underscore are
            /// treated as internal commands.
            /// </summary>
            /// <param name="filterInternal">
            /// Set <c>true</c> to not see internal commands (starting with an underscore)
            /// </param>
            /// <returns>
            /// Thenable that resolves to a list of command ids.
            /// </returns>
            [<Emit("$0.getCommands($1...)")>]
            abstract member getCommands: ?filterInternal: bool -> Thenable<ResizeArray<string>>

        module Exports =

            module registerTextEditorCommand =

                type callback =
                    delegate of textEditor: TextEditor * edit: TextEditorEdit * [<ParamArray>] args: obj [] -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type WindowState =
        /// <summary>
        /// Whether the current window is focused.
        /// </summary>
        abstract member focused: bool with get
        /// <summary>
        /// Whether the window has been interacted with recently. This will change
        /// immediately on activity, or after a short time of user inactivity.
        /// </summary>
        abstract member active: bool with get

    [<AllowNullLiteral>]
    [<Interface>]
    type UriHandler =
        /// <summary>
        /// Handle the provided system-wide <see href="Uri">Uri</see>.
        /// </summary>
        abstract member handleUri: uri: Uri -> ProviderResult<unit>

    module window =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Represents the grid widget within the main editor area
            /// </summary>
            [<Emit("$0.tabGroups")>]
            abstract member tabGroups: TabGroups
            /// <summary>
            /// The currently active editor or <c>undefined</c>. The active editor is the one
            /// that currently has focus or, when none has focus, the one that has changed
            /// input most recently.
            /// </summary>
            [<Emit("$0.activeTextEditor")>]
            abstract member activeTextEditor: TextEditor option
            /// <summary>
            /// The currently visible editors or an empty array.
            /// </summary>
            [<Emit("$0.visibleTextEditors")>]
            abstract member visibleTextEditors: ReadonlyArray<TextEditor>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the <see href="window.activeTextEditoractive">editor</see>"
            /// has changed. *Note* that the event also fires when the active editor changes
            /// to <c>undefined</c>.
            /// </summary>
            [<Emit("$0.onDidChangeActiveTextEditor")>]
            abstract member onDidChangeActiveTextEditor: Event<TextEditor option>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the array of <see href="window.visibleTextEditorsvisible">editors</see>"
            /// has changed.
            /// </summary>
            [<Emit("$0.onDidChangeVisibleTextEditors")>]
            abstract member onDidChangeVisibleTextEditors: Event<ReadonlyArray<TextEditor>>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the selection in an editor has changed.
            /// </summary>
            [<Emit("$0.onDidChangeTextEditorSelection")>]
            abstract member onDidChangeTextEditorSelection: Event<TextEditorSelectionChangeEvent>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the visible ranges of an editor has changed.
            /// </summary>
            [<Emit("$0.onDidChangeTextEditorVisibleRanges")>]
            abstract member onDidChangeTextEditorVisibleRanges: Event<TextEditorVisibleRangesChangeEvent>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the options of an editor have changed.
            /// </summary>
            [<Emit("$0.onDidChangeTextEditorOptions")>]
            abstract member onDidChangeTextEditorOptions: Event<TextEditorOptionsChangeEvent>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the view column of an editor has changed.
            /// </summary>
            [<Emit("$0.onDidChangeTextEditorViewColumn")>]
            abstract member onDidChangeTextEditorViewColumn: Event<TextEditorViewColumnChangeEvent>
            /// <summary>
            /// The currently visible <see href="NotebookEditornotebook">editors</see>" or an empty array.
            /// </summary>
            [<Emit("$0.visibleNotebookEditors")>]
            abstract member visibleNotebookEditors: ReadonlyArray<NotebookEditor>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the <see href="window.visibleNotebookEditorsvisible">notebook editors</see>"
            /// has changed.
            /// </summary>
            [<Emit("$0.onDidChangeVisibleNotebookEditors")>]
            abstract member onDidChangeVisibleNotebookEditors: Event<ReadonlyArray<NotebookEditor>>
            /// <summary>
            /// The currently active <see href="NotebookEditornotebook">editor</see>" or <c>undefined</c>. The active editor is the one
            /// that currently has focus or, when none has focus, the one that has changed
            /// input most recently.
            /// </summary>
            [<Emit("$0.activeNotebookEditor")>]
            abstract member activeNotebookEditor: NotebookEditor option
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the <see href="window.activeNotebookEditoractive">notebook editor</see>"
            /// has changed. *Note* that the event also fires when the active editor changes
            /// to <c>undefined</c>.
            /// </summary>
            [<Emit("$0.onDidChangeActiveNotebookEditor")>]
            abstract member onDidChangeActiveNotebookEditor: Event<NotebookEditor option>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the <see href="NotebookEditor.selectionsnotebook">editor selections</see>"
            /// have changed.
            /// </summary>
            [<Emit("$0.onDidChangeNotebookEditorSelection")>]
            abstract member onDidChangeNotebookEditorSelection: Event<NotebookEditorSelectionChangeEvent>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the <see href="NotebookEditor.visibleRangesnotebook">editor visible ranges</see>"
            /// have changed.
            /// </summary>
            [<Emit("$0.onDidChangeNotebookEditorVisibleRanges")>]
            abstract member onDidChangeNotebookEditorVisibleRanges: Event<NotebookEditorVisibleRangesChangeEvent>
            /// <summary>
            /// The currently opened terminals or an empty array.
            /// </summary>
            [<Emit("$0.terminals")>]
            abstract member terminals: ReadonlyArray<Terminal>
            /// <summary>
            /// The currently active terminal or <c>undefined</c>. The active terminal is the one that
            /// currently has focus or most recently had focus.
            /// </summary>
            [<Emit("$0.activeTerminal")>]
            abstract member activeTerminal: Terminal option
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the <see href="window.activeTerminalactive">terminal</see>"
            /// has changed. *Note* that the event also fires when the active terminal changes
            /// to <c>undefined</c>.
            /// </summary>
            [<Emit("$0.onDidChangeActiveTerminal")>]
            abstract member onDidChangeActiveTerminal: Event<Terminal option>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when a terminal has been created, either through the
            /// <see href="window.createTerminalcreateTerminal">window.createTerminalcreateTerminal</see> API or commands.
            /// </summary>
            [<Emit("$0.onDidOpenTerminal")>]
            abstract member onDidOpenTerminal: Event<Terminal>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when a terminal is disposed.
            /// </summary>
            [<Emit("$0.onDidCloseTerminal")>]
            abstract member onDidCloseTerminal: Event<Terminal>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when a <see href="Terminal.stateterminal's">state</see>" has changed.
            /// </summary>
            [<Emit("$0.onDidChangeTerminalState")>]
            abstract member onDidChangeTerminalState: Event<Terminal>
            /// <summary>
            /// Fires when shell integration activates or one of its properties changes in a terminal.
            /// </summary>
            [<Emit("$0.onDidChangeTerminalShellIntegration")>]
            abstract member onDidChangeTerminalShellIntegration: Event<TerminalShellIntegrationChangeEvent>
            /// <summary>
            /// This will be fired when a terminal command is started. This event will fire only when
            /// [shell integration](https://code.visualstudio.com/docs/terminal/shell-integration) is
            /// activated for the terminal.
            /// </summary>
            [<Emit("$0.onDidStartTerminalShellExecution")>]
            abstract member onDidStartTerminalShellExecution: Event<TerminalShellExecutionStartEvent>
            /// <summary>
            /// This will be fired when a terminal command is ended. This event will fire only when
            /// [shell integration](https://code.visualstudio.com/docs/terminal/shell-integration) is
            /// activated for the terminal.
            /// </summary>
            [<Emit("$0.onDidEndTerminalShellExecution")>]
            abstract member onDidEndTerminalShellExecution: Event<TerminalShellExecutionEndEvent>
            /// <summary>
            /// Represents the current window's state.
            /// </summary>
            [<Emit("$0.state")>]
            abstract member state: WindowState
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the focus or activity state of the current window
            /// changes. The value of the event represents whether the window is focused.
            /// </summary>
            [<Emit("$0.onDidChangeWindowState")>]
            abstract member onDidChangeWindowState: Event<WindowState>
            /// <summary>
            /// Show the given document in a text editor. A <see href="ViewColumncolumn">ViewColumncolumn</see> can be provided
            /// to control where the editor is being shown. Might change the <see href="window.activeTextEditoractive">editor</see>".
            /// </summary>
            /// <param name="document">
            /// A text document to be shown.
            /// </param>
            /// <param name="column">
            /// A view column in which the <see href="TextEditor">editor</see>" should be shown. The default is the <see href="ViewColumn.Active">active</see>".
            /// Columns that do not exist will be created as needed up to the maximum of {@linkcode ViewColumn.Nine }. Use {@linkcode ViewColumn.Beside }to open the editor to the side of the currently active one.
            /// </param>
            /// <param name="preserveFocus">
            /// When <c>true</c> the editor will not take focus.
            /// </param>
            /// <returns>
            /// A promise that resolves to an <see href="TextEditor">editor</see>".
            /// </returns>
            [<Emit("$0.showTextDocument($1...)")>]
            abstract member showTextDocument: document: TextDocument * ?column: ViewColumn * ?preserveFocus: bool -> Thenable<TextEditor>
            /// <summary>
            /// Show the given document in a text editor. <see href="TextDocumentShowOptionsOptions">TextDocumentShowOptionsOptions</see> can be provided
            /// to control options of the editor is being shown. Might change the <see href="window.activeTextEditoractive">editor</see>".
            /// </summary>
            /// <param name="document">
            /// A text document to be shown.
            /// </param>
            /// <param name="options">
            /// <see href="TextDocumentShowOptions">Editor options</see>" to configure the behavior of showing the <see href="TextEditor">editor</see>".
            /// </param>
            /// <returns>
            /// A promise that resolves to an <see href="TextEditor">editor</see>".
            /// </returns>
            [<Emit("$0.showTextDocument($1...)")>]
            abstract member showTextDocument: document: TextDocument * ?options: TextDocumentShowOptions -> Thenable<TextEditor>
            /// <summary>
            /// A short-hand for <c>openTextDocument(uri).then(document => showTextDocument(document, options))</c>.
            /// </summary>
            /// <param name="uri">
            /// A resource identifier.
            /// </param>
            /// <param name="options">
            /// <see href="TextDocumentShowOptions">Editor options</see>" to configure the behavior of showing the <see href="TextEditor">editor</see>".
            /// </param>
            /// <returns>
            /// A promise that resolves to an <see href="TextEditor">editor</see>".
            /// </returns>
            [<Emit("$0.showTextDocument($1...)")>]
            abstract member showTextDocument: uri: Uri * ?options: TextDocumentShowOptions -> Thenable<TextEditor>
            /// <summary>
            /// Show the given <see href="NotebookDocument">NotebookDocument</see> in a <see href="NotebookEditornotebook">editor</see>".
            /// </summary>
            /// <param name="document">
            /// A text document to be shown.
            /// </param>
            /// <param name="options">
            /// <see href="NotebookDocumentShowOptions">Editor options</see>" to configure the behavior of showing the <see href="NotebookEditor">notebook editor</see>".
            /// </param>
            /// <returns>
            /// A promise that resolves to an <see href="NotebookEditor">notebook editor</see>".
            /// </returns>
            [<Emit("$0.showNotebookDocument($1...)")>]
            abstract member showNotebookDocument: document: NotebookDocument * ?options: NotebookDocumentShowOptions -> Thenable<NotebookEditor>
            /// <summary>
            /// Create a TextEditorDecorationType that can be used to add decorations to text editors.
            /// </summary>
            /// <param name="options">
            /// Rendering options for the decoration type.
            /// </param>
            /// <returns>
            /// A new decoration type instance.
            /// </returns>
            [<Emit("$0.createTextEditorDecorationType($1...)")>]
            abstract member createTextEditorDecorationType: options: DecorationRenderOptions -> TextEditorDecorationType
            /// <summary>
            /// Show an information message to users. Optionally provide an array of items which will be presented as
            /// clickable buttons.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showInformationMessage($1...)")>]
            abstract member showInformationMessage: message: string * [<ParamArray>] items: string [] -> Thenable<string option>
            /// <summary>
            /// Show an information message to users. Optionally provide an array of items which will be presented as
            /// clickable buttons.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="options">
            /// Configures the behaviour of the message.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showInformationMessage($1...)")>]
            abstract member showInformationMessage: message: string * options: MessageOptions * [<ParamArray>] items: string [] -> Thenable<string option>
            /// <summary>
            /// Show an information message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showInformationMessage($1...)")>]
            abstract member showInformationMessage<'T when 'T :> MessageItem>: message: string * [<ParamArray>] items: 'T [] -> Thenable<'T option>
            /// <summary>
            /// Show an information message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="options">
            /// Configures the behaviour of the message.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showInformationMessage($1...)")>]
            abstract member showInformationMessage<'T when 'T :> MessageItem>: message: string * options: MessageOptions * [<ParamArray>] items: 'T [] -> Thenable<'T option>
            /// <summary>
            /// Show a warning message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showWarningMessage($1...)")>]
            abstract member showWarningMessage: message: string * [<ParamArray>] items: string [] -> Thenable<string option>
            /// <summary>
            /// Show a warning message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="options">
            /// Configures the behaviour of the message.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showWarningMessage($1...)")>]
            abstract member showWarningMessage: message: string * options: MessageOptions * [<ParamArray>] items: string [] -> Thenable<string option>
            /// <summary>
            /// Show a warning message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showWarningMessage($1...)")>]
            abstract member showWarningMessage<'T when 'T :> MessageItem>: message: string * [<ParamArray>] items: 'T [] -> Thenable<'T option>
            /// <summary>
            /// Show a warning message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="options">
            /// Configures the behaviour of the message.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showWarningMessage($1...)")>]
            abstract member showWarningMessage<'T when 'T :> MessageItem>: message: string * options: MessageOptions * [<ParamArray>] items: 'T [] -> Thenable<'T option>
            /// <summary>
            /// Show an error message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showErrorMessage($1...)")>]
            abstract member showErrorMessage: message: string * [<ParamArray>] items: string [] -> Thenable<string option>
            /// <summary>
            /// Show an error message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="options">
            /// Configures the behaviour of the message.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showErrorMessage($1...)")>]
            abstract member showErrorMessage: message: string * options: MessageOptions * [<ParamArray>] items: string [] -> Thenable<string option>
            /// <summary>
            /// Show an error message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showErrorMessage($1...)")>]
            abstract member showErrorMessage<'T when 'T :> MessageItem>: message: string * [<ParamArray>] items: 'T [] -> Thenable<'T option>
            /// <summary>
            /// Show an error message.
            /// </summary>
            /// <param name="message">
            /// The message to show.
            /// </param>
            /// <param name="options">
            /// Configures the behaviour of the message.
            /// </param>
            /// <param name="items">
            /// A set of items that will be rendered as actions in the message.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c> when being dismissed.
            /// </returns>
            [<Emit("$0.showErrorMessage($1...)")>]
            abstract member showErrorMessage<'T when 'T :> MessageItem>: message: string * options: MessageOptions * [<ParamArray>] items: 'T [] -> Thenable<'T option>
            /// <summary>
            /// Shows a selection list allowing multiple selections.
            /// </summary>
            /// <param name="items">
            /// An array of strings, or a promise that resolves to an array of strings.
            /// </param>
            /// <param name="options">
            /// Configures the behavior of the selection list.
            /// </param>
            /// <param name="token">
            /// A token that can be used to signal cancellation.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected items or <c>undefined</c>.
            /// </returns>
            [<Emit("$0.showQuickPick($1...)")>]
            abstract member showQuickPick: items: U2<ReadonlyArray<string>, Thenable<ReadonlyArray<string>>> * options: obj * ?token: CancellationToken -> Thenable<ResizeArray<string> option>
            /// <summary>
            /// Shows a selection list.
            /// </summary>
            /// <param name="items">
            /// An array of strings, or a promise that resolves to an array of strings.
            /// </param>
            /// <param name="options">
            /// Configures the behavior of the selection list.
            /// </param>
            /// <param name="token">
            /// A token that can be used to signal cancellation.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected string or <c>undefined</c>.
            /// </returns>
            [<Emit("$0.showQuickPick($1...)")>]
            abstract member showQuickPick: items: U2<ReadonlyArray<string>, Thenable<ReadonlyArray<string>>> * ?options: QuickPickOptions * ?token: CancellationToken -> Thenable<string option>
            /// <summary>
            /// Shows a selection list allowing multiple selections.
            /// </summary>
            /// <param name="items">
            /// An array of items, or a promise that resolves to an array of items.
            /// </param>
            /// <param name="options">
            /// Configures the behavior of the selection list.
            /// </param>
            /// <param name="token">
            /// A token that can be used to signal cancellation.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected items or <c>undefined</c>.
            /// </returns>
            [<Emit("$0.showQuickPick($1...)")>]
            abstract member showQuickPick<'T when 'T :> QuickPickItem>: items: U2<ReadonlyArray<'T>, Thenable<ReadonlyArray<'T>>> * options: obj * ?token: CancellationToken -> Thenable<ResizeArray<'T> option>
            /// <summary>
            /// Shows a selection list.
            /// </summary>
            /// <param name="items">
            /// An array of items, or a promise that resolves to an array of items.
            /// </param>
            /// <param name="options">
            /// Configures the behavior of the selection list.
            /// </param>
            /// <param name="token">
            /// A token that can be used to signal cancellation.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the selected item or <c>undefined</c>.
            /// </returns>
            [<Emit("$0.showQuickPick($1...)")>]
            abstract member showQuickPick<'T when 'T :> QuickPickItem>: items: U2<ReadonlyArray<'T>, Thenable<ReadonlyArray<'T>>> * ?options: QuickPickOptions * ?token: CancellationToken -> Thenable<'T option>
            /// <summary>
            /// Shows a selection list of <see href="workspace.workspaceFoldersworkspace">folders</see>" to pick from.
            /// Returns <c>undefined</c> if no folder is open.
            /// </summary>
            /// <param name="options">
            /// Configures the behavior of the workspace folder list.
            /// </param>
            /// <returns>
            /// A promise that resolves to the workspace folder or <c>undefined</c>.
            /// </returns>
            [<Emit("$0.showWorkspaceFolderPick($1...)")>]
            abstract member showWorkspaceFolderPick: ?options: WorkspaceFolderPickOptions -> Thenable<WorkspaceFolder option>
            /// <summary>
            /// Shows a file open dialog to the user which allows to select a file
            /// for opening-purposes.
            /// </summary>
            /// <param name="options">
            /// Options that control the dialog.
            /// </param>
            /// <returns>
            /// A promise that resolves to the selected resources or <c>undefined</c>.
            /// </returns>
            [<Emit("$0.showOpenDialog($1...)")>]
            abstract member showOpenDialog: ?options: OpenDialogOptions -> Thenable<ResizeArray<Uri> option>
            /// <summary>
            /// Shows a file save dialog to the user which allows to select a file
            /// for saving-purposes.
            /// </summary>
            /// <param name="options">
            /// Options that control the dialog.
            /// </param>
            /// <returns>
            /// A promise that resolves to the selected resource or <c>undefined</c>.
            /// </returns>
            [<Emit("$0.showSaveDialog($1...)")>]
            abstract member showSaveDialog: ?options: SaveDialogOptions -> Thenable<Uri option>
            /// <summary>
            /// Opens an input box to ask the user for input.
            ///
            /// The returned value will be <c>undefined</c> if the input box was canceled (e.g., pressing ESC). Otherwise the
            /// returned value will be the string typed by the user or an empty string if the user did not type
            /// anything but dismissed the input box with OK.
            /// </summary>
            /// <param name="options">
            /// Configures the behavior of the input box.
            /// </param>
            /// <param name="token">
            /// A token that can be used to signal cancellation.
            /// </param>
            /// <returns>
            /// A thenable that resolves to a string the user provided or to <c>undefined</c> in case of dismissal.
            /// </returns>
            [<Emit("$0.showInputBox($1...)")>]
            abstract member showInputBox: ?options: InputBoxOptions * ?token: CancellationToken -> Thenable<string option>
            /// <summary>
            /// Creates a <see href="QuickPick">QuickPick</see> to let the user pick an item from a list of items of type <c>T</c>.
            ///
            /// Note that in many cases the more convenient <see href="window.showQuickPick">window.showQuickPick</see> is easier to use.
            /// <see href="window.createQuickPick">window.createQuickPick</see> should be used when <see href="window.showQuickPick">window.showQuickPick</see> does not offer
            /// the required flexibility.
            /// </summary>
            /// <returns>
            /// A new <see href="QuickPick">QuickPick</see>.
            /// </returns>
            [<Emit("$0.createQuickPick($1...)")>]
            abstract member createQuickPick<'T when 'T :> QuickPickItem>: unit -> QuickPick<'T>
            /// <summary>
            /// Creates a <see href="InputBox">InputBox</see> to let the user enter some text input.
            ///
            /// Note that in many cases the more convenient <see href="window.showInputBox">window.showInputBox</see> is easier to use.
            /// <see href="window.createInputBox">window.createInputBox</see> should be used when <see href="window.showInputBox">window.showInputBox</see> does not offer
            /// the required flexibility.
            /// </summary>
            /// <returns>
            /// A new <see href="InputBox">InputBox</see>.
            /// </returns>
            [<Emit("$0.createInputBox($1...)")>]
            abstract member createInputBox: unit -> InputBox
            /// <summary>
            /// Creates a new <see href="OutputChanneloutput">channel</see>" with the given name and language id
            /// If language id is not provided, then **Log** is used as default language id.
            ///
            /// You can access the visible or active output channel as a <see href="TextDocumenttext">document</see>" from <see href="window.visibleTextEditorsvisible">editors</see>" or <see href="window.activeTextEditoractive">editor</see>"
            /// and use the language id to contribute language features like syntax coloring, code lens etc.,
            /// </summary>
            /// <param name="name">
            /// Human-readable string which will be used to represent the channel in the UI.
            /// </param>
            /// <param name="languageId">
            /// The identifier of the language associated with the channel.
            /// </param>
            /// <returns>
            /// A new output channel.
            /// </returns>
            [<Emit("$0.createOutputChannel($1...)")>]
            abstract member createOutputChannel: name: string * ?languageId: string -> OutputChannel
            /// <summary>
            /// Creates a new <see href="LogOutputChannellog">output channel</see>" with the given name.
            /// </summary>
            /// <param name="name">
            /// Human-readable string which will be used to represent the channel in the UI.
            /// </param>
            /// <param name="options">
            /// Options for the log output channel.
            /// </param>
            /// <returns>
            /// A new log output channel.
            /// </returns>
            [<Emit("$0.createOutputChannel($1...)")>]
            abstract member createOutputChannel: name: string * options: Exports.createOutputChannel.options -> LogOutputChannel
            /// <summary>
            /// Create and show a new webview panel.
            /// </summary>
            /// <param name="viewType">
            /// Identifies the type of the webview panel.
            /// </param>
            /// <param name="title">
            /// Title of the panel.
            /// </param>
            /// <param name="showOptions">
            /// Where to show the webview in the editor. If preserveFocus is set, the new webview will not take focus.
            /// </param>
            /// <param name="options">
            /// Settings for the new panel.
            /// </param>
            /// <returns>
            /// New webview panel.
            /// </returns>
            [<Emit("$0.createWebviewPanel($1...)")>]
            abstract member createWebviewPanel: viewType: string * title: string * showOptions: U2<ViewColumn, Exports.createWebviewPanel.showOptions.U2.Case2> * ?options: Exports.createWebviewPanel.options -> WebviewPanel
            /// <summary>
            /// Set a message to the status bar. This is a short hand for the more powerful
            /// status bar <see href="window.createStatusBarItemitems">window.createStatusBarItemitems</see>.
            /// </summary>
            /// <param name="text">
            /// The message to show, supports icon substitution as in status bar <see href="StatusBarItem.text">items</see>".
            /// </param>
            /// <param name="hideAfterTimeout">
            /// Timeout in milliseconds after which the message will be disposed.
            /// </param>
            /// <returns>
            /// A disposable which hides the status bar message.
            /// </returns>
            [<Emit("$0.setStatusBarMessage($1...)")>]
            abstract member setStatusBarMessage: text: string * hideAfterTimeout: float -> Disposable
            /// <summary>
            /// Set a message to the status bar. This is a short hand for the more powerful
            /// status bar <see href="window.createStatusBarItemitems">window.createStatusBarItemitems</see>.
            /// </summary>
            /// <param name="text">
            /// The message to show, supports icon substitution as in status bar <see href="StatusBarItem.text">items</see>".
            /// </param>
            /// <param name="hideWhenDone">
            /// Thenable on which completion (resolve or reject) the message will be disposed.
            /// </param>
            /// <returns>
            /// A disposable which hides the status bar message.
            /// </returns>
            [<Emit("$0.setStatusBarMessage($1...)")>]
            abstract member setStatusBarMessage: text: string * hideWhenDone: Thenable<obj> -> Disposable
            /// <summary>
            /// Set a message to the status bar. This is a short hand for the more powerful
            /// status bar <see href="window.createStatusBarItemitems">window.createStatusBarItemitems</see>.
            ///
            /// *Note* that status bar messages stack and that they must be disposed when no
            /// longer used.
            /// </summary>
            /// <param name="text">
            /// The message to show, supports icon substitution as in status bar <see href="StatusBarItem.text">items</see>".
            /// </param>
            /// <returns>
            /// A disposable which hides the status bar message.
            /// </returns>
            [<Emit("$0.setStatusBarMessage($1...)")>]
            abstract member setStatusBarMessage: text: string -> Disposable
            /// <summary>
            /// Show progress in the Source Control viewlet while running the given callback and while
            /// its returned promise isn't resolve or rejected.
            /// </summary>
            /// <param name="task">
            /// A callback returning a promise. Progress increments can be reported with
            /// the provided <see href="Progress">Progress</see>-object.
            /// </param>
            /// <returns>
            /// The thenable the task did return.
            /// </returns>
            [<Emit("$0.withScmProgress($1...)"); Obsolete("Use `withProgress` instead.")>]
            abstract member withScmProgress<'R>: task: (Progress<float> -> Thenable<'R>) -> Thenable<'R>
            /// <summary>
            /// Show progress in the editor. Progress is shown while running the given callback
            /// and while the promise it returned isn't resolved nor rejected. The location at which
            /// progress should show (and other details) is defined via the passed {@linkcode ProgressOptions}.
            /// </summary>
            /// <param name="options">
            /// A {@linkcode ProgressOptions }-object describing the options to use for showing progress, like its location
            /// </param>
            /// <param name="task">
            /// A callback returning a promise. Progress state can be reported with
            /// the provided <see href="Progress">Progress</see>-object.
            ///
            /// To report discrete progress, use <c>increment</c> to indicate how much work has been completed. Each call with
            /// a <c>increment</c> value will be summed up and reflected as overall progress until 100% is reached (a value of
            /// e.g. <c>10</c> accounts for <c>10%</c> of work done).
            /// Note that currently only <c>ProgressLocation.Notification</c> is capable of showing discrete progress.
            ///
            /// To monitor if the operation has been cancelled by the user, use the provided {@linkcode CancellationToken }.
            /// Note that currently only <c>ProgressLocation.Notification</c> is supporting to show a cancel button to cancel the
            /// long running operation.
            /// </param>
            /// <returns>
            /// The thenable the task-callback returned.
            /// </returns>
            [<Emit("$0.withProgress($1...)")>]
            abstract member withProgress<'R>: options: ProgressOptions * task: Exports.withProgress.task<'R> -> Thenable<'R>
            /// <summary>
            /// Creates a status bar <see href="StatusBarItemitem">StatusBarItemitem</see>.
            /// </summary>
            /// <param name="id">
            /// The identifier of the item. Must be unique within the extension.
            /// </param>
            /// <param name="alignment">
            /// The alignment of the item.
            /// </param>
            /// <param name="priority">
            /// The priority of the item. Higher values mean the item should be shown more to the left.
            /// </param>
            /// <returns>
            /// A new status bar item.
            /// </returns>
            [<Emit("$0.createStatusBarItem($1...)")>]
            abstract member createStatusBarItem: id: string * ?alignment: StatusBarAlignment * ?priority: float -> StatusBarItem
            /// <summary>
            /// Creates a status bar <see href="StatusBarItemitem">StatusBarItemitem</see>.
            /// </summary>
            /// <param name="alignment">
            /// The alignment of the item.
            /// </param>
            /// <param name="priority">
            /// The priority of the item. Higher values mean the item should be shown more to the left.
            /// </param>
            /// <returns>
            /// A new status bar item.
            /// </returns>
            [<Emit("$0.createStatusBarItem($1...)")>]
            abstract member createStatusBarItem: ?alignment: StatusBarAlignment * ?priority: float -> StatusBarItem
            /// <summary>
            /// Creates a <see href="Terminal">Terminal</see> with a backing shell process. The cwd of the terminal will be the workspace
            /// directory if it exists.
            /// </summary>
            /// <remarks>
            /// Throws:
            /// -------
            ///
            /// When running in an environment where a new process cannot be started.
            /// </remarks>
            /// <param name="name">
            /// Optional human-readable string which will be used to represent the terminal in the UI.
            /// </param>
            /// <param name="shellPath">
            /// Optional path to a custom shell executable to be used in the terminal.
            /// </param>
            /// <param name="shellArgs">
            /// Optional args for the custom shell executable. A string can be used on Windows only which
            /// allows specifying shell args in
            /// [command-line format](https://msdn.microsoft.com/en-au/08dfcab2-eb6e-49a4-80eb-87d4076c98c6).
            /// </param>
            /// <returns>
            /// A new Terminal.
            /// </returns>
            [<Emit("$0.createTerminal($1...)")>]
            abstract member createTerminal: ?name: string * ?shellPath: string * ?shellArgs: U2<ReadonlyArray<string>, string> -> Terminal
            /// <summary>
            /// Creates a <see href="Terminal">Terminal</see> with a backing shell process.
            /// </summary>
            /// <remarks>
            /// Throws:
            /// -------
            ///
            /// When running in an environment where a new process cannot be started.
            /// </remarks>
            /// <param name="options">
            /// A TerminalOptions object describing the characteristics of the new terminal.
            /// </param>
            /// <returns>
            /// A new Terminal.
            /// </returns>
            [<Emit("$0.createTerminal($1...)")>]
            abstract member createTerminal: options: TerminalOptions -> Terminal
            /// <summary>
            /// Creates a <see href="Terminal">Terminal</see> where an extension controls its input and output.
            /// </summary>
            /// <param name="options">
            /// An <see href="ExtensionTerminalOptions">ExtensionTerminalOptions</see> object describing
            /// the characteristics of the new terminal.
            /// </param>
            /// <returns>
            /// A new Terminal.
            /// </returns>
            [<Emit("$0.createTerminal($1...)")>]
            abstract member createTerminal: options: ExtensionTerminalOptions -> Terminal
            /// <summary>
            /// Register a <see href="TreeDataProvider">TreeDataProvider</see> for the view contributed using the extension point <c>views</c>.
            /// This will allow you to contribute data to the <see href="TreeView">TreeView</see> and update if the data changes.
            ///
            /// **Note:** To get access to the <see href="TreeView">TreeView</see> and perform operations on it, use <see href="window.createTreeViewcreateTreeView">window.createTreeViewcreateTreeView</see>.
            /// </summary>
            /// <param name="viewId">
            /// Id of the view contributed using the extension point <c>views</c>.
            /// </param>
            /// <param name="treeDataProvider">
            /// A <see href="TreeDataProvider">TreeDataProvider</see> that provides tree data for the view
            /// </param>
            /// <returns>
            /// A <see href="Disposable">disposable</see>" that unregisters the <see href="TreeDataProvider">TreeDataProvider</see>.
            /// </returns>
            [<Emit("$0.registerTreeDataProvider($1...)")>]
            abstract member registerTreeDataProvider<'T>: viewId: string * treeDataProvider: TreeDataProvider<'T> -> Disposable
            /// <summary>
            /// Create a <see href="TreeView">TreeView</see> for the view contributed using the extension point <c>views</c>.
            /// </summary>
            /// <param name="viewId">
            /// Id of the view contributed using the extension point <c>views</c>.
            /// </param>
            /// <param name="options">
            /// Options for creating the <see href="TreeView">TreeView</see>
            /// </param>
            /// <returns>
            /// a <see href="TreeView">TreeView</see>.
            /// </returns>
            [<Emit("$0.createTreeView($1...)")>]
            abstract member createTreeView<'T>: viewId: string * options: TreeViewOptions<'T> -> TreeView<'T>
            /// <summary>
            /// Registers a <see href="UriHandleruri">handler</see>" capable of handling system-wide <see href="Uriuris">Uriuris</see>.
            /// In case there are multiple windows open, the topmost window will handle the uri.
            /// A uri handler is scoped to the extension it is contributed from; it will only
            /// be able to handle uris which are directed to the extension itself. A uri must respect
            /// the following rules:
            ///
            /// - The uri-scheme must be <c>vscode.env.uriScheme</c>;
            /// - The uri-authority must be the extension id (e.g. <c>my.extension</c>);
            /// - The uri-path, -query and -fragment parts are arbitrary.
            ///
            /// For example, if the <c>my.extension</c> extension registers a uri handler, it will only
            /// be allowed to handle uris with the prefix <c>product-name://my.extension</c>.
            ///
            /// An extension can only register a single uri handler in its entire activation lifetime.
            ///
            /// * *Note:* There is an activation event <c>onUri</c> that fires when a uri directed for
            /// the current extension is about to be handled.
            /// </summary>
            /// <param name="handler">
            /// The uri handler to register for this extension.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">disposable</see>" that unregisters the handler.
            /// </returns>
            [<Emit("$0.registerUriHandler($1...)")>]
            abstract member registerUriHandler: handler: UriHandler -> Disposable
            /// <summary>
            /// Registers a webview panel serializer.
            ///
            /// Extensions that support reviving should have an <c>"onWebviewPanel:viewType"</c> activation event and
            /// make sure that <c>registerWebviewPanelSerializer</c> is called during activation.
            ///
            /// Only a single serializer may be registered at a time for a given <c>viewType</c>.
            /// </summary>
            /// <param name="viewType">
            /// Type of the webview panel that can be serialized.
            /// </param>
            /// <param name="serializer">
            /// Webview serializer.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">disposable</see>" that unregisters the serializer.
            /// </returns>
            [<Emit("$0.registerWebviewPanelSerializer($1...)")>]
            abstract member registerWebviewPanelSerializer: viewType: string * serializer: WebviewPanelSerializer -> Disposable
            /// <summary>
            /// Register a new provider for webview views.
            /// </summary>
            /// <param name="viewId">
            /// Unique id of the view. This should match the <c>id</c> from the
            /// <c>views</c> contribution in the package.json.
            /// </param>
            /// <param name="provider">
            /// Provider for the webview views.
            /// </param>
            /// <returns>
            /// Disposable that unregisters the provider.
            /// </returns>
            [<Emit("$0.registerWebviewViewProvider($1...)")>]
            abstract member registerWebviewViewProvider: viewId: string * provider: WebviewViewProvider * ?options: Exports.registerWebviewViewProvider.options -> Disposable
            /// <summary>
            /// Register a provider for custom editors for the <c>viewType</c> contributed by the <c>customEditors</c> extension point.
            ///
            /// When a custom editor is opened, an <c>onCustomEditor:viewType</c> activation event is fired. Your extension
            /// must register a {@linkcode CustomTextEditorProvider}, {@linkcode CustomReadonlyEditorProvider},
            /// {@linkcode CustomEditorProvider}for <c>viewType</c> as part of activation.
            /// </summary>
            /// <param name="viewType">
            /// Unique identifier for the custom editor provider. This should match the <c>viewType</c> from the
            /// <c>customEditors</c> contribution point.
            /// </param>
            /// <param name="provider">
            /// Provider that resolves custom editors.
            /// </param>
            /// <param name="options">
            /// Options for the provider.
            /// </param>
            /// <returns>
            /// Disposable that unregisters the provider.
            /// </returns>
            [<Emit("$0.registerCustomEditorProvider($1...)")>]
            abstract member registerCustomEditorProvider: viewType: string * provider: U3<CustomTextEditorProvider, CustomReadonlyEditorProvider, CustomEditorProvider> * ?options: Exports.registerCustomEditorProvider.options -> Disposable
            /// <summary>
            /// Register provider that enables the detection and handling of links within the terminal.
            /// </summary>
            /// <param name="provider">
            /// The provider that provides the terminal links.
            /// </param>
            /// <returns>
            /// Disposable that unregisters the provider.
            /// </returns>
            [<Emit("$0.registerTerminalLinkProvider($1...)")>]
            abstract member registerTerminalLinkProvider: provider: TerminalLinkProvider -> Disposable
            /// <summary>
            /// Registers a provider for a contributed terminal profile.
            /// </summary>
            /// <param name="id">
            /// The ID of the contributed terminal profile.
            /// </param>
            /// <param name="provider">
            /// The terminal profile provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">disposable</see>" that unregisters the provider.
            /// </returns>
            [<Emit("$0.registerTerminalProfileProvider($1...)")>]
            abstract member registerTerminalProfileProvider: id: string * provider: TerminalProfileProvider -> Disposable
            /// <summary>
            /// Register a file decoration provider.
            /// </summary>
            /// <param name="provider">
            /// A <see href="FileDecorationProvider">FileDecorationProvider</see>.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters the provider.
            /// </returns>
            [<Emit("$0.registerFileDecorationProvider($1...)")>]
            abstract member registerFileDecorationProvider: provider: FileDecorationProvider -> Disposable
            /// <summary>
            /// The currently active color theme as configured in the settings. The active
            /// theme can be changed via the <c>workbench.colorTheme</c> setting.
            /// </summary>
            [<Emit("$0.activeColorTheme")>]
            abstract member activeColorTheme: ColorTheme
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the active color theme is changed or has changes.
            /// </summary>
            [<Emit("$0.onDidChangeActiveColorTheme")>]
            abstract member onDidChangeActiveColorTheme: Event<ColorTheme>

        module Exports =

            module createOutputChannel =

                [<Global>]
                [<AllowNullLiteral>]
                type options
                    [<ParamObject; Emit("$0")>]
                    (
                        log: bool
                    ) =

                    member val log : bool = nativeOnly with get, set

            module createWebviewPanel =

                [<AllowNullLiteral>]
                [<Interface>]
                type options =
                    /// <summary>
                    /// Controls if the find widget is enabled in the panel.
                    ///
                    /// Defaults to <c>false</c>.
                    /// </summary>
                    abstract member enableFindWidget: bool option with get
                    /// <summary>
                    /// Controls if the webview panel's content (iframe) is kept around even when the panel
                    /// is no longer visible.
                    ///
                    /// Normally the webview panel's html context is created when the panel becomes visible
                    /// and destroyed when it is hidden. Extensions that have complex state
                    /// or UI can set the <c>retainContextWhenHidden</c> to make the editor keep the webview
                    /// context around, even when the webview moves to a background tab. When a webview using
                    /// <c>retainContextWhenHidden</c> becomes hidden, its scripts and other dynamic content are suspended.
                    /// When the panel becomes visible again, the context is automatically restored
                    /// in the exact same state it was in originally. You cannot send messages to a
                    /// hidden webview, even with <c>retainContextWhenHidden</c> enabled.
                    ///
                    /// <c>retainContextWhenHidden</c> has a high memory overhead and should only be used if
                    /// your panel's context cannot be quickly saved and restored.
                    /// </summary>
                    abstract member retainContextWhenHidden: bool option with get
                    /// <summary>
                    /// Controls whether scripts are enabled in the webview content or not.
                    ///
                    /// Defaults to false (scripts-disabled).
                    /// </summary>
                    abstract member enableScripts: bool option with get
                    /// <summary>
                    /// Controls whether forms are enabled in the webview content or not.
                    ///
                    /// Defaults to true if <see href="WebviewOptions.enableScriptsscripts">are enabled</see>". Otherwise defaults to false.
                    /// Explicitly setting this property to either true or false overrides the default.
                    /// </summary>
                    abstract member enableForms: bool option with get
                    /// <summary>
                    /// Controls whether command uris are enabled in webview content or not.
                    ///
                    /// Defaults to <c>false</c> (command uris are disabled).
                    ///
                    /// If you pass in an array, only the commands in the array are allowed.
                    /// </summary>
                    abstract member enableCommandUris: U2<bool, ReadonlyArray<string>> option with get
                    /// <summary>
                    /// Root paths from which the webview can load local (filesystem) resources using uris from <c>asWebviewUri</c>
                    ///
                    /// Default to the root folders of the current workspace plus the extension's install directory.
                    ///
                    /// Pass in an empty array to disallow access to any local resources.
                    /// </summary>
                    abstract member localResourceRoots: ReadonlyArray<Uri> option with get
                    /// <summary>
                    /// Mappings of localhost ports used inside the webview.
                    ///
                    /// Port mapping allow webviews to transparently define how localhost ports are resolved. This can be used
                    /// to allow using a static localhost port inside the webview that is resolved to random port that a service is
                    /// running on.
                    ///
                    /// If a webview accesses localhost content, we recommend that you specify port mappings even if
                    /// the <c>webviewPort</c> and <c>extensionHostPort</c> ports are the same.
                    ///
                    /// *Note* that port mappings only work for <c>http</c> or <c>https</c> urls. Websocket urls (e.g. <c>ws://localhost:3000</c>)
                    /// cannot be mapped to another port.
                    /// </summary>
                    abstract member portMapping: ReadonlyArray<WebviewPortMapping> option with get

                module showOptions =

                    module U2 =

                        [<Global>]
                        [<AllowNullLiteral>]
                        type Case2
                            [<ParamObject; Emit("$0")>]
                            (
                                viewColumn: ViewColumn,
                                ?preserveFocus: bool
                            ) =

                            member val viewColumn : ViewColumn = nativeOnly with get
                            member val preserveFocus : bool option = nativeOnly with get

            module withProgress =

                type task<'R> =
                    delegate of progress: Progress<Exports.withProgress.task.progress> * token: CancellationToken -> Thenable<'R>

                module task =

                    [<Global>]
                    [<AllowNullLiteral>]
                    type progress
                        [<ParamObject; Emit("$0")>]
                        (
                            ?message: string,
                            ?increment: float
                        ) =

                        member val message : string option = nativeOnly with get, set
                        member val increment : float option = nativeOnly with get, set

            module registerWebviewViewProvider =

                [<Global>]
                [<AllowNullLiteral>]
                type options
                    [<ParamObject; Emit("$0")>]
                    (
                        ?webviewOptions: Exports.registerWebviewViewProvider.options.webviewOptions
                    ) =

                    member val webviewOptions : Exports.registerWebviewViewProvider.options.webviewOptions option = nativeOnly with get

                module options =

                    [<Global>]
                    [<AllowNullLiteral>]
                    type webviewOptions
                        [<ParamObject; Emit("$0")>]
                        (
                            ?retainContextWhenHidden: bool
                        ) =

                        member val retainContextWhenHidden : bool option = nativeOnly with get

            module registerCustomEditorProvider =

                [<Global>]
                [<AllowNullLiteral>]
                type options
                    [<ParamObject; Emit("$0")>]
                    (
                        ?webviewOptions: WebviewPanelOptions,
                        ?supportsMultipleEditorsPerDocument: bool
                    ) =

                    member val webviewOptions : WebviewPanelOptions option = nativeOnly with get
                    member val supportsMultipleEditorsPerDocument : bool option = nativeOnly with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeViewOptions<'T> =
        /// <summary>
        /// A data provider that provides tree data.
        /// </summary>
        abstract member treeDataProvider: TreeDataProvider<'T> with get, set
        /// <summary>
        /// Whether to show collapse all action or not.
        /// </summary>
        abstract member showCollapseAll: bool option with get, set
        /// <summary>
        /// Whether the tree supports multi-select. When the tree supports multi-select and a command is executed from the tree,
        /// the first argument to the command is the tree item that the command was executed on and the second argument is an
        /// array containing all selected tree items.
        /// </summary>
        abstract member canSelectMany: bool option with get, set
        /// <summary>
        /// An optional interface to implement drag and drop in the tree view.
        /// </summary>
        abstract member dragAndDropController: TreeDragAndDropController<'T> option with get, set
        /// <summary>
        /// By default, when the children of a tree item have already been fetched, child checkboxes are automatically managed based on the checked state of the parent tree item.
        /// If the tree item is collapsed by default (meaning that the children haven't yet been fetched) then child checkboxes will not be updated.
        /// To override this behavior and manage child and parent checkbox state in the extension, set this to <c>true</c>.
        ///
        /// Examples where <see href="TreeViewOptions.manageCheckboxStateManually">TreeViewOptions.manageCheckboxStateManually</see> is false, the default behavior:
        ///
        /// 1. A tree item is checked, then its children are fetched. The children will be checked.
        ///
        /// 2. A tree item's parent is checked. The tree item and all of it's siblings will be checked.
        ///   - [ ] Parent
        ///     - [ ] Child 1
        ///     - [ ] Child 2
        ///   When the user checks Parent, the tree will look like this:
        ///   - [x] Parent
        ///     - [x] Child 1
        ///     - [x] Child 2
        ///
        /// 3. A tree item and all of it's siblings are checked. The parent will be checked.
        ///   - [ ] Parent
        ///     - [ ] Child 1
        ///     - [ ] Child 2
        ///   When the user checks Child 1 and Child 2, the tree will look like this:
        ///   - [x] Parent
        ///     - [x] Child 1
        ///     - [x] Child 2
        ///
        /// 4. A tree item is unchecked. The parent will be unchecked.
        ///   - [x] Parent
        ///     - [x] Child 1
        ///     - [x] Child 2
        ///   When the user unchecks Child 1, the tree will look like this:
        ///   - [ ] Parent
        ///     - [ ] Child 1
        ///     - [x] Child 2
        /// </summary>
        abstract member manageCheckboxStateManually: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeViewExpansionEvent<'T> =
        /// <summary>
        /// Element that is expanded or collapsed.
        /// </summary>
        abstract member element: 'T with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeViewSelectionChangeEvent<'T> =
        /// <summary>
        /// Selected elements.
        /// </summary>
        abstract member selection: ReadonlyArray<'T> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeViewVisibilityChangeEvent =
        /// <summary>
        /// <c>true</c> if the <see href="TreeViewtree">view</see>" is visible otherwise <c>false</c>.
        /// </summary>
        abstract member visible: bool with get

    [<AllowNullLiteral>]
    [<Interface>]
    type DataTransferFile =
        /// <summary>
        /// The name of the file.
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// The full file path of the file.
        ///
        /// May be <c>undefined</c> on web.
        /// </summary>
        abstract member uri: Uri option with get
        /// <summary>
        /// The full file contents of the file.
        /// </summary>
        abstract member data: unit -> Thenable<JS.Uint8Array>

    /// <summary>
    /// Encapsulates data transferred during drag and drop operations.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DataTransferItem =
        /// <summary>
        /// Get a string representation of this item.
        ///
        /// If {@linkcode DataTransferItem.value} is an object, this returns the result of json stringifying {@linkcode DataTransferItem.value} value.
        /// </summary>
        abstract member asString: unit -> Thenable<string>
        /// <summary>
        /// Try getting the <see href="DataTransferFilefile">DataTransferFilefile</see> associated with this data transfer item.
        ///
        /// Note that the file object is only valid for the scope of the drag and drop operation.
        /// </summary>
        /// <returns>
        /// The file for the data transfer or <c>undefined</c> if the item is either not a file or the
        /// file data cannot be accessed.
        /// </returns>
        abstract member asFile: unit -> DataTransferFile option
        /// <summary>
        /// Custom data stored on this item.
        ///
        /// You can use <c>value</c> to share data across operations. The original object can be retrieved so long as the extension that
        /// created the <c>DataTransferItem</c> runs in the same extension host.
        /// </summary>
        abstract member value: obj with get

    /// <summary>
    /// A map containing a mapping of the mime type of the corresponding transferred data.
    ///
    /// Drag and drop controllers that implement <see href="TreeDragAndDropController.handleDrag<c>handleDrag</c>">TreeDragAndDropController.handleDrag<c>handleDrag</c></see> can add additional mime types to the
    /// data transfer. These additional mime types will only be included in the <c>handleDrop</c> when the drag was initiated from
    /// an element in the same drag and drop controller.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DataTransfer =
        inherit Iterable<string * DataTransferItem>
        /// <summary>
        /// Retrieves the data transfer item for a given mime type.
        /// </summary>
        /// <param name="mimeType">
        /// The mime type to get the data transfer item for, such as <c>text/plain</c> or <c>image/png</c>.
        /// Mimes type look ups are case-insensitive.
        ///
        /// Special mime types:
        /// - <c>text/uri-list</c> — A string with <c>toString()</c>ed Uris separated by <c>\r\n</c>. To specify a cursor position in the file,
        /// set the Uri's fragment to <c>L3,5</c>, where 3 is the line number and 5 is the column number.
        /// </param>
        abstract member get: mimeType: string -> DataTransferItem option
        /// <summary>
        /// Sets a mime type to data transfer item mapping.
        /// </summary>
        /// <param name="mimeType">
        /// The mime type to set the data for. Mimes types stored in lower case, with case-insensitive looks up.
        /// </param>
        /// <param name="value">
        /// The data transfer item for the given mime type.
        /// </param>
        abstract member set: mimeType: string * value: DataTransferItem -> unit
        /// <summary>
        /// Allows iteration through the data transfer items.
        /// </summary>
        /// <param name="callbackfn">
        /// Callback for iteration through the data transfer items.
        /// </param>
        /// <param name="thisArg">
        /// The <c>this</c> context used when invoking the handler function.
        /// </param>
        abstract member forEach: callbackfn: DataTransfer.forEach.callbackfn * ?thisArg: obj -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeDragAndDropController<'T> =
        /// <summary>
        /// The mime types that the <see href="TreeDragAndDropController.handleDrop<c>handleDrop</c>">TreeDragAndDropController.handleDrop<c>handleDrop</c></see> method of this <c>DragAndDropController</c> supports.
        /// This could be well-defined, existing, mime types, and also mime types defined by the extension.
        ///
        /// To support drops from trees, you will need to add the mime type of that tree.
        /// This includes drops from within the same tree.
        /// The mime type of a tree is recommended to be of the format <c>application/vnd.code.tree.<treeidlowercase></c>.
        ///
        /// Use the special <c>files</c> mime type to support all types of dropped files <see href="DataTransferFilefiles">DataTransferFilefiles</see>, regardless of the file's actual mime type.
        ///
        /// To learn the mime type of a dragged item:
        /// 1. Set up your <c>DragAndDropController</c>
        /// 2. Use the Developer: Set Log Level... command to set the level to "Debug"
        /// 3. Open the developer tools and drag the item with unknown mime type over your tree. The mime types will be logged to the developer console
        ///
        /// Note that mime types that cannot be sent to the extension will be omitted.
        /// </summary>
        abstract member dropMimeTypes: ReadonlyArray<string> with get
        /// <summary>
        /// The mime types that the <see href="TreeDragAndDropController.handleDrag<c>handleDrag</c>">TreeDragAndDropController.handleDrag<c>handleDrag</c></see> method of this <c>TreeDragAndDropController</c> may add to the tree data transfer.
        /// This could be well-defined, existing, mime types, and also mime types defined by the extension.
        ///
        /// The recommended mime type of the tree (<c>application/vnd.code.tree.<treeidlowercase></c>) will be automatically added.
        /// </summary>
        abstract member dragMimeTypes: ReadonlyArray<string> with get
        /// <summary>
        /// When the user starts dragging items from this <c>DragAndDropController</c>, <c>handleDrag</c> will be called.
        /// Extensions can use <c>handleDrag</c> to add their <see href="DataTransferItem<c>DataTransferItem</c>">DataTransferItem<c>DataTransferItem</c></see> items to the drag and drop.
        ///
        /// Mime types added in <c>handleDrag</c> won't be available outside the application.
        ///
        /// When the items are dropped on **another tree item** in **the same tree**, your <c>DataTransferItem</c> objects
        /// will be preserved. Use the recommended mime type for the tree (<c>application/vnd.code.tree.<treeidlowercase></c>) to add
        /// tree objects in a data transfer. See the documentation for <c>DataTransferItem</c> for how best to take advantage of this.
        ///
        /// To add a data transfer item that can be dragged into the editor, use the application specific mime type "text/uri-list".
        /// The data for "text/uri-list" should be a string with <c>toString()</c>ed Uris separated by <c>\r\n</c>. To specify a cursor position in the file,
        /// set the Uri's fragment to <c>L3,5</c>, where 3 is the line number and 5 is the column number.
        /// </summary>
        /// <param name="source">
        /// The source items for the drag and drop operation.
        /// </param>
        /// <param name="dataTransfer">
        /// The data transfer associated with this drag.
        /// </param>
        /// <param name="token">
        /// A cancellation token indicating that drag has been cancelled.
        /// </param>
        abstract member handleDrag: source: ReadonlyArray<'T> * dataTransfer: DataTransfer * token: CancellationToken -> U2<Thenable<unit>, unit>
        /// <summary>
        /// Called when a drag and drop action results in a drop on the tree that this <c>DragAndDropController</c> belongs to.
        ///
        /// Extensions should fire <see href="TreeDataProvider.onDidChangeTreeDataonDidChangeTreeData">TreeDataProvider.onDidChangeTreeDataonDidChangeTreeData</see> for any elements that need to be refreshed.
        /// </summary>
        /// <param name="target">
        /// The target tree element that the drop is occurring on. When undefined, the target is the root.
        /// </param>
        /// <param name="dataTransfer">
        /// The data transfer items of the source of the drag.
        /// </param>
        /// <param name="token">
        /// A cancellation token indicating that the drop has been cancelled.
        /// </param>
        abstract member handleDrop: target: 'T option * dataTransfer: DataTransfer * token: CancellationToken -> U2<Thenable<unit>, unit>

    [<AllowNullLiteral>]
    [<Interface>]
    type ViewBadge =
        /// <summary>
        /// A label to present in tooltip for the badge.
        /// </summary>
        abstract member tooltip: string with get
        /// <summary>
        /// The value to present in the badge.
        /// </summary>
        abstract member value: float with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeCheckboxChangeEvent<'T> =
        /// <summary>
        /// The items that were checked or unchecked.
        /// </summary>
        abstract member items: ReadonlyArray<'T * TreeItemCheckboxState> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeView<'T> =
        inherit Disposable
        /// <summary>
        /// Event that is fired when an element is expanded
        /// </summary>
        abstract member onDidExpandElement: Event<TreeViewExpansionEvent<'T>> with get
        /// <summary>
        /// Event that is fired when an element is collapsed
        /// </summary>
        abstract member onDidCollapseElement: Event<TreeViewExpansionEvent<'T>> with get
        /// <summary>
        /// Currently selected elements.
        /// </summary>
        abstract member selection: ReadonlyArray<'T> with get
        /// <summary>
        /// Event that is fired when the <see href="TreeView.selectionselection">TreeView.selectionselection</see> has changed
        /// </summary>
        abstract member onDidChangeSelection: Event<TreeViewSelectionChangeEvent<'T>> with get
        /// <summary>
        /// <c>true</c> if the <see href="TreeViewtree">view</see>" is visible otherwise <c>false</c>.
        /// </summary>
        abstract member visible: bool with get
        /// <summary>
        /// Event that is fired when <see href="TreeView.visiblevisibility">TreeView.visiblevisibility</see> has changed
        /// </summary>
        abstract member onDidChangeVisibility: Event<TreeViewVisibilityChangeEvent> with get
        /// <summary>
        /// An event to signal that an element or root has either been checked or unchecked.
        /// </summary>
        abstract member onDidChangeCheckboxState: Event<TreeCheckboxChangeEvent<'T>> with get
        /// <summary>
        /// An optional human-readable message that will be rendered in the view.
        /// Setting the message to null, undefined, or empty string will remove the message from the view.
        /// </summary>
        abstract member message: string option with get, set
        /// <summary>
        /// The tree view title is initially taken from the extension package.json
        /// Changes to the title property will be properly reflected in the UI in the title of the view.
        /// </summary>
        abstract member title: string option with get, set
        /// <summary>
        /// An optional human-readable description which is rendered less prominently in the title of the view.
        /// Setting the title description to null, undefined, or empty string will remove the description from the view.
        /// </summary>
        abstract member description: string option with get, set
        /// <summary>
        /// The badge to display for this TreeView.
        /// To remove the badge, set to undefined.
        /// </summary>
        abstract member badge: ViewBadge option with get, set
        /// <summary>
        /// Reveals the given element in the tree view.
        /// If the tree view is not visible then the tree view is shown and element is revealed.
        ///
        /// By default revealed element is selected.
        /// In order to not to select, set the option <c>select</c> to <c>false</c>.
        /// In order to focus, set the option <c>focus</c> to <c>true</c>.
        /// In order to expand the revealed element, set the option <c>expand</c> to <c>true</c>. To expand recursively set <c>expand</c> to the number of levels to expand.
        ///
        /// * *NOTE:* You can expand only to 3 levels maximum.
        /// * *NOTE:* The <see href="TreeDataProvider">TreeDataProvider</see> that the <c>TreeView</c> <see href="window.createTreeViewis">registered with</see>" with must implement <see href="TreeDataProvider.getParentgetParent">TreeDataProvider.getParentgetParent</see> method to access this API.
        /// </summary>
        abstract member reveal: element: 'T * ?options: TreeView.reveal.options -> Thenable<unit>

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeDataProvider<'T> =
        /// <summary>
        /// An optional event to signal that an element or root has changed.
        /// This will trigger the view to update the changed element/root and its children recursively (if shown).
        /// To signal that root has changed, do not pass any argument or pass <c>undefined</c> or <c>null</c>.
        /// </summary>
        abstract member onDidChangeTreeData: Event<U3<'T, ResizeArray<'T>, unit> option> option with get, set
        /// <summary>
        /// Get <see href="TreeItem">TreeItem</see> representation of the <c>element</c>
        /// </summary>
        /// <param name="element">
        /// The element for which <see href="TreeItem">TreeItem</see> representation is asked for.
        /// </param>
        /// <returns>
        /// TreeItem representation of the element.
        /// </returns>
        abstract member getTreeItem: element: 'T -> U2<TreeItem, Thenable<TreeItem>>
        /// <summary>
        /// Get the children of <c>element</c> or root if no element is passed.
        /// </summary>
        /// <param name="element">
        /// The element from which the provider gets children. Can be <c>undefined</c>.
        /// </param>
        /// <returns>
        /// Children of <c>element</c> or root if no element is passed.
        /// </returns>
        abstract member getChildren: ?element: 'T -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// Optional method to return the parent of <c>element</c>.
        /// Return <c>null</c> or <c>undefined</c> if <c>element</c> is a child of root.
        ///
        /// **NOTE:** This method should be implemented in order to access <see href="TreeView.revealreveal">TreeView.revealreveal</see> API.
        /// </summary>
        /// <param name="element">
        /// The element for which the parent has to be returned.
        /// </param>
        /// <returns>
        /// Parent of <c>element</c>.
        /// </returns>
        abstract member getParent: element: 'T -> ProviderResult<'T>
        /// <summary>
        /// Called on hover to resolve the <see href="TreeItem.tooltipTreeItem">TreeItem.tooltipTreeItem</see> property if it is undefined.
        /// Called on tree item click/open to resolve the <see href="TreeItem.commandTreeItem">TreeItem.commandTreeItem</see> property if it is undefined.
        /// Only properties that were undefined can be resolved in <c>resolveTreeItem</c>.
        /// Functionality may be expanded later to include being called to resolve other missing
        /// properties on selection and/or on open.
        ///
        /// Will only ever be called once per TreeItem.
        ///
        /// onDidChangeTreeData should not be triggered from within resolveTreeItem.
        ///
        /// *Note* that this function is called when tree items are already showing in the UI.
        /// Because of that, no property that changes the presentation (label, description, etc.)
        /// can be changed.
        /// </summary>
        /// <param name="item">
        /// Undefined properties of <c>item</c> should be set then <c>item</c> should be returned.
        /// </param>
        /// <param name="element">
        /// The object associated with the TreeItem.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved tree item or a thenable that resolves to such. It is OK to return the given
        /// <c>item</c>. When no result is returned, the given <c>item</c> will be used.
        /// </returns>
        abstract member resolveTreeItem: item: TreeItem * element: 'T * token: CancellationToken -> ProviderResult<TreeItem>

    /// <summary>
    /// A tree item is an UI element of the tree. Tree items are created by the <see href="TreeDataProviderdata">provider</see>".
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TreeItem =
        /// <summary>
        /// A human-readable string describing this item. When <c>falsy</c>, it is derived from <see href="TreeItem.resourceUriresourceUri">TreeItem.resourceUriresourceUri</see>.
        /// </summary>
        abstract member label: U2<string, TreeItemLabel> option with get, set
        /// <summary>
        /// Optional id for the tree item that has to be unique across tree. The id is used to preserve the selection and expansion state of the tree item.
        ///
        /// If not provided, an id is generated using the tree item's label. **Note** that when labels change, ids will change and that selection and expansion state cannot be kept stable anymore.
        /// </summary>
        abstract member id: string option with get, set
        /// <summary>
        /// The icon path or <see href="ThemeIcon">ThemeIcon</see> for the tree item.
        /// When <c>falsy</c>, <see href="ThemeIcon.FolderFolder">Theme Icon</see>" is assigned, if item is collapsible otherwise <see href="ThemeIcon.FileFile">Theme Icon</see>".
        /// When a file or folder <see href="ThemeIcon">ThemeIcon</see> is specified, icon is derived from the current file icon theme for the specified theme icon using <see href="TreeItem.resourceUriresourceUri">TreeItem.resourceUriresourceUri</see> (if provided).
        /// </summary>
        abstract member iconPath: U2<string, IconPath> option with get, set
        /// <summary>
        /// A human-readable string which is rendered less prominent.
        /// When <c>true</c>, it is derived from <see href="TreeItem.resourceUriresourceUri">TreeItem.resourceUriresourceUri</see> and when <c>falsy</c>, it is not shown.
        /// </summary>
        abstract member description: U2<string, bool> option with get, set
        /// <summary>
        /// A <see href="Uri">Uri</see> representing the resource associated with this item.
        ///
        /// When set, this property is used to automatically derive several item properties if they are not explicitly provided:
        /// - **Label**: Derived from the resource's file name when <see href="TreeItem.labellabel">TreeItem.labellabel</see> is not provided.
        /// - **Description**: Derived from the resource's path when <see href="TreeItem.descriptiondescription">TreeItem.descriptiondescription</see> is set to <c>true</c>.
        /// - **Icon**: Derived from the current file icon theme when <see href="TreeItem.iconPathiconPath">TreeItem.iconPathiconPath</see> is set to
        ///   <see href="ThemeIcon.File">ThemeIcon.File</see> or <see href="ThemeIcon.Folder">ThemeIcon.Folder</see>.
        /// </summary>
        abstract member resourceUri: Uri option with get, set
        /// <summary>
        /// The tooltip text when you hover over this item.
        /// </summary>
        abstract member tooltip: U2<string, MarkdownString> option option with get, set
        /// <summary>
        /// The <see href="Command">Command</see> that should be executed when the tree item is selected.
        ///
        /// Please use <c>vscode.open</c> or <c>vscode.diff</c> as command IDs when the tree item is opening
        /// something in the editor. Using these commands ensures that the resulting editor will
        /// appear consistent with how other built-in trees open editors.
        /// </summary>
        abstract member command: Command option with get, set
        /// <summary>
        /// <see href="TreeItemCollapsibleState">TreeItemCollapsibleState</see> of the tree item.
        /// </summary>
        abstract member collapsibleState: TreeItemCollapsibleState option with get, set
        /// <summary>
        /// Context value of the tree item. This can be used to contribute item specific actions in the tree.
        /// For example, a tree item is given a context value as <c>folder</c>. When contributing actions to <c>view/item/context</c>
        /// using <c>menus</c> extension point, you can specify context value for key <c>viewItem</c> in <c>when</c> expression like <c>viewItem == folder</c>.
        /// <code lang="json">
        /// "contributes": {
        ///   "menus": {
        ///     "view/item/context": [
        ///       {
        ///         "command": "extension.deleteFolder",
        ///         "when": "viewItem == folder"
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// This will show action <c>extension.deleteFolder</c> only for items with <c>contextValue</c> is <c>folder</c>.
        /// </summary>
        abstract member contextValue: string option with get, set
        /// <summary>
        /// Accessibility information used when screen reader interacts with this tree item.
        /// Generally, a TreeItem has no need to set the <c>role</c> of the accessibilityInformation;
        /// however, there are cases where a TreeItem is not displayed in a tree-like way where setting the <c>role</c> may make sense.
        /// </summary>
        abstract member accessibilityInformation: AccessibilityInformation option with get, set
        /// <summary>
        /// <see href="TreeItemCheckboxStateTreeItemCheckboxState">TreeItemCheckboxStateTreeItemCheckboxState</see> of the tree item.
        /// <see href="TreeDataProvider.onDidChangeTreeDataonDidChangeTreeData">TreeDataProvider.onDidChangeTreeDataonDidChangeTreeData</see> should be fired when <see href="TreeItem.checkboxStatecheckboxState">TreeItem.checkboxStatecheckboxState</see> changes.
        /// </summary>
        abstract member checkboxState: U2<TreeItemCheckboxState, TreeItem.checkboxState.U2.Case2> option with get, set

    [<RequireQualifiedAccess>]
    type TreeItemCollapsibleState =
        | None = 0
        | Collapsed = 1
        | Expanded = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type TreeItemLabel =
        /// <summary>
        /// A human-readable string describing the <see href="TreeItemTree">item</see>".
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// Ranges in the label to highlight. A range is defined as a tuple of two number where the
        /// first is the inclusive start index and the second the exclusive end index
        /// </summary>
        abstract member highlights: ResizeArray<float * float> option with get, set

    [<RequireQualifiedAccess>]
    type TreeItemCheckboxState =
        | Unchecked = 0
        | Checked = 1

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalOptions =
        /// <summary>
        /// A human-readable string which will be used to represent the terminal in the UI.
        /// </summary>
        abstract member name: string option with get, set
        /// <summary>
        /// A path to a custom shell executable to be used in the terminal.
        /// </summary>
        abstract member shellPath: string option with get, set
        /// <summary>
        /// Args for the custom shell executable. A string can be used on Windows only which allows
        /// specifying shell args in [command-line format](https://msdn.microsoft.com/en-au/08dfcab2-eb6e-49a4-80eb-87d4076c98c6).
        /// </summary>
        abstract member shellArgs: U2<ResizeArray<string>, string> option with get, set
        /// <summary>
        /// A path or Uri for the current working directory to be used for the terminal.
        /// </summary>
        abstract member cwd: U2<string, Uri> option with get, set
        /// <summary>
        /// Object with environment variables that will be added to the editor process.
        /// </summary>
        abstract member env: TerminalOptions.env option with get, set
        /// <summary>
        /// Whether the terminal process environment should be exactly as provided in
        /// <c>TerminalOptions.env</c>. When this is false (default), the environment will be based on the
        /// window's environment and also apply configured platform settings like
        /// <c>terminal.integrated.env.windows</c> on top. When this is true, the complete environment
        /// must be provided as nothing will be inherited from the process or any configuration.
        /// </summary>
        abstract member strictEnv: bool option with get, set
        /// <summary>
        /// When enabled the terminal will run the process as normal but not be surfaced to the user
        /// until <c>Terminal.show</c> is called. The typical usage for this is when you need to run
        /// something that may need interactivity but only want to tell the user about it when
        /// interaction is needed. Note that the terminals will still be exposed to all extensions
        /// as normal. The hidden terminals will not be restored when the workspace is next opened.
        /// </summary>
        abstract member hideFromUser: bool option with get, set
        /// <summary>
        /// A message to write to the terminal on first launch, note that this is not sent to the
        /// process but, rather written directly to the terminal. This supports escape sequences such
        /// a setting text style.
        /// </summary>
        abstract member message: string option with get, set
        /// <summary>
        /// The icon path or <see href="ThemeIcon">ThemeIcon</see> for the terminal.
        /// </summary>
        abstract member iconPath: IconPath option with get, set
        /// <summary>
        /// The icon <see href="ThemeColor">ThemeColor</see> for the terminal.
        /// The <c>terminal.ansi*</c> theme keys are
        /// recommended for the best contrast and consistency across themes.
        /// </summary>
        abstract member color: ThemeColor option with get, set
        /// <summary>
        /// The <see href="TerminalLocation">TerminalLocation</see> or <see href="TerminalEditorLocationOptions">TerminalEditorLocationOptions</see> or <see href="TerminalSplitLocationOptions">TerminalSplitLocationOptions</see> for the terminal.
        /// </summary>
        abstract member location: U3<TerminalLocation, TerminalEditorLocationOptions, TerminalSplitLocationOptions> option with get, set
        /// <summary>
        /// Opt-out of the default terminal persistence on restart and reload.
        /// This will only take effect when <c>terminal.integrated.enablePersistentSessions</c> is enabled.
        /// </summary>
        abstract member isTransient: bool option with get, set
        /// <summary>
        /// The nonce to use to verify shell integration sequences are coming from a trusted source.
        /// An example impact of UX of this is if the command line is reported with a nonce, it will
        /// not need to verify with the user that the command line is correct before rerunning it
        /// via the [shell integration command decoration](https://code.visualstudio.com/docs/terminal/shell-integration#_command-decorations-and-the-overview-ruler).
        ///
        /// This should be used if the terminal includes [custom shell integration support](https://code.visualstudio.com/docs/terminal/shell-integration#_supported-escape-sequences).
        /// It should be set to a random GUID which will then set the <c>VSCODE_NONCE</c> environment
        /// variable. Inside the shell, this should then be removed from the environment so as to
        /// protect it from general access. Once that is done it can be passed through in the
        /// relevant sequences to make them trusted.
        /// </summary>
        abstract member shellIntegrationNonce: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ExtensionTerminalOptions =
        /// <summary>
        /// A human-readable string which will be used to represent the terminal in the UI.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// An implementation of <see href="Pseudoterminal">Pseudoterminal</see> that allows an extension to
        /// control a terminal.
        /// </summary>
        abstract member pty: Pseudoterminal with get, set
        /// <summary>
        /// The icon path or <see href="ThemeIcon">ThemeIcon</see> for the terminal.
        /// </summary>
        abstract member iconPath: IconPath option with get, set
        /// <summary>
        /// The icon <see href="ThemeColor">ThemeColor</see> for the terminal.
        /// The standard <c>terminal.ansi*</c> theme keys are
        /// recommended for the best contrast and consistency across themes.
        /// </summary>
        abstract member color: ThemeColor option with get, set
        /// <summary>
        /// The <see href="TerminalLocation">TerminalLocation</see> or <see href="TerminalEditorLocationOptions">TerminalEditorLocationOptions</see> or <see href="TerminalSplitLocationOptions">TerminalSplitLocationOptions</see> for the terminal.
        /// </summary>
        abstract member location: U3<TerminalLocation, TerminalEditorLocationOptions, TerminalSplitLocationOptions> option with get, set
        /// <summary>
        /// Opt-out of the default terminal persistence on restart and reload.
        /// This will only take effect when <c>terminal.integrated.enablePersistentSessions</c> is enabled.
        /// </summary>
        abstract member isTransient: bool option with get, set
        /// <summary>
        /// The nonce to use to verify shell integration sequences are coming from a trusted source.
        /// An example impact of UX of this is if the command line is reported with a nonce, it will
        /// not need to verify with the user that the command line is correct before rerunning it
        /// via the [shell integration command decoration](https://code.visualstudio.com/docs/terminal/shell-integration#_command-decorations-and-the-overview-ruler).
        ///
        /// This should be used if the terminal includes [custom shell integration support](https://code.visualstudio.com/docs/terminal/shell-integration#_supported-escape-sequences).
        /// It should be set to a random GUID. Inside the <see href="Pseudoterminal">Pseudoterminal</see> implementation, this value
        /// can be passed through in the relevant sequences to make them trusted.
        /// </summary>
        abstract member shellIntegrationNonce: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type Pseudoterminal =
        /// <summary>
        /// An event that when fired will write data to the terminal. Unlike
        /// <see href="Terminal.sendText">Terminal.sendText</see> which sends text to the underlying child
        /// pseudo-device (the child), this will write the text to parent pseudo-device (the
        /// _terminal_ itself).
        ///
        /// Note writing <c>\n</c> will just move the cursor down 1 row, you need to write <c>\r</c> as well
        /// to move the cursor to the left-most cell.
        ///
        /// Events fired before <see href="Pseudoterminal.open">Pseudoterminal.open</see> is called will be be ignored.
        ///
        /// **Example:** Write red text to the terminal
        /// <code lang="typescript">
        /// const writeEmitter = new vscode.EventEmitter<string>();
        /// const pty: vscode.Pseudoterminal = {
        ///   onDidWrite: writeEmitter.event,
        ///   open: () => writeEmitter.fire('\x1b[31mHello world\x1b[0m'),
        ///   close: () => {}
        /// };
        /// vscode.window.createTerminal({ name: 'My terminal', pty });
        /// </code>
        ///
        /// **Example:** Move the cursor to the 10th row and 20th column and write an asterisk
        /// <code lang="typescript">
        /// writeEmitter.fire('\x1b[10;20H*');
        /// </code>
        /// </summary>
        abstract member onDidWrite: Event<string> with get, set
        /// <summary>
        /// An event that when fired allows overriding the <see href="Pseudoterminal.setDimensionsdimensions">Pseudoterminal.setDimensionsdimensions</see> of the
        /// terminal. Note that when set, the overridden dimensions will only take effect when they
        /// are lower than the actual dimensions of the terminal (ie. there will never be a scroll
        /// bar). Set to <c>undefined</c> for the terminal to go back to the regular dimensions (fit to
        /// the size of the panel).
        ///
        /// Events fired before <see href="Pseudoterminal.open">Pseudoterminal.open</see> is called will be be ignored.
        ///
        /// **Example:** Override the dimensions of a terminal to 20 columns and 10 rows
        /// <code lang="typescript">
        /// const dimensionsEmitter = new vscode.EventEmitter<vscode.TerminalDimensions>();
        /// const pty: vscode.Pseudoterminal = {
        ///   onDidWrite: writeEmitter.event,
        ///   onDidOverrideDimensions: dimensionsEmitter.event,
        ///   open: () => {
        ///     dimensionsEmitter.fire({
        ///       columns: 20,
        ///       rows: 10
        ///     });
        ///   },
        ///   close: () => {}
        /// };
        /// vscode.window.createTerminal({ name: 'My terminal', pty });
        /// </code>
        /// </summary>
        abstract member onDidOverrideDimensions: Event<TerminalDimensions option> option with get, set
        /// <summary>
        /// An event that when fired will signal that the pty is closed and dispose of the terminal.
        ///
        /// Events fired before <see href="Pseudoterminal.open">Pseudoterminal.open</see> is called will be be ignored.
        ///
        /// A number can be used to provide an exit code for the terminal. Exit codes must be
        /// positive and a non-zero exit codes signals failure which shows a notification for a
        /// regular terminal and allows dependent tasks to proceed when used with the
        /// <c>CustomExecution</c> API.
        ///
        /// **Example:** Exit the terminal when "y" is pressed, otherwise show a notification.
        /// <code lang="typescript">
        /// const writeEmitter = new vscode.EventEmitter<string>();
        /// const closeEmitter = new vscode.EventEmitter<void>();
        /// const pty: vscode.Pseudoterminal = {
        ///   onDidWrite: writeEmitter.event,
        ///   onDidClose: closeEmitter.event,
        ///   open: () => writeEmitter.fire('Press y to exit successfully'),
        ///   close: () => {},
        ///   handleInput: data => {
        ///     if (data !== 'y') {
        ///       vscode.window.showInformationMessage('Something went wrong');
        ///     }
        ///     closeEmitter.fire();
        ///   }
        /// };
        /// const terminal = vscode.window.createTerminal({ name: 'Exit example', pty });
        /// terminal.show(true);
        /// </code>
        /// </summary>
        abstract member onDidClose: Event<U2<unit, float>> option with get, set
        /// <summary>
        /// An event that when fired allows changing the name of the terminal.
        ///
        /// Events fired before <see href="Pseudoterminal.open">Pseudoterminal.open</see> is called will be be ignored.
        ///
        /// **Example:** Change the terminal name to "My new terminal".
        /// <code lang="typescript">
        /// const writeEmitter = new vscode.EventEmitter<string>();
        /// const changeNameEmitter = new vscode.EventEmitter<string>();
        /// const pty: vscode.Pseudoterminal = {
        ///   onDidWrite: writeEmitter.event,
        ///   onDidChangeName: changeNameEmitter.event,
        ///   open: () => changeNameEmitter.fire('My new terminal'),
        ///   close: () => {}
        /// };
        /// vscode.window.createTerminal({ name: 'My terminal', pty });
        /// </code>
        /// </summary>
        abstract member onDidChangeName: Event<string> option with get, set
        /// <summary>
        /// Implement to handle when the pty is open and ready to start firing events.
        /// </summary>
        /// <param name="initialDimensions">
        /// The dimensions of the terminal, this will be undefined if the
        /// terminal panel has not been opened before this is called.
        /// </param>
        abstract member ``open``: initialDimensions: TerminalDimensions option -> unit
        /// <summary>
        /// Implement to handle when the terminal is closed by an act of the user.
        /// </summary>
        abstract member close: unit -> unit
        /// <summary>
        /// Implement to handle incoming keystrokes in the terminal or when an extension calls
        /// <see href="Terminal.sendText">Terminal.sendText</see>. <c>data</c> contains the keystrokes/text serialized into
        /// their corresponding VT sequence representation.
        /// </summary>
        /// <param name="data">
        /// The incoming data.
        ///
        /// **Example:** Echo input in the terminal. The sequence for enter (<c>\r</c>) is translated to
        /// CRLF to go to a new line and move the cursor to the start of the line.
        /// <code lang="typescript">
        /// const writeEmitter = new vscode.EventEmitter<string>();
        /// const pty: vscode.Pseudoterminal = {
        /// onDidWrite: writeEmitter.event,
        /// open: () => {},
        /// close: () => {},
        /// handleInput: data => writeEmitter.fire(data === '\r' ? '\r\n' : data)
        /// };
        /// vscode.window.createTerminal({ name: 'Local echo', pty });
        /// </code>
        /// </param>
        abstract member handleInput: data: string -> unit
        /// <summary>
        /// Implement to handle when the number of rows and columns that fit into the terminal panel
        /// changes, for example when font size changes or when the panel is resized. The initial
        /// state of a terminal's dimensions should be treated as <c>undefined</c> until this is triggered
        /// as the size of a terminal isn't known until it shows up in the user interface.
        ///
        /// When dimensions are overridden by
        /// <see href="Pseudoterminal.onDidOverrideDimensionsonDidOverrideDimensions">Pseudoterminal.onDidOverrideDimensionsonDidOverrideDimensions</see>, <c>setDimensions</c> will
        /// continue to be called with the regular panel dimensions, allowing the extension continue
        /// to react dimension changes.
        /// </summary>
        /// <param name="dimensions">
        /// The new dimensions.
        /// </param>
        abstract member setDimensions: dimensions: TerminalDimensions -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalDimensions =
        /// <summary>
        /// The number of columns in the terminal.
        /// </summary>
        abstract member columns: float with get
        /// <summary>
        /// The number of rows in the terminal.
        /// </summary>
        abstract member rows: float with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TerminalExitStatus =
        /// <summary>
        /// The exit code that a terminal exited with, it can have the following values:
        /// - Zero: the terminal process or custom execution succeeded.
        /// - Non-zero: the terminal process or custom execution failed.
        /// - <c>undefined</c>: the user forcibly closed the terminal or a custom execution exited
        ///   without providing an exit code.
        /// </summary>
        abstract member code: float option with get
        /// <summary>
        /// The reason that triggered the exit of a terminal.
        /// </summary>
        abstract member reason: TerminalExitReason with get

    [<RequireQualifiedAccess>]
    type TerminalExitReason =
        | Unknown = 0
        | Shutdown = 1
        | Process = 2
        | User = 3
        | Extension = 4

    [<RequireQualifiedAccess>]
    type EnvironmentVariableMutatorType =
        | Replace = 1
        | Append = 2
        | Prepend = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type EnvironmentVariableMutatorOptions =
        /// <summary>
        /// Apply to the environment just before the process is created. Defaults to false.
        /// </summary>
        abstract member applyAtProcessCreation: bool option with get, set
        /// <summary>
        /// Apply to the environment in the shell integration script. Note that this _will not_ apply
        /// the mutator if shell integration is disabled or not working for some reason. Defaults to
        /// false.
        /// </summary>
        abstract member applyAtShellIntegration: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type EnvironmentVariableMutator =
        /// <summary>
        /// The type of mutation that will occur to the variable.
        /// </summary>
        abstract member ``type``: EnvironmentVariableMutatorType with get
        /// <summary>
        /// The value to use for the variable.
        /// </summary>
        abstract member value: string with get
        /// <summary>
        /// Options applied to the mutator.
        /// </summary>
        abstract member options: EnvironmentVariableMutatorOptions with get

    [<AllowNullLiteral>]
    [<Interface>]
    type EnvironmentVariableCollection =
        inherit Iterable<string * EnvironmentVariableMutator>
        /// <summary>
        /// Whether the collection should be cached for the workspace and applied to the terminal
        /// across window reloads. When true the collection will be active immediately such when the
        /// window reloads. Additionally, this API will return the cached version if it exists. The
        /// collection will be invalidated when the extension is uninstalled or when the collection
        /// is cleared. Defaults to true.
        /// </summary>
        abstract member persistent: bool with get, set
        /// <summary>
        /// A description for the environment variable collection, this will be used to describe the
        /// changes in the UI.
        /// </summary>
        abstract member description: U2<string, MarkdownString> option with get, set
        /// <summary>
        /// Replace an environment variable with a value.
        ///
        /// Note that an extension can only make a single change to any one variable, so this will
        /// overwrite any previous calls to replace, append or prepend.
        /// </summary>
        /// <param name="variable">
        /// The variable to replace.
        /// </param>
        /// <param name="value">
        /// The value to replace the variable with.
        /// </param>
        /// <param name="options">
        /// Options applied to the mutator, when no options are provided this will
        /// default to <c>{ applyAtProcessCreation: true }</c>.
        /// </param>
        abstract member replace: variable: string * value: string * ?options: EnvironmentVariableMutatorOptions -> unit
        /// <summary>
        /// Append a value to an environment variable.
        ///
        /// Note that an extension can only make a single change to any one variable, so this will
        /// overwrite any previous calls to replace, append or prepend.
        /// </summary>
        /// <param name="variable">
        /// The variable to append to.
        /// </param>
        /// <param name="value">
        /// The value to append to the variable.
        /// </param>
        /// <param name="options">
        /// Options applied to the mutator, when no options are provided this will
        /// default to <c>{ applyAtProcessCreation: true }</c>.
        /// </param>
        abstract member append: variable: string * value: string * ?options: EnvironmentVariableMutatorOptions -> unit
        /// <summary>
        /// Prepend a value to an environment variable.
        ///
        /// Note that an extension can only make a single change to any one variable, so this will
        /// overwrite any previous calls to replace, append or prepend.
        /// </summary>
        /// <param name="variable">
        /// The variable to prepend.
        /// </param>
        /// <param name="value">
        /// The value to prepend to the variable.
        /// </param>
        /// <param name="options">
        /// Options applied to the mutator, when no options are provided this will
        /// default to <c>{ applyAtProcessCreation: true }</c>.
        /// </param>
        abstract member prepend: variable: string * value: string * ?options: EnvironmentVariableMutatorOptions -> unit
        /// <summary>
        /// Gets the mutator that this collection applies to a variable, if any.
        /// </summary>
        /// <param name="variable">
        /// The variable to get the mutator for.
        /// </param>
        abstract member get: variable: string -> EnvironmentVariableMutator option
        /// <summary>
        /// Iterate over each mutator in this collection.
        /// </summary>
        /// <param name="callback">
        /// Function to execute for each entry.
        /// </param>
        /// <param name="thisArg">
        /// The <c>this</c> context used when invoking the handler function.
        /// </param>
        abstract member forEach: callback: EnvironmentVariableCollection.forEach.callback * ?thisArg: obj -> unit
        /// <summary>
        /// Deletes this collection's mutator for a variable.
        /// </summary>
        /// <param name="variable">
        /// The variable to delete the mutator for.
        /// </param>
        abstract member delete: variable: string -> unit
        /// <summary>
        /// Clears all mutators from this collection.
        /// </summary>
        abstract member clear: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type GlobalEnvironmentVariableCollection =
        inherit EnvironmentVariableCollection
        /// <summary>
        /// Gets scope-specific environment variable collection for the extension. This enables alterations to
        /// terminal environment variables solely within the designated scope, and is applied in addition to (and
        /// after) the global collection.
        ///
        /// Each object obtained through this method is isolated and does not impact objects for other scopes,
        /// including the global collection.
        /// </summary>
        /// <param name="scope">
        /// The scope to which the environment variable collection applies to.
        ///
        /// If a scope parameter is omitted, collection applicable to all relevant scopes for that parameter is
        /// returned. For instance, if the 'workspaceFolder' parameter is not specified, the collection that applies
        /// across all workspace folders will be returned.
        /// </param>
        /// <returns>
        /// Environment variable collection for the passed in scope.
        /// </returns>
        abstract member getScoped: scope: EnvironmentVariableScope -> EnvironmentVariableCollection

    [<AllowNullLiteral>]
    [<Interface>]
    type EnvironmentVariableScope =
        /// <summary>
        /// Any specific workspace folder to get collection for.
        /// </summary>
        abstract member workspaceFolder: WorkspaceFolder option with get, set

    [<RequireQualifiedAccess>]
    type ProgressLocation =
        | SourceControl = 1
        | Window = 10
        | Notification = 15

    [<AllowNullLiteral>]
    [<Interface>]
    type ProgressOptions =
        /// <summary>
        /// The location at which progress should show.
        /// </summary>
        abstract member location: U2<ProgressLocation, ProgressOptions.location.U2.Case2> with get, set
        /// <summary>
        /// A human-readable string which will be used to describe the
        /// operation.
        /// </summary>
        abstract member title: string option with get, set
        /// <summary>
        /// Controls if a cancel button should show to allow the user to
        /// cancel the long running operation.  Note that currently only
        /// <c>ProgressLocation.Notification</c> is supporting to show a cancel
        /// button.
        /// </summary>
        abstract member cancellable: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type QuickInput =
        /// <summary>
        /// An optional title for the input UI.
        /// </summary>
        abstract member title: string option with get, set
        /// <summary>
        /// An optional current step count for multi-step input flows.
        /// </summary>
        abstract member step: float option with get, set
        /// <summary>
        /// An optional total step count for multi-step input flows.
        /// </summary>
        abstract member totalSteps: float option with get, set
        /// <summary>
        /// Determines if the UI should allow for user input. Defaults to <c>true</c>.
        ///
        /// Change this to <c>false</c>, for example, while validating user input or loading data for the next
        /// step in user input.
        /// </summary>
        abstract member enabled: bool with get, set
        /// <summary>
        /// Determines if the UI should show a progress indicator. Defaults to <c>false</c>.
        ///
        /// Change this to <c>true</c>, for example, while loading more data or validating user input.
        /// </summary>
        abstract member busy: bool with get, set
        /// <summary>
        /// Determines if the UI should stay open even when losing UI focus. Defaults to <c>false</c>.
        /// This setting is ignored on iPad and is always <c>false</c>.
        /// </summary>
        abstract member ignoreFocusOut: bool with get, set
        /// <summary>
        /// Makes the input UI visible in its current configuration.
        ///
        /// Any other input UI will first fire an <see href="QuickInput.onDidHideonDidHide">QuickInput.onDidHideonDidHide</see> event.
        /// </summary>
        abstract member show: unit -> unit
        /// <summary>
        /// Hides this input UI.
        ///
        /// This will also fire an <see href="QuickInput.onDidHideonDidHide">QuickInput.onDidHideonDidHide</see> event.
        /// </summary>
        abstract member hide: unit -> unit
        /// <summary>
        /// An event signaling when this input UI is hidden.
        ///
        /// There are several reasons why this UI might have to be hidden and the extension will be notified
        /// through <see href="QuickInput.onDidHideonDidHide">QuickInput.onDidHideonDidHide</see>. Examples include: an explicit call to
        /// <see href="QuickInput.hidehide">QuickInput.hidehide</see>, the user pressing Esc, some other input UI opening, etc.
        /// </summary>
        abstract member onDidHide: Event<unit> with get
        /// <summary>
        /// Dispose of this input UI and any associated resources.
        ///
        /// If it is still visible, it is first hidden. After this call the input UI is no longer functional
        /// and no additional methods or properties on it should be accessed. Instead a new input UI should
        /// be created.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type QuickPick<'T when 'T :> QuickPickItem> =
        inherit QuickInput
        /// <summary>
        /// The current value of the filter text.
        /// </summary>
        abstract member value: string with get, set
        /// <summary>
        /// Optional placeholder text displayed in the filter text box when no value has been entered.
        /// </summary>
        abstract member placeholder: string option with get, set
        /// <summary>
        /// Optional text that provides instructions or context to the user.
        ///
        /// The prompt is displayed below the input box and above the list of items.
        /// </summary>
        abstract member prompt: string option with get, set
        /// <summary>
        /// An event signaling when the value of the filter text has changed.
        /// </summary>
        abstract member onDidChangeValue: Event<string> with get
        /// <summary>
        /// An event signaling when the user indicated acceptance of the selected item(s).
        /// </summary>
        abstract member onDidAccept: Event<unit> with get
        /// <summary>
        /// Buttons for actions in the UI.
        /// </summary>
        abstract member buttons: ReadonlyArray<QuickInputButton> with get, set
        /// <summary>
        /// An event signaling when a button was triggered.
        ///
        /// This event fires for buttons stored in the <see href="QuickPick.buttonsbuttons">QuickPick.buttonsbuttons</see> array. This event does
        /// not fire for buttons on a <see href="QuickPickItem">QuickPickItem</see>.
        /// </summary>
        abstract member onDidTriggerButton: Event<QuickInputButton> with get
        /// <summary>
        /// An event signaling when a button in a particular <see href="QuickPickItem">QuickPickItem</see> was triggered.
        ///
        /// This event does not fire for buttons in the title bar which are part of <see href="QuickPick.buttonsbuttons">QuickPick.buttonsbuttons</see>.
        /// </summary>
        abstract member onDidTriggerItemButton: Event<QuickPickItemButtonEvent<'T>> with get
        /// <summary>
        /// Items to pick from. This can be read and updated by the extension.
        /// </summary>
        abstract member items: ReadonlyArray<'T> with get, set
        /// <summary>
        /// Determines if multiple items can be selected at the same time. Defaults to <c>false</c>.
        /// </summary>
        abstract member canSelectMany: bool with get, set
        /// <summary>
        /// Determines if the filter text should also be matched against the <see href="QuickPickItem.descriptiondescription">QuickPickItem.descriptiondescription</see> of the items. Defaults to <c>false</c>.
        /// </summary>
        abstract member matchOnDescription: bool with get, set
        /// <summary>
        /// Determines if the filter text should also be matched against the <see href="QuickPickItem.detaildetail">QuickPickItem.detaildetail</see> of the items. Defaults to <c>false</c>.
        /// </summary>
        abstract member matchOnDetail: bool with get, set
        /// <summary>
        /// Determines if the scroll position is maintained when the quick pick items are updated. Defaults to <c>false</c>.
        /// </summary>
        abstract member keepScrollPosition: bool option with get, set
        /// <summary>
        /// Active items. This can be read and updated by the extension.
        /// </summary>
        abstract member activeItems: ReadonlyArray<'T> with get, set
        /// <summary>
        /// An event signaling when the active items have changed.
        /// </summary>
        abstract member onDidChangeActive: Event<ReadonlyArray<'T>> with get
        /// <summary>
        /// Selected items. This can be read and updated by the extension.
        /// </summary>
        abstract member selectedItems: ReadonlyArray<'T> with get, set
        /// <summary>
        /// An event signaling when the selected items have changed.
        /// </summary>
        abstract member onDidChangeSelection: Event<ReadonlyArray<'T>> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type InputBox =
        inherit QuickInput
        /// <summary>
        /// The current input value.
        /// </summary>
        abstract member value: string with get, set
        /// <summary>
        /// Selection range in the input value.
        ///
        /// Defined as tuple of two numbers where the first is the inclusive start index and the second the
        /// exclusive end index. When <c>undefined</c> the whole pre-filled value will be selected, when empty
        /// (start equals end) only the cursor will be set, otherwise the defined range will be selected.
        ///
        /// This property does not get updated when the user types or makes a selection, but it can be updated
        /// by the extension.
        /// </summary>
        abstract member valueSelection: float * float option with get, set
        /// <summary>
        /// Optional placeholder text shown when no value has been input.
        /// </summary>
        abstract member placeholder: string option with get, set
        /// <summary>
        /// Determines if the input value should be hidden. Defaults to <c>false</c>.
        /// </summary>
        abstract member password: bool with get, set
        /// <summary>
        /// An event signaling when the value has changed.
        /// </summary>
        abstract member onDidChangeValue: Event<string> with get
        /// <summary>
        /// An event signaling when the user indicated acceptance of the input value.
        /// </summary>
        abstract member onDidAccept: Event<unit> with get
        /// <summary>
        /// Buttons for actions in the UI.
        /// </summary>
        abstract member buttons: ReadonlyArray<QuickInputButton> with get, set
        /// <summary>
        /// An event signaling when a button was triggered.
        /// </summary>
        abstract member onDidTriggerButton: Event<QuickInputButton> with get
        /// <summary>
        /// An optional prompt text providing some ask or explanation to the user.
        /// </summary>
        abstract member prompt: string option with get, set
        /// <summary>
        /// An optional validation message indicating a problem with the current input value.
        ///
        /// By setting a string, the InputBox will use a default <see href="InputBoxValidationSeverity">InputBoxValidationSeverity</see> of Error.
        /// Returning <c>undefined</c> clears the validation message.
        /// </summary>
        abstract member validationMessage: U2<string, InputBoxValidationMessage> option with get, set

    [<RequireQualifiedAccess>]
    type QuickInputButtonLocation =
        | Title = 1
        | Inline = 2
        | Input = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type QuickInputButton =
        /// <summary>
        /// The icon for the button.
        /// </summary>
        abstract member iconPath: IconPath with get
        /// <summary>
        /// An optional tooltip displayed when hovering over the button.
        /// </summary>
        abstract member tooltip: string option with get
        /// <summary>
        /// The location where the button should be rendered.
        ///
        /// Defaults to <see href="QuickInputButtonLocation.Title">QuickInputButtonLocation.Title</see>.
        ///
        /// **Note:** This property is ignored if the button was added to a <see href="QuickPickItem">QuickPickItem</see>.
        /// </summary>
        abstract member location: QuickInputButtonLocation option with get, set
        /// <summary>
        /// When present, indicates that the button is a toggle button that can be checked or unchecked.
        /// </summary>
        abstract member toggle: QuickInputButton.toggle option with get

    /// <summary>
    /// Predefined buttons for <see href="QuickPick">QuickPick</see> and <see href="InputBox">InputBox</see>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type QuickInputButtons =
        /// <summary>
        /// A predefined back button for <see href="QuickPick">QuickPick</see> and <see href="InputBox">InputBox</see>.
        ///
        /// This button should be used for consistency when a navigation back button is needed. It comes
        /// with a predefined icon, tooltip, and location.
        /// </summary>
        static member inline Back
            with get () : QuickInputButton =
                emitJsExpr () $$"""
import { QuickInputButtons } from "vscode";
QuickInputButtons.Back"""

    [<AllowNullLiteral>]
    [<Interface>]
    type QuickPickItemButtonEvent<'T when 'T :> QuickPickItem> =
        /// <summary>
        /// The button that was pressed.
        /// </summary>
        abstract member button: QuickInputButton with get
        /// <summary>
        /// The item that the button belongs to.
        /// </summary>
        abstract member item: 'T with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TextDocumentContentChangeEvent =
        /// <summary>
        /// The range that got replaced.
        /// </summary>
        abstract member range: Range with get
        /// <summary>
        /// The offset of the range that got replaced.
        /// </summary>
        abstract member rangeOffset: float with get
        /// <summary>
        /// The length of the range that got replaced.
        /// </summary>
        abstract member rangeLength: float with get
        /// <summary>
        /// The new text for the range.
        /// </summary>
        abstract member text: string with get

    [<RequireQualifiedAccess>]
    type TextDocumentChangeReason =
        | Undo = 1
        | Redo = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type TextDocumentChangeEvent =
        /// <summary>
        /// The affected document.
        /// </summary>
        abstract member document: TextDocument with get
        /// <summary>
        /// An array of content changes.
        /// </summary>
        abstract member contentChanges: ReadonlyArray<TextDocumentContentChangeEvent> with get
        /// <summary>
        /// The reason why the document was changed.
        /// Is <c>undefined</c> if the reason is not known.
        /// </summary>
        abstract member reason: TextDocumentChangeReason option with get

    [<RequireQualifiedAccess>]
    type TextDocumentSaveReason =
        | Manual = 1
        | AfterDelay = 2
        | FocusOut = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type TextDocumentWillSaveEvent =
        /// <summary>
        /// The document that will be saved.
        /// </summary>
        abstract member document: TextDocument with get
        /// <summary>
        /// The reason why save was triggered.
        /// </summary>
        abstract member reason: TextDocumentSaveReason with get
        /// <summary>
        /// Allows to pause the event loop and to apply <see href="TextEditpre-save-edits">TextEditpre-save-edits</see>.
        /// Edits of subsequent calls to this function will be applied in order. The
        /// edits will be *ignored* if concurrent modifications of the document happened.
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillSaveTextDocument(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event loop until the provided thenable resolved.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that resolves to <see href="TextEdit">pre-save-edits</see>".
        /// </param>
        abstract member waitUntil: thenable: Thenable<ReadonlyArray<TextEdit>> -> unit
        /// <summary>
        /// Allows to pause the event loop and to apply <see href="TextEditpre-save-edits">TextEditpre-save-edits</see>.
        /// Edits of subsequent calls to this function will be applied in order. The
        /// edits will be *ignored* if concurrent modifications of the document happened.
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillSaveTextDocument(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event loop until the provided thenable resolved.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that delays saving.
        /// </param>
        abstract member waitUntil: thenable: Thenable<obj> -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type FileWillCreateEvent =
        /// <summary>
        /// A cancellation token.
        /// </summary>
        abstract member token: CancellationToken with get
        /// <summary>
        /// The files that are going to be created.
        /// </summary>
        abstract member files: ReadonlyArray<Uri> with get
        /// <summary>
        /// Allows to pause the event and to apply a <see href="WorkspaceEditworkspace">edit</see>".
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillCreateFiles(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event until the provided thenable resolves.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that delays saving.
        /// </param>
        abstract member waitUntil: thenable: Thenable<WorkspaceEdit> -> unit
        /// <summary>
        /// Allows to pause the event and to apply a <see href="WorkspaceEditworkspace">edit</see>".
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillCreateFiles(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event until the provided thenable resolves.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that delays saving.
        /// </param>
        abstract member waitUntil: thenable: Thenable<obj> -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type FileCreateEvent =
        /// <summary>
        /// The files that got created.
        /// </summary>
        abstract member files: ReadonlyArray<Uri> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type FileWillDeleteEvent =
        /// <summary>
        /// A cancellation token.
        /// </summary>
        abstract member token: CancellationToken with get
        /// <summary>
        /// The files that are going to be deleted.
        /// </summary>
        abstract member files: ReadonlyArray<Uri> with get
        /// <summary>
        /// Allows to pause the event and to apply a <see href="WorkspaceEditworkspace">edit</see>".
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillCreateFiles(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event until the provided thenable resolves.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that delays saving.
        /// </param>
        abstract member waitUntil: thenable: Thenable<WorkspaceEdit> -> unit
        /// <summary>
        /// Allows to pause the event and to apply a <see href="WorkspaceEditworkspace">edit</see>".
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillCreateFiles(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event until the provided thenable resolves.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that delays saving.
        /// </param>
        abstract member waitUntil: thenable: Thenable<obj> -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type FileDeleteEvent =
        /// <summary>
        /// The files that got deleted.
        /// </summary>
        abstract member files: ReadonlyArray<Uri> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type FileWillRenameEvent =
        /// <summary>
        /// A cancellation token.
        /// </summary>
        abstract member token: CancellationToken with get
        /// <summary>
        /// The files that are going to be renamed.
        /// </summary>
        abstract member files: ReadonlyArray<FileWillRenameEvent.files> with get
        /// <summary>
        /// Allows to pause the event and to apply a <see href="WorkspaceEditworkspace">edit</see>".
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillCreateFiles(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event until the provided thenable resolves.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that delays saving.
        /// </param>
        abstract member waitUntil: thenable: Thenable<WorkspaceEdit> -> unit
        /// <summary>
        /// Allows to pause the event and to apply a <see href="WorkspaceEditworkspace">edit</see>".
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillCreateFiles(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event until the provided thenable resolves.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that delays saving.
        /// </param>
        abstract member waitUntil: thenable: Thenable<obj> -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type FileRenameEvent =
        /// <summary>
        /// The files that got renamed.
        /// </summary>
        abstract member files: ReadonlyArray<FileRenameEvent.files> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type WorkspaceFoldersChangeEvent =
        /// <summary>
        /// Added workspace folders.
        /// </summary>
        abstract member added: ReadonlyArray<WorkspaceFolder> with get
        /// <summary>
        /// Removed workspace folders.
        /// </summary>
        abstract member removed: ReadonlyArray<WorkspaceFolder> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type WorkspaceFolder =
        /// <summary>
        /// The associated uri for this workspace folder.
        ///
        /// *Note:* The <see href="Uri">Uri</see>-type was intentionally chosen such that future releases of the editor can support
        /// workspace folders that are not stored on the local disk, e.g. <c>ftp://server/workspaces/foo</c>.
        /// </summary>
        abstract member uri: Uri with get
        /// <summary>
        /// The name of this workspace folder. Defaults to
        /// the basename of its <see href="Uri.pathuri-path">Uri.pathuri-path</see>
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// The ordinal number of this workspace folder.
        /// </summary>
        abstract member index: float with get

    module workspace =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// A <see href="FileSystemfile">system</see>" instance that allows to interact with local and remote
            /// files, e.g. <c>vscode.workspace.fs.readDirectory(someUri)</c> allows to retrieve all entries
            /// of a directory or <c>vscode.workspace.fs.stat(anotherUri)</c> returns the meta data for a
            /// file.
            /// </summary>
            [<Emit("$0.fs")>]
            abstract member fs: FileSystem
            /// <summary>
            /// The uri of the first entry of {@linkcode workspace.workspaceFoldersworkspaceFolders}
            /// as <c>string</c>. <c>undefined</c> if there is no first entry.
            ///
            /// Refer to https://code.visualstudio.com/docs/editor/workspaces for more information
            /// on workspaces.
            /// </summary>
            [<Emit("$0.rootPath")>]
            [<Obsolete("Use {@linkcode workspace.workspaceFolders workspaceFolders} instead.")>]
            abstract member rootPath: string option
            /// <summary>
            /// List of workspace folders (0-N) that are open in the editor. <c>undefined</c> when no workspace
            /// has been opened.
            ///
            /// Refer to https://code.visualstudio.com/docs/editor/workspaces for more information
            /// on workspaces.
            /// </summary>
            [<Emit("$0.workspaceFolders")>]
            abstract member workspaceFolders: ReadonlyArray<WorkspaceFolder> option
            /// <summary>
            /// The name of the workspace. <c>undefined</c> when no workspace
            /// has been opened.
            ///
            /// Refer to https://code.visualstudio.com/docs/editor/workspaces for more information on
            /// the concept of workspaces.
            /// </summary>
            [<Emit("$0.name")>]
            abstract member name: string option
            /// <summary>
            /// The location of the workspace file, for example:
            ///
            /// <c>file:///Users/name/Development/myProject.code-workspace</c>
            ///
            /// or
            ///
            /// <c>untitled:1555503116870</c>
            ///
            /// for a workspace that is untitled and not yet saved.
            ///
            /// Depending on the workspace that is opened, the value will be:
            ///  * <c>undefined</c> when no workspace is opened
            ///  * the path of the workspace file as <c>Uri</c> otherwise. if the workspace
            /// is untitled, the returned URI will use the <c>untitled:</c> scheme
            ///
            /// The location can e.g. be used with the <c>vscode.openFolder</c> command to
            /// open the workspace again after it has been closed.
            ///
            /// **Example:**
            /// <code lang="typescript">
            /// vscode.commands.executeCommand('vscode.openFolder', uriOfWorkspace);
            /// </code>
            ///
            /// Refer to https://code.visualstudio.com/docs/editor/workspaces for more information on
            /// the concept of workspaces.
            ///
            /// **Note:** it is not advised to use <c>workspace.workspaceFile</c> to write
            /// configuration data into the file. You can use <c>workspace.getConfiguration().update()</c>
            /// for that purpose which will work both when a single folder is opened as
            /// well as an untitled or saved workspace.
            /// </summary>
            [<Emit("$0.workspaceFile")>]
            abstract member workspaceFile: Uri option
            /// <summary>
            /// An event that is emitted when a workspace folder is added or removed.
            ///
            /// **Note:** this event will not fire if the first workspace folder is added, removed or changed,
            /// because in that case the currently executing extensions (including the one that listens to this
            /// event) will be terminated and restarted so that the (deprecated) <c>rootPath</c> property is updated
            /// to point to the first workspace folder.
            /// </summary>
            [<Emit("$0.onDidChangeWorkspaceFolders")>]
            abstract member onDidChangeWorkspaceFolders: Event<WorkspaceFoldersChangeEvent>
            /// <summary>
            /// Returns the <see href="WorkspaceFolderworkspace">folder</see>" that contains a given uri.
            /// * returns <c>undefined</c> when the given uri doesn't match any workspace folder
            /// * returns the *input* when the given uri is a workspace folder itself
            /// </summary>
            /// <param name="uri">
            /// An uri.
            /// </param>
            /// <returns>
            /// A workspace folder or <c>undefined</c>
            /// </returns>
            [<Emit("$0.getWorkspaceFolder($1...)")>]
            abstract member getWorkspaceFolder: uri: Uri -> WorkspaceFolder option
            /// <summary>
            /// Returns a path that is relative to the workspace folder or folders.
            ///
            /// When there are no <see href="workspace.workspaceFoldersworkspace">folders</see>" or when the path
            /// is not contained in them, the input is returned.
            /// </summary>
            /// <param name="pathOrUri">
            /// A path or uri. When a uri is given its <see href="Uri.fsPath">fsPath</see>" is used.
            /// </param>
            /// <param name="includeWorkspaceFolder">
            /// When <c>true</c> and when the given path is contained inside a
            /// workspace folder the name of the workspace is prepended. Defaults to <c>true</c> when there are
            /// multiple workspace folders and <c>false</c> otherwise.
            /// </param>
            /// <returns>
            /// A path relative to the root or the input.
            /// </returns>
            [<Emit("$0.asRelativePath($1...)")>]
            abstract member asRelativePath: pathOrUri: U2<string, Uri> * ?includeWorkspaceFolder: bool -> string
            /// <summary>
            /// This method replaces <c>deleteCount</c> <see href="workspace.workspaceFoldersworkspace">folders</see>" starting at index <c>start</c>
            /// by an optional set of <c>workspaceFoldersToAdd</c> on the <c>vscode.workspace.workspaceFolders</c> array. This "splice"
            /// behavior can be used to add, remove and change workspace folders in a single operation.
            ///
            /// **Note:** in some cases calling this method may result in the currently executing extensions (including the
            /// one that called this method) to be terminated and restarted. For example when the first workspace folder is
            /// added, removed or changed the (deprecated) <c>rootPath</c> property is updated to point to the first workspace
            /// folder. Another case is when transitioning from an empty or single-folder workspace into a multi-folder
            /// workspace (see also: https://code.visualstudio.com/docs/editor/workspaces).
            ///
            /// Use the {@linkcode onDidChangeWorkspaceFoldersonDidChangeWorkspaceFolders()} event to get notified when the
            /// workspace folders have been updated.
            ///
            /// **Example:** adding a new workspace folder at the end of workspace folders
            /// <code lang="typescript">
            /// workspace.updateWorkspaceFolders(workspace.workspaceFolders ? workspace.workspaceFolders.length : 0, null, { uri: ...});
            /// </code>
            ///
            /// **Example:** removing the first workspace folder
            /// <code lang="typescript">
            /// workspace.updateWorkspaceFolders(0, 1);
            /// </code>
            ///
            /// **Example:** replacing an existing workspace folder with a new one
            /// <code lang="typescript">
            /// workspace.updateWorkspaceFolders(0, 1, { uri: ...});
            /// </code>
            ///
            /// It is valid to remove an existing workspace folder and add it again with a different name
            /// to rename that folder.
            ///
            /// **Note:** it is not valid to call <see href="updateWorkspaceFoldersupdateWorkspaceFolders()">updateWorkspaceFoldersupdateWorkspaceFolders()</see> multiple times
            /// without waiting for the {@linkcode onDidChangeWorkspaceFoldersonDidChangeWorkspaceFolders()} to fire.
            /// </summary>
            /// <param name="start">
            /// the zero-based location in the list of currently opened <see href="WorkspaceFolder">workspace folders</see>"from which to start deleting workspace folders.
            /// </param>
            /// <param name="deleteCount">
            /// the optional number of workspace folders to remove.
            /// </param>
            /// <param name="workspaceFoldersToAdd">
            /// the optional variable set of workspace folders to add in place of the deleted ones.
            /// Each workspace is identified with a mandatory URI and an optional name.
            /// </param>
            /// <returns>
            /// true if the operation was successfully started and false otherwise if arguments were used that would result
            /// in invalid workspace folder state (e.g. 2 folders with the same URI).
            /// </returns>
            [<Emit("$0.updateWorkspaceFolders($1...)")>]
            abstract member updateWorkspaceFolders: start: float * deleteCount: float option * [<ParamArray>] workspaceFoldersToAdd: Exports.updateWorkspaceFolders.workspaceFoldersToAdd [] -> bool
            /// <summary>
            /// Creates a file system watcher that is notified on file events (create, change, delete)
            /// depending on the parameters provided.
            ///
            /// By default, all opened <see href="workspace.workspaceFoldersworkspace">folders</see>" will be watched
            /// for file changes recursively.
            ///
            /// Additional paths can be added for file watching by providing a <see href="RelativePattern">RelativePattern</see> with
            /// a <c>base</c> path to watch. If the path is a folder and the <c>pattern</c> is complex (e.g. contains
            /// <c>**</c> or path segments), it will be watched recursively and otherwise will be watched
            /// non-recursively (i.e. only changes to the first level of the path will be reported).
            ///
            /// *Note* that paths that do not exist in the file system will be monitored with a delay until
            /// created and then watched depending on the parameters provided. If a watched path is deleted,
            /// the watcher will suspend and not report any events until the path is created again.
            ///
            /// If possible, keep the use of recursive watchers to a minimum because recursive file watching
            /// is quite resource intense.
            ///
            /// Providing a <c>string</c> as <c>globPattern</c> acts as convenience method for watching file events in
            /// all opened workspace folders. It cannot be used to add more folders for file watching, nor will
            /// it report any file events from folders that are not part of the opened workspace folders.
            ///
            /// *Note* that case-sensitivity of the <see href="globPattern">globPattern</see> parameter will depend on the file system
            /// where the watcher is running: on Windows and macOS the matching will be case-insensitive and
            /// on Linux it will be case-sensitive.
            ///
            /// Optionally, flags to ignore certain kinds of events can be provided.
            ///
            /// To stop listening to events the watcher must be disposed.
            ///
            /// *Note* that file events from deleting a folder may not include events for the contained files.
            /// For example, when a folder is moved to the trash, only one event is reported because technically
            /// this is a rename/move operation and not a delete operation for each files within.
            /// On top of that, performance optimizations are in place to fold multiple events that all belong
            /// to the same parent operation (e.g. delete folder) into one event for that parent. As such, if
            /// you need to know about all deleted files, you have to watch with <c>**</c> and deal with all file
            /// events yourself.
            ///
            /// *Note* that file events from recursive file watchers may be excluded based on user configuration.
            /// The setting <c>files.watcherExclude</c> helps to reduce the overhead of file events from folders
            /// that are known to produce many file changes at once (such as <c>.git</c> folders). As such,
            /// it is highly recommended to watch with simple patterns that do not require recursive watchers
            /// where the exclude settings are ignored and you have full control over the events.
            ///
            /// *Note* that symbolic links are not automatically followed for file watching unless the path to
            /// watch itself is a symbolic link.
            ///
            /// *Note* that the file paths that are reported for having changed may have a different path casing
            /// compared to the actual casing on disk on case-insensitive platforms (typically macOS and Windows
            /// but not Linux). We allow a user to open a workspace folder with any desired path casing and try
            /// to preserve that. This means:
            /// * if the path is within any of the workspace folders, the path will match the casing of the
            ///   workspace folder up to that portion of the path and match the casing on disk for children
            /// * if the path is outside of any of the workspace folders, the casing will match the case of the
            ///   path that was provided for watching
            /// In the same way, symbolic links are preserved, i.e. the file event will report the path of the
            /// symbolic link as it was provided for watching and not the target.
            ///
            /// ### Examples
            ///
            /// The basic anatomy of a file watcher is as follows:
            ///
            /// <code lang="ts">
            /// const watcher = vscode.workspace.createFileSystemWatcher(new vscode.RelativePattern(<folder>, <pattern>));
            ///
            /// watcher.onDidChange(uri => { ... }); // listen to files being changed
            /// watcher.onDidCreate(uri => { ... }); // listen to files/folders being created
            /// watcher.onDidDelete(uri => { ... }); // listen to files/folders getting deleted
            ///
            /// watcher.dispose(); // dispose after usage
            /// </code>
            ///
            /// #### Workspace file watching
            ///
            /// If you only care about file events in a specific workspace folder:
            ///
            /// <code lang="ts">
            /// vscode.workspace.createFileSystemWatcher(new vscode.RelativePattern(vscode.workspace.workspaceFolders[0], '**​/*.js'));
            /// </code>
            ///
            /// If you want to monitor file events across all opened workspace folders:
            ///
            /// <code lang="ts">
            /// vscode.workspace.createFileSystemWatcher('**​/*.js');
            /// </code>
            ///
            /// *Note:* the array of workspace folders can be empty if no workspace is opened (empty window).
            ///
            /// #### Out of workspace file watching
            ///
            /// To watch a folder for changes to *.js files outside the workspace (non recursively), pass in a <c>Uri</c> to such
            /// a folder:
            ///
            /// <code lang="ts">
            /// vscode.workspace.createFileSystemWatcher(new vscode.RelativePattern(vscode.Uri.file(<path to folder outside workspace>), '*.js'));
            /// </code>
            ///
            /// And use a complex glob pattern to watch recursively:
            ///
            /// <code lang="ts">
            /// vscode.workspace.createFileSystemWatcher(new vscode.RelativePattern(vscode.Uri.file(<path to folder outside workspace>), '**​/*.js'));
            /// </code>
            ///
            /// Here is an example for watching the active editor for file changes:
            ///
            /// <code lang="ts">
            /// vscode.workspace.createFileSystemWatcher(new vscode.RelativePattern(vscode.window.activeTextEditor.document.uri, '*'));
            /// </code>
            /// </summary>
            /// <param name="globPattern">
            /// A <see href="GlobPattern">glob pattern</see>" that controls which file events the watcher should report.
            /// </param>
            /// <param name="ignoreCreateEvents">
            /// Ignore when files have been created.
            /// </param>
            /// <param name="ignoreChangeEvents">
            /// Ignore when files have been changed.
            /// </param>
            /// <param name="ignoreDeleteEvents">
            /// Ignore when files have been deleted.
            /// </param>
            /// <returns>
            /// A new file system watcher instance. Must be disposed when no longer needed.
            /// </returns>
            [<Emit("$0.createFileSystemWatcher($1...)")>]
            abstract member createFileSystemWatcher: globPattern: GlobPattern * ?ignoreCreateEvents: bool * ?ignoreChangeEvents: bool * ?ignoreDeleteEvents: bool -> FileSystemWatcher
            /// <summary>
            /// Find files across all <see href="workspace.workspaceFoldersworkspace">folders</see>" in the workspace.
            /// </summary>
            /// <example>
            /// findFiles('**​/*.js', '**​/node_modules/**', 10)
            /// </example>
            /// <param name="include">
            /// A <see href="GlobPattern">glob pattern</see>" that defines the files to search for. The glob pattern
            /// will be matched against the file paths of resulting matches relative to their workspace. Use a <see href="RelativePattern">relative pattern</see>"
            /// to restrict the search results to a <see href="WorkspaceFolder">workspace folder</see>".
            /// </param>
            /// <param name="exclude">
            /// A <see href="GlobPattern">glob pattern</see>" that defines files and folders to exclude. The glob pattern
            /// will be matched against the file paths of resulting matches relative to their workspace. When <c>undefined</c>, default file-excludes (e.g. the <c>files.exclude</c>-setting
            /// but not <c>search.exclude</c>) will apply. When <c>null</c>, no excludes will apply.
            /// </param>
            /// <param name="maxResults">
            /// An upper-bound for the result.
            /// </param>
            /// <param name="token">
            /// A token that can be used to signal cancellation to the underlying search engine.
            /// </param>
            /// <returns>
            /// A thenable that resolves to an array of resource identifiers. Will return no results if no
            /// <see href="workspace.workspaceFolders">workspace folders</see>" are opened.
            /// </returns>
            [<Emit("$0.findFiles($1...)")>]
            abstract member findFiles: ``include``: GlobPattern * ?exclude: GlobPattern * ?maxResults: float * ?token: CancellationToken -> Thenable<ResizeArray<Uri>>
            /// <summary>
            /// Saves the editor identified by the given resource and returns the resulting resource or <c>undefined</c>
            /// if save was not successful or no editor with the given resource was found.
            ///
            /// **Note** that an editor with the provided resource must be opened in order to be saved.
            /// </summary>
            /// <param name="uri">
            /// the associated uri for the opened editor to save.
            /// </param>
            /// <returns>
            /// A thenable that resolves when the save operation has finished.
            /// </returns>
            [<Emit("$0.save($1...)")>]
            abstract member save: uri: Uri -> Thenable<Uri option>
            /// <summary>
            /// Saves the editor identified by the given resource to a new file name as provided by the user and
            /// returns the resulting resource or <c>undefined</c> if save was not successful or cancelled or no editor
            /// with the given resource was found.
            ///
            /// **Note** that an editor with the provided resource must be opened in order to be saved as.
            /// </summary>
            /// <param name="uri">
            /// the associated uri for the opened editor to save as.
            /// </param>
            /// <returns>
            /// A thenable that resolves when the save-as operation has finished.
            /// </returns>
            [<Emit("$0.saveAs($1...)")>]
            abstract member saveAs: uri: Uri -> Thenable<Uri option>
            /// <summary>
            /// Save all dirty files.
            /// </summary>
            /// <param name="includeUntitled">
            /// Also save files that have been created during this session.
            /// </param>
            /// <returns>
            /// A thenable that resolves when the files have been saved. Will return <c>false</c>
            /// for any file that failed to save.
            /// </returns>
            [<Emit("$0.saveAll($1...)")>]
            abstract member saveAll: ?includeUntitled: bool -> Thenable<bool>
            /// <summary>
            /// Make changes to one or many resources or create, delete, and rename resources as defined by the given
            /// <see href="WorkspaceEditworkspace">edit</see>".
            ///
            /// All changes of a workspace edit are applied in the same order in which they have been added. If
            /// multiple textual inserts are made at the same position, these strings appear in the resulting text
            /// in the order the 'inserts' were made, unless that are interleaved with resource edits. Invalid sequences
            /// like 'delete file a' -> 'insert text in file a' cause failure of the operation.
            ///
            /// When applying a workspace edit that consists only of text edits an 'all-or-nothing'-strategy is used.
            /// A workspace edit with resource creations or deletions aborts the operation, e.g. consecutive edits will
            /// not be attempted, when a single edit fails.
            /// </summary>
            /// <param name="edit">
            /// A workspace edit.
            /// </param>
            /// <param name="metadata">
            /// Optional <see href="WorkspaceEditMetadata">metadata</see>" for the edit.
            /// </param>
            /// <returns>
            /// A thenable that resolves when the edit could be applied.
            /// </returns>
            [<Emit("$0.applyEdit($1...)")>]
            abstract member applyEdit: edit: WorkspaceEdit * ?metadata: WorkspaceEditMetadata -> Thenable<bool>
            /// <summary>
            /// All text documents currently known to the editor.
            /// </summary>
            [<Emit("$0.textDocuments")>]
            abstract member textDocuments: ReadonlyArray<TextDocument>
            /// <summary>
            /// Opens a document. Will return early if this document is already open. Otherwise
            /// the document is loaded and the <see href="workspace.onDidOpenTextDocumentdidOpen">workspace.onDidOpenTextDocumentdidOpen</see>-event fires.
            ///
            /// The document is denoted by an <see href="Uri">Uri</see>. Depending on the <see href="Uri.schemescheme">Uri.schemescheme</see> the
            /// following rules apply:
            /// * <c>file</c>-scheme: Open a file on disk (<c>openTextDocument(Uri.file(path))</c>). Will be rejected if the file
            /// does not exist or cannot be loaded.
            /// * <c>untitled</c>-scheme: Open a blank untitled file with associated path (<c>openTextDocument(Uri.file(path).with({ scheme: 'untitled' }))</c>).
            /// The language will be derived from the file name.
            /// * For all other schemes contributed <see href="TextDocumentContentProvidertext">document content providers</see>" and
            /// <see href="FileSystemProviderfile">system providers</see>" are consulted.
            ///
            /// *Note* that the lifecycle of the returned document is owned by the editor and not by the extension. That means an
            /// {@linkcode workspace.onDidCloseTextDocumentonDidClose}-event can occur at any time after opening it.
            /// </summary>
            /// <param name="uri">
            /// Identifies the resource to open.
            /// </param>
            /// <returns>
            /// A promise that resolves to a <see href="TextDocument">document</see>".
            /// </returns>
            [<Emit("$0.openTextDocument($1...)")>]
            abstract member openTextDocument: uri: Uri * ?options: Exports.openTextDocument.options -> Thenable<TextDocument>
            /// <summary>
            /// A short-hand for <c>openTextDocument(Uri.file(path))</c>.
            /// </summary>
            /// <param name="path">
            /// A path of a file on disk.
            /// </param>
            /// <returns>
            /// A promise that resolves to a <see href="TextDocument">document</see>".
            /// </returns>
            [<Emit("$0.openTextDocument($1...)")>]
            abstract member openTextDocument: path: string * ?options: Exports.openTextDocument.options_1 -> Thenable<TextDocument>
            /// <summary>
            /// Opens an untitled text document. The editor will prompt the user for a file
            /// path when the document is to be saved. The <c>options</c> parameter allows to
            /// specify the *language* and/or the *content* of the document.
            /// </summary>
            /// <param name="options">
            /// Options to control how the document will be created.
            /// </param>
            /// <returns>
            /// A promise that resolves to a <see href="TextDocument">document</see>".
            /// </returns>
            [<Emit("$0.openTextDocument($1...)")>]
            abstract member openTextDocument: ?options: Exports.openTextDocument.options_2 -> Thenable<TextDocument>
            /// <summary>
            /// Register a text document content provider.
            ///
            /// Only one provider can be registered per scheme.
            /// </summary>
            /// <param name="scheme">
            /// The uri-scheme to register for.
            /// </param>
            /// <param name="provider">
            /// A content provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerTextDocumentContentProvider($1...)")>]
            abstract member registerTextDocumentContentProvider: scheme: string * provider: TextDocumentContentProvider -> Disposable
            /// <summary>
            /// An event that is emitted when a <see href="TextDocumenttext">document</see>" is opened or when the language id
            /// of a text document <see href="languages.setTextDocumentLanguagehas">been changed</see>".
            ///
            /// To add an event listener when a visible text document is opened, use the <see href="TextEditor">TextEditor</see> events in the
            /// <see href="window">window</see> namespace. Note that:
            ///
            /// - The event is emitted before the <see href="TextDocumentdocument">TextDocumentdocument</see> is updated in the
            /// <see href="window.activeTextEditoractive">text editor</see>"
            /// - When a <see href="TextDocumenttext">document</see>" is already open (e.g.: open in another <see href="window.visibleTextEditorsvisible">text editor</see>") this event is not emitted
            /// </summary>
            [<Emit("$0.onDidOpenTextDocument")>]
            abstract member onDidOpenTextDocument: Event<TextDocument>
            /// <summary>
            /// An event that is emitted when a <see href="TextDocumenttext">document</see>" is disposed or when the language id
            /// of a text document <see href="languages.setTextDocumentLanguagehas">been changed</see>".
            ///
            /// *Note 1:* There is no guarantee that this event fires when an editor tab is closed, use the
            /// {@linkcode window.onDidChangeVisibleTextEditorsonDidChangeVisibleTextEditors}-event to know when editors change.
            ///
            /// *Note 2:* A document can be open but not shown in an editor which means this event can fire
            /// for a document that has not been shown in an editor.
            /// </summary>
            [<Emit("$0.onDidCloseTextDocument")>]
            abstract member onDidCloseTextDocument: Event<TextDocument>
            /// <summary>
            /// An event that is emitted when a <see href="TextDocumenttext">document</see>" is changed. This usually happens
            /// when the <see href="TextDocument.getTextcontents">TextDocument.getTextcontents</see> changes but also when other things like the
            /// <see href="TextDocument.isDirtydirty">TextDocument.isDirtydirty</see>-state changes.
            /// </summary>
            [<Emit("$0.onDidChangeTextDocument")>]
            abstract member onDidChangeTextDocument: Event<TextDocumentChangeEvent>
            /// <summary>
            /// An event that is emitted when a <see href="TextDocumenttext">document</see>" will be saved to disk.
            ///
            /// *Note 1:* Subscribers can delay saving by registering asynchronous work. For the sake of data integrity the editor
            /// might save without firing this event. For instance when shutting down with dirty files.
            ///
            /// *Note 2:* Subscribers are called sequentially and they can <see href="TextDocumentWillSaveEvent.waitUntildelay">TextDocumentWillSaveEvent.waitUntildelay</see> saving
            /// by registering asynchronous work. Protection against misbehaving listeners is implemented as such:
            ///  * there is an overall time budget that all listeners share and if that is exhausted no further listener is called
            ///  * listeners that take a long time or produce errors frequently will not be called anymore
            ///
            /// The current thresholds are 1.5 seconds as overall time budget and a listener can misbehave 3 times before being ignored.
            /// </summary>
            [<Emit("$0.onWillSaveTextDocument")>]
            abstract member onWillSaveTextDocument: Event<TextDocumentWillSaveEvent>
            /// <summary>
            /// An event that is emitted when a <see href="TextDocumenttext">document</see>" is saved to disk.
            /// </summary>
            [<Emit("$0.onDidSaveTextDocument")>]
            abstract member onDidSaveTextDocument: Event<TextDocument>
            /// <summary>
            /// All notebook documents currently known to the editor.
            /// </summary>
            [<Emit("$0.notebookDocuments")>]
            abstract member notebookDocuments: ReadonlyArray<NotebookDocument>
            /// <summary>
            /// Open a notebook. Will return early if this notebook is already <see href="notebookDocumentsloaded">notebookDocumentsloaded</see>. Otherwise
            /// the notebook is loaded and the {@linkcode onDidOpenNotebookDocument}-event fires.
            ///
            /// *Note* that the lifecycle of the returned notebook is owned by the editor and not by the extension. That means an
            /// {@linkcode onDidCloseNotebookDocument}-event can occur at any time after.
            ///
            /// *Note* that opening a notebook does not show a notebook editor. This function only returns a notebook document which
            /// can be shown in a notebook editor but it can also be used for other things.
            /// </summary>
            /// <param name="uri">
            /// The resource to open.
            /// </param>
            /// <returns>
            /// A promise that resolves to a <see href="NotebookDocument">notebook</see>"
            /// </returns>
            [<Emit("$0.openNotebookDocument($1...)")>]
            abstract member openNotebookDocument: uri: Uri -> Thenable<NotebookDocument>
            /// <summary>
            /// Open an untitled notebook. The editor will prompt the user for a file
            /// path when the document is to be saved.
            /// </summary>
            /// <param name="notebookType">
            /// The notebook type that should be used.
            /// </param>
            /// <param name="content">
            /// The initial contents of the notebook.
            /// </param>
            /// <returns>
            /// A promise that resolves to a <see href="NotebookDocument">notebook</see>".
            /// </returns>
            [<Emit("$0.openNotebookDocument($1...)")>]
            abstract member openNotebookDocument: notebookType: string * ?content: NotebookData -> Thenable<NotebookDocument>
            /// <summary>
            /// An event that is emitted when a <see href="NotebookDocumentnotebook">NotebookDocumentnotebook</see> has changed.
            /// </summary>
            [<Emit("$0.onDidChangeNotebookDocument")>]
            abstract member onDidChangeNotebookDocument: Event<NotebookDocumentChangeEvent>
            /// <summary>
            /// An event that is emitted when a <see href="NotebookDocumentnotebook">document</see>" will be saved to disk.
            ///
            /// *Note 1:* Subscribers can delay saving by registering asynchronous work. For the sake of data integrity the editor
            /// might save without firing this event. For instance when shutting down with dirty files.
            ///
            /// *Note 2:* Subscribers are called sequentially and they can <see href="NotebookDocumentWillSaveEvent.waitUntildelay">NotebookDocumentWillSaveEvent.waitUntildelay</see> saving
            /// by registering asynchronous work. Protection against misbehaving listeners is implemented as such:
            ///  * there is an overall time budget that all listeners share and if that is exhausted no further listener is called
            ///  * listeners that take a long time or produce errors frequently will not be called anymore
            ///
            /// The current thresholds are 1.5 seconds as overall time budget and a listener can misbehave 3 times before being ignored.
            /// </summary>
            [<Emit("$0.onWillSaveNotebookDocument")>]
            abstract member onWillSaveNotebookDocument: Event<NotebookDocumentWillSaveEvent>
            /// <summary>
            /// An event that is emitted when a <see href="NotebookDocumentnotebook">NotebookDocumentnotebook</see> is saved.
            /// </summary>
            [<Emit("$0.onDidSaveNotebookDocument")>]
            abstract member onDidSaveNotebookDocument: Event<NotebookDocument>
            /// <summary>
            /// Register a <see href="NotebookSerializernotebook">serializer</see>".
            ///
            /// A notebook serializer must be contributed through the <c>notebooks</c> extension point. When opening a notebook file, the editor will send
            /// the <c>onNotebook:<notebookType></c> activation event, and extensions must register their serializer in return.
            /// </summary>
            /// <param name="notebookType">
            /// A notebook.
            /// </param>
            /// <param name="serializer">
            /// A notebook serializer.
            /// </param>
            /// <param name="options">
            /// Optional context options that define what parts of a notebook should be persisted
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this serializer when being disposed.
            /// </returns>
            [<Emit("$0.registerNotebookSerializer($1...)")>]
            abstract member registerNotebookSerializer: notebookType: string * serializer: NotebookSerializer * ?options: NotebookDocumentContentOptions -> Disposable
            /// <summary>
            /// An event that is emitted when a <see href="NotebookDocumentnotebook">NotebookDocumentnotebook</see> is opened.
            /// </summary>
            [<Emit("$0.onDidOpenNotebookDocument")>]
            abstract member onDidOpenNotebookDocument: Event<NotebookDocument>
            /// <summary>
            /// An event that is emitted when a <see href="NotebookDocumentnotebook">NotebookDocumentnotebook</see> is disposed.
            ///
            /// *Note 1:* There is no guarantee that this event fires when an editor tab is closed.
            ///
            /// *Note 2:* A notebook can be open but not shown in an editor which means this event can fire
            /// for a notebook that has not been shown in an editor.
            /// </summary>
            [<Emit("$0.onDidCloseNotebookDocument")>]
            abstract member onDidCloseNotebookDocument: Event<NotebookDocument>
            /// <summary>
            /// An event that is emitted when files are being created.
            ///
            /// *Note 1:* This event is triggered by user gestures, like creating a file from the
            /// explorer, or from the {@linkcode workspace.applyEdit}-api. This event is *not* fired when
            /// files change on disk, e.g triggered by another application, or when using the
            /// {@linkcode FileSystemworkspace.fs}-api.
            ///
            /// *Note 2:* When this event is fired, edits to files that are are being created cannot be applied.
            /// </summary>
            [<Emit("$0.onWillCreateFiles")>]
            abstract member onWillCreateFiles: Event<FileWillCreateEvent>
            /// <summary>
            /// An event that is emitted when files have been created.
            ///
            /// *Note:* This event is triggered by user gestures, like creating a file from the
            /// explorer, or from the {@linkcode workspace.applyEdit}-api, but this event is *not* fired when
            /// files change on disk, e.g triggered by another application, or when using the
            /// {@linkcode FileSystemworkspace.fs}-api.
            /// </summary>
            [<Emit("$0.onDidCreateFiles")>]
            abstract member onDidCreateFiles: Event<FileCreateEvent>
            /// <summary>
            /// An event that is emitted when files are being deleted.
            ///
            /// *Note 1:* This event is triggered by user gestures, like deleting a file from the
            /// explorer, or from the {@linkcode workspace.applyEdit}-api, but this event is *not* fired when
            /// files change on disk, e.g triggered by another application, or when using the
            /// {@linkcode FileSystemworkspace.fs}-api.
            ///
            /// *Note 2:* When deleting a folder with children only one event is fired.
            /// </summary>
            [<Emit("$0.onWillDeleteFiles")>]
            abstract member onWillDeleteFiles: Event<FileWillDeleteEvent>
            /// <summary>
            /// An event that is emitted when files have been deleted.
            ///
            /// *Note 1:* This event is triggered by user gestures, like deleting a file from the
            /// explorer, or from the {@linkcode workspace.applyEdit}-api, but this event is *not* fired when
            /// files change on disk, e.g triggered by another application, or when using the
            /// {@linkcode FileSystemworkspace.fs}-api.
            ///
            /// *Note 2:* When deleting a folder with children only one event is fired.
            /// </summary>
            [<Emit("$0.onDidDeleteFiles")>]
            abstract member onDidDeleteFiles: Event<FileDeleteEvent>
            /// <summary>
            /// An event that is emitted when files are being renamed.
            ///
            /// *Note 1:* This event is triggered by user gestures, like renaming a file from the
            /// explorer, and from the {@linkcode workspace.applyEdit}-api, but this event is *not* fired when
            /// files change on disk, e.g triggered by another application, or when using the
            /// {@linkcode FileSystemworkspace.fs}-api.
            ///
            /// *Note 2:* When renaming a folder with children only one event is fired.
            /// </summary>
            [<Emit("$0.onWillRenameFiles")>]
            abstract member onWillRenameFiles: Event<FileWillRenameEvent>
            /// <summary>
            /// An event that is emitted when files have been renamed.
            ///
            /// *Note 1:* This event is triggered by user gestures, like renaming a file from the
            /// explorer, and from the {@linkcode workspace.applyEdit}-api, but this event is *not* fired when
            /// files change on disk, e.g triggered by another application, or when using the
            /// {@linkcode FileSystemworkspace.fs}-api.
            ///
            /// *Note 2:* When renaming a folder with children only one event is fired.
            /// </summary>
            [<Emit("$0.onDidRenameFiles")>]
            abstract member onDidRenameFiles: Event<FileRenameEvent>
            /// <summary>
            /// Get a workspace configuration object.
            ///
            /// When a section-identifier is provided only that part of the configuration
            /// is returned. Dots in the section-identifier are interpreted as child-access,
            /// like <c>{ myExt: { setting: { doIt: true }}}</c> and <c>getConfiguration('myExt.setting').get('doIt') === true</c>.
            ///
            /// When a scope is provided configuration confined to that scope is returned. Scope can be a resource or a language identifier or both.
            /// </summary>
            /// <param name="section">
            /// A dot-separated identifier.
            /// </param>
            /// <param name="scope">
            /// A scope for which the configuration is asked for.
            /// </param>
            /// <returns>
            /// The full configuration or a subset.
            /// </returns>
            [<Emit("$0.getConfiguration($1...)")>]
            abstract member getConfiguration: ?section: string * ?scope: ConfigurationScope -> WorkspaceConfiguration
            /// <summary>
            /// An event that is emitted when the <see href="WorkspaceConfigurationconfiguration">WorkspaceConfigurationconfiguration</see> changed.
            /// </summary>
            [<Emit("$0.onDidChangeConfiguration")>]
            abstract member onDidChangeConfiguration: Event<ConfigurationChangeEvent>
            /// <summary>
            /// Register a task provider.
            /// </summary>
            /// <param name="type">
            /// The task kind type this provider is registered for.
            /// </param>
            /// <param name="provider">
            /// A task provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerTaskProvider($1...)"); Obsolete("Use the corresponding function on the `tasks` namespace instead")>]
            abstract member registerTaskProvider: ``type``: string * provider: TaskProvider -> Disposable
            /// <summary>
            /// Register a filesystem provider for a given scheme, e.g. <c>ftp</c>.
            ///
            /// There can only be one provider per scheme and an error is being thrown when a scheme
            /// has been claimed by another provider or when it is reserved.
            /// </summary>
            /// <param name="scheme">
            /// The uri-<see href="Uri.scheme">scheme</see>" the provider registers for.
            /// </param>
            /// <param name="provider">
            /// The filesystem provider.
            /// </param>
            /// <param name="options">
            /// Immutable metadata about the provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerFileSystemProvider($1...)")>]
            abstract member registerFileSystemProvider: scheme: string * provider: FileSystemProvider * ?options: Exports.registerFileSystemProvider.options -> Disposable
            /// <summary>
            /// When true, the user has explicitly trusted the contents of the workspace.
            /// </summary>
            [<Emit("$0.isTrusted")>]
            abstract member isTrusted: bool
            /// <summary>
            /// Event that fires when the current workspace has been trusted.
            /// </summary>
            [<Emit("$0.onDidGrantWorkspaceTrust")>]
            abstract member onDidGrantWorkspaceTrust: Event<unit>
            /// <summary>
            /// Decodes the content from a <c>Uint8Array</c> to a <c>string</c>. You MUST
            /// provide the entire content at once to ensure that the encoding
            /// can properly apply. Do not use this method to decode content
            /// in chunks, as that may lead to incorrect results.
            ///
            /// Will pick an encoding based on settings and the content of the
            /// buffer (for example byte order marks).
            ///
            /// *Note* that if you decode content that is unsupported by the
            /// encoding, the result may contain substitution characters as
            /// appropriate.
            /// </summary>
            /// <remarks>
            /// Throws:
            /// -------
            ///
            /// This method will throw an error when the content is binary.
            /// </remarks>
            /// <param name="content">
            /// The text content to decode as a <c>Uint8Array</c>.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the decoded <c>string</c>.
            /// </returns>
            [<Emit("$0.decode($1...)")>]
            abstract member decode: content: JS.Uint8Array -> Thenable<string>
            /// <summary>
            /// Decodes the content from a <c>Uint8Array</c> to a <c>string</c> using the
            /// provided encoding. You MUST provide the entire content at once
            /// to ensure that the encoding can properly apply. Do not use this
            /// method to decode content in chunks, as that may lead to incorrect
            /// results.
            ///
            /// *Note* that if you decode content that is unsupported by the
            /// encoding, the result may contain substitution characters as
            /// appropriate.
            /// </summary>
            /// <remarks>
            /// Throws:
            /// -------
            ///
            /// This method will throw an error when the content is binary.
            /// </remarks>
            /// <param name="content">
            /// The text content to decode as a <c>Uint8Array</c>.
            /// </param>
            /// <param name="options">
            /// Additional context for picking the encoding.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the decoded <c>string</c>.
            /// </returns>
            [<Emit("$0.decode($1...)")>]
            abstract member decode: content: JS.Uint8Array * options: Exports.decode.options -> Thenable<string>
            /// <summary>
            /// Decodes the content from a <c>Uint8Array</c> to a <c>string</c>. You MUST
            /// provide the entire content at once to ensure that the encoding
            /// can properly apply. Do not use this method to decode content
            /// in chunks, as that may lead to incorrect results.
            ///
            /// The encoding is picked based on settings and the content
            /// of the buffer (for example byte order marks).
            ///
            /// *Note* that if you decode content that is unsupported by the
            /// encoding, the result may contain substitution characters as
            /// appropriate.
            /// </summary>
            /// <remarks>
            /// Throws:
            /// -------
            ///
            /// This method will throw an error when the content is binary.
            /// </remarks>
            /// <param name="content">
            /// The content to decode as a <c>Uint8Array</c>.
            /// </param>
            /// <param name="options">
            /// Additional context for picking the encoding.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the decoded <c>string</c>.
            /// </returns>
            [<Emit("$0.decode($1...)")>]
            abstract member decode: content: JS.Uint8Array * options: Exports.decode.options_1 -> Thenable<string>
            /// <summary>
            /// Encodes the content of a <c>string</c> to a <c>Uint8Array</c>.
            ///
            /// Will pick an encoding based on settings.
            /// </summary>
            /// <param name="content">
            /// The content to decode as a <c>string</c>.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the encoded <c>Uint8Array</c>.
            /// </returns>
            [<Emit("$0.encode($1...)")>]
            abstract member encode: content: string -> Thenable<JS.Uint8Array>
            /// <summary>
            /// Encodes the content of a <c>string</c> to a <c>Uint8Array</c> using the
            /// provided encoding.
            /// </summary>
            /// <param name="content">
            /// The content to decode as a <c>string</c>.
            /// </param>
            /// <param name="options">
            /// Additional context for picking the encoding.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the encoded <c>Uint8Array</c>.
            /// </returns>
            [<Emit("$0.encode($1...)")>]
            abstract member encode: content: string * options: Exports.encode.options -> Thenable<JS.Uint8Array>
            /// <summary>
            /// Encodes the content of a <c>string</c> to a <c>Uint8Array</c>.
            ///
            /// The encoding is picked based on settings.
            /// </summary>
            /// <param name="content">
            /// The content to decode as a <c>string</c>.
            /// </param>
            /// <param name="options">
            /// Additional context for picking the encoding.
            /// </param>
            /// <returns>
            /// A thenable that resolves to the encoded <c>Uint8Array</c>.
            /// </returns>
            [<Emit("$0.encode($1...)")>]
            abstract member encode: content: string * options: Exports.encode.options_1 -> Thenable<JS.Uint8Array>

        module Exports =

            module updateWorkspaceFolders =

                [<Global>]
                [<AllowNullLiteral>]
                type workspaceFoldersToAdd
                    [<ParamObject; Emit("$0")>]
                    (
                        uri: Uri,
                        ?name: string
                    ) =

                    member val uri : Uri = nativeOnly with get
                    member val name : string option = nativeOnly with get

            module openTextDocument =

                [<Global>]
                [<AllowNullLiteral>]
                type options
                    [<ParamObject; Emit("$0")>]
                    (
                        ?encoding: string
                    ) =

                    member val encoding : string option = nativeOnly with get

                [<Global>]
                [<AllowNullLiteral>]
                type options_1
                    [<ParamObject; Emit("$0")>]
                    (
                        ?encoding: string
                    ) =

                    member val encoding : string option = nativeOnly with get

                [<Global>]
                [<AllowNullLiteral>]
                type options_2
                    [<ParamObject; Emit("$0")>]
                    (
                        ?language: string,
                        ?content: string,
                        ?encoding: string
                    ) =

                    member val language : string option = nativeOnly with get, set
                    member val content : string option = nativeOnly with get, set
                    member val encoding : string option = nativeOnly with get

            module registerFileSystemProvider =

                [<Global>]
                [<AllowNullLiteral>]
                type options
                    [<ParamObject; Emit("$0")>]
                    (
                        ?isCaseSensitive: bool,
                        ?isReadonly: U2<bool, MarkdownString>
                    ) =

                    member val isCaseSensitive : bool option = nativeOnly with get
                    member val isReadonly : U2<bool, MarkdownString> option = nativeOnly with get

            module decode =

                [<Global>]
                [<AllowNullLiteral>]
                type options
                    [<ParamObject; Emit("$0")>]
                    (
                        encoding: string
                    ) =

                    member val encoding : string = nativeOnly with get

                [<Global>]
                [<AllowNullLiteral>]
                type options_1
                    [<ParamObject; Emit("$0")>]
                    (
                        uri: Uri
                    ) =

                    member val uri : Uri = nativeOnly with get

            module encode =

                [<Global>]
                [<AllowNullLiteral>]
                type options
                    [<ParamObject; Emit("$0")>]
                    (
                        encoding: string
                    ) =

                    member val encoding : string = nativeOnly with get

                [<Global>]
                [<AllowNullLiteral>]
                type options_1
                    [<ParamObject; Emit("$0")>]
                    (
                        uri: Uri
                    ) =

                    member val uri : Uri = nativeOnly with get

    /// <summary>
    /// The configuration scope which can be:
    /// - a <see href="Uri">Uri</see> representing a resource
    /// - a <see href="TextDocument">TextDocument</see> representing an open text document
    /// - a <see href="WorkspaceFolder">WorkspaceFolder</see> representing a workspace folder
    /// - an object containing:
    ///   - <c>uri</c>: an optional <see href="Uri">Uri</see> of a text document
    ///   - <c>languageId</c>: the language identifier of a text document
    /// </summary>
    type ConfigurationScope =
        U4<Uri, TextDocument, WorkspaceFolder, ConfigurationScope.U4.Case4>

    [<AllowNullLiteral>]
    [<Interface>]
    type ConfigurationChangeEvent =
        /// <summary>
        /// Checks if the given section has changed.
        /// If scope is provided, checks if the section has changed for resources under the given scope.
        /// </summary>
        /// <param name="section">
        /// Configuration name, supports _dotted_ names.
        /// </param>
        /// <param name="scope">
        /// A scope in which to check.
        /// </param>
        /// <returns>
        /// <c>true</c> if the given section has changed.
        /// </returns>
        abstract member affectsConfiguration: section: string * ?scope: ConfigurationScope -> bool

    module languages =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Return the identifiers of all known languages.
            /// </summary>
            /// <returns>
            /// Promise resolving to an array of identifier strings.
            /// </returns>
            [<Emit("$0.getLanguages($1...)")>]
            abstract member getLanguages: unit -> Thenable<ResizeArray<string>>
            /// <summary>
            /// Set (and change) the <see href="TextDocument.languageIdlanguage">TextDocument.languageIdlanguage</see> that is associated
            /// with the given document.
            ///
            /// *Note* that calling this function will trigger the {@linkcode workspace.onDidCloseTextDocumentonDidCloseTextDocument} event
            /// followed by the {@linkcode workspace.onDidOpenTextDocumentonDidOpenTextDocument} event.
            /// </summary>
            /// <param name="document">
            /// The document which language is to be changed
            /// </param>
            /// <param name="languageId">
            /// The new language identifier.
            /// </param>
            /// <returns>
            /// A thenable that resolves with the updated document.
            /// </returns>
            [<Emit("$0.setTextDocumentLanguage($1...)")>]
            abstract member setTextDocumentLanguage: document: TextDocument * languageId: string -> Thenable<TextDocument>
            /// <summary>
            /// Compute the match between a document <see href="DocumentSelectorselector">DocumentSelectorselector</see> and a document. Values
            /// greater than zero mean the selector matches the document.
            ///
            /// A match is computed according to these rules:
            /// 1. When {@linkcode DocumentSelector} is an array, compute the match for each contained <c>DocumentFilter</c> or language identifier and take the maximum value.
            /// 2. A string will be desugared to become the <c>language</c>-part of a {@linkcode DocumentFilter}, so <c>"fooLang"</c> is like <c>{ language: "fooLang" }</c>.
            /// 3. A {@linkcode DocumentFilter} will be matched against the document by comparing its parts with the document. The following rules apply:
            ///    1. When the <c>DocumentFilter</c> is empty (<c>{}</c>) the result is <c>0</c>
            ///    2. When <c>scheme</c>, <c>language</c>, <c>pattern</c>, or <c>notebook</c> are defined but one doesn't match, the result is <c>0</c>
            ///    3. Matching against <c>*</c> gives a score of <c>5</c>, matching via equality or via a glob-pattern gives a score of <c>10</c>
            ///    4. The result is the maximum value of each match
            ///
            /// Samples:
            /// <c></c><c>js
            /// // default document from disk (file-scheme)
            /// doc.uri; //'file:///my/file.js'
            /// doc.languageId; // 'javascript'
            /// match('javascript', doc); // 10;
            /// match({ language: 'javascript' }, doc); // 10;
            /// match({ language: 'javascript', scheme: 'file' }, doc); // 10;
            /// match('*', doc); // 5
            /// match('fooLang', doc); // 0
            /// match(['fooLang', '*'], doc); // 5
            ///
            /// // virtual document, e.g. from git-index
            /// doc.uri; // 'git:/my/file.js'
            /// doc.languageId; // 'javascript'
            /// match('javascript', doc); // 10;
            /// match({ language: 'javascript', scheme: 'git' }, doc); // 10;
            /// match('*', doc); // 5
            ///
            /// // notebook cell document
            /// doc.uri; // </c>vscode-notebook-cell:///my/notebook.ipynb#gl65s2pmha<c>;
            /// doc.languageId; // 'python'
            /// match({ notebookType: 'jupyter-notebook' }, doc) // 10
            /// match({ notebookType: 'fooNotebook', language: 'python' }, doc) // 0
            /// match({ language: 'python' }, doc) // 10
            /// match({ notebookType: '*' }, doc) // 5
            /// </c><c></c>
            /// </summary>
            /// <param name="selector">
            /// A document selector.
            /// </param>
            /// <param name="document">
            /// A text document.
            /// </param>
            /// <returns>
            /// A number <c>>0</c> when the selector matches and <c>0</c> when the selector does not match.
            /// </returns>
            [<Emit("$0.match($1...)")>]
            abstract member ``match``: selector: DocumentSelector * document: TextDocument -> float
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the global set of diagnostics changes. This is
            /// newly added and removed diagnostics.
            /// </summary>
            [<Emit("$0.onDidChangeDiagnostics")>]
            abstract member onDidChangeDiagnostics: Event<DiagnosticChangeEvent>
            /// <summary>
            /// Get all diagnostics for a given resource.
            /// </summary>
            /// <param name="resource">
            /// A resource
            /// </param>
            /// <returns>
            /// An array of <see href="Diagnostic">diagnostics</see>" objects or an empty array.
            /// </returns>
            [<Emit("$0.getDiagnostics($1...)")>]
            abstract member getDiagnostics: resource: Uri -> ResizeArray<Diagnostic>
            /// <summary>
            /// Get all diagnostics.
            /// </summary>
            /// <returns>
            /// An array of uri-diagnostics tuples or an empty array.
            /// </returns>
            [<Emit("$0.getDiagnostics($1...)")>]
            abstract member getDiagnostics: unit -> ResizeArray<Uri * ResizeArray<Diagnostic>>
            /// <summary>
            /// Create a diagnostics collection.
            /// </summary>
            /// <param name="name">
            /// The <see href="DiagnosticCollection.name">name</see>" of the collection.
            /// </param>
            /// <returns>
            /// A new diagnostic collection.
            /// </returns>
            [<Emit("$0.createDiagnosticCollection($1...)")>]
            abstract member createDiagnosticCollection: ?name: string -> DiagnosticCollection
            /// <summary>
            /// Creates a new <see href="LanguageStatusItemlanguage">status item</see>".
            /// </summary>
            /// <param name="id">
            /// The identifier of the item.
            /// </param>
            /// <param name="selector">
            /// The document selector that defines for what editors the item shows.
            /// </param>
            /// <returns>
            /// A new language status item.
            /// </returns>
            [<Emit("$0.createLanguageStatusItem($1...)")>]
            abstract member createLanguageStatusItem: id: string * selector: DocumentSelector -> LanguageStatusItem
            /// <summary>
            /// Register a completion provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and groups of equal score are sequentially asked for
            /// completion items. The process stops when one or many providers of a group return a
            /// result. A failing provider (rejected promise or exception) will not fail the whole
            /// operation.
            ///
            /// A completion item provider can be associated with a set of <c>triggerCharacters</c>. When trigger
            /// characters are being typed, completions are requested but only from providers that registered
            /// the typed character. Because of that trigger characters should be different than <see href="LanguageConfiguration.wordPatternword">characters</see>",
            /// a common trigger character is <c>.</c> to trigger member completions.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A completion provider.
            /// </param>
            /// <param name="triggerCharacters">
            /// Trigger completion when the user types one of the characters.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerCompletionItemProvider($1...)")>]
            abstract member registerCompletionItemProvider: selector: DocumentSelector * provider: CompletionItemProvider * [<ParamArray>] triggerCharacters: string [] -> Disposable
            /// <summary>
            /// Registers an inline completion provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// An inline completion provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerInlineCompletionItemProvider($1...)")>]
            abstract member registerInlineCompletionItemProvider: selector: DocumentSelector * provider: InlineCompletionItemProvider -> Disposable
            /// <summary>
            /// Register a code action provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A code action provider.
            /// </param>
            /// <param name="metadata">
            /// Metadata about the kind of code actions the provider provides.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerCodeActionsProvider($1...)")>]
            abstract member registerCodeActionsProvider: selector: DocumentSelector * provider: CodeActionProvider * ?metadata: CodeActionProviderMetadata -> Disposable
            /// <summary>
            /// Register a code lens provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A code lens provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerCodeLensProvider($1...)")>]
            abstract member registerCodeLensProvider: selector: DocumentSelector * provider: CodeLensProvider -> Disposable
            /// <summary>
            /// Register a definition provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A definition provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDefinitionProvider($1...)")>]
            abstract member registerDefinitionProvider: selector: DocumentSelector * provider: DefinitionProvider -> Disposable
            /// <summary>
            /// Register an implementation provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// An implementation provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerImplementationProvider($1...)")>]
            abstract member registerImplementationProvider: selector: DocumentSelector * provider: ImplementationProvider -> Disposable
            /// <summary>
            /// Register a type definition provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A type definition provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerTypeDefinitionProvider($1...)")>]
            abstract member registerTypeDefinitionProvider: selector: DocumentSelector * provider: TypeDefinitionProvider -> Disposable
            /// <summary>
            /// Register a declaration provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A declaration provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDeclarationProvider($1...)")>]
            abstract member registerDeclarationProvider: selector: DocumentSelector * provider: DeclarationProvider -> Disposable
            /// <summary>
            /// Register a hover provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A hover provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerHoverProvider($1...)")>]
            abstract member registerHoverProvider: selector: DocumentSelector * provider: HoverProvider -> Disposable
            /// <summary>
            /// Register a provider that locates evaluatable expressions in text documents.
            /// The editor will evaluate the expression in the active debug session and will show the result in the debug hover.
            ///
            /// If multiple providers are registered for a language an arbitrary provider will be used.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// An evaluatable expression provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerEvaluatableExpressionProvider($1...)")>]
            abstract member registerEvaluatableExpressionProvider: selector: DocumentSelector * provider: EvaluatableExpressionProvider -> Disposable
            /// <summary>
            /// Register a provider that returns data for the debugger's 'inline value' feature.
            /// Whenever the generic debugger has stopped in a source file, providers registered for the language of the file
            /// are called to return textual data that will be shown in the editor at the end of lines.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// An inline values provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerInlineValuesProvider($1...)")>]
            abstract member registerInlineValuesProvider: selector: DocumentSelector * provider: InlineValuesProvider -> Disposable
            /// <summary>
            /// Register a document highlight provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and groups sequentially asked for document highlights.
            /// The process stops when a provider returns a <c>non-falsy</c> or <c>non-failure</c> result.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A document highlight provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDocumentHighlightProvider($1...)")>]
            abstract member registerDocumentHighlightProvider: selector: DocumentSelector * provider: DocumentHighlightProvider -> Disposable
            /// <summary>
            /// Register a document symbol provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A document symbol provider.
            /// </param>
            /// <param name="metaData">
            /// metadata about the provider
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDocumentSymbolProvider($1...)")>]
            abstract member registerDocumentSymbolProvider: selector: DocumentSelector * provider: DocumentSymbolProvider * ?metaData: DocumentSymbolProviderMetadata -> Disposable
            /// <summary>
            /// Register a workspace symbol provider.
            ///
            /// Multiple providers can be registered. In that case providers are asked in parallel and
            /// the results are merged. A failing provider (rejected promise or exception) will not cause
            /// a failure of the whole operation.
            /// </summary>
            /// <param name="provider">
            /// A workspace symbol provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerWorkspaceSymbolProvider($1...)")>]
            abstract member registerWorkspaceSymbolProvider: provider: WorkspaceSymbolProvider -> Disposable
            /// <summary>
            /// Register a reference provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A reference provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerReferenceProvider($1...)")>]
            abstract member registerReferenceProvider: selector: DocumentSelector * provider: ReferenceProvider -> Disposable
            /// <summary>
            /// Register a rename provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and asked in sequence. The first provider producing a result
            /// defines the result of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A rename provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerRenameProvider($1...)")>]
            abstract member registerRenameProvider: selector: DocumentSelector * provider: RenameProvider -> Disposable
            /// <summary>
            /// Register a semantic tokens provider for a whole document.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and the best-matching provider is used. Failure
            /// of the selected provider will cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A document semantic tokens provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDocumentSemanticTokensProvider($1...)")>]
            abstract member registerDocumentSemanticTokensProvider: selector: DocumentSelector * provider: DocumentSemanticTokensProvider * legend: SemanticTokensLegend -> Disposable
            /// <summary>
            /// Register a semantic tokens provider for a document range.
            ///
            /// *Note:* If a document has both a <c>DocumentSemanticTokensProvider</c> and a <c>DocumentRangeSemanticTokensProvider</c>,
            /// the range provider will be invoked only initially, for the time in which the full document provider takes
            /// to resolve the first request. Once the full document provider resolves the first request, the semantic tokens
            /// provided via the range provider will be discarded and from that point forward, only the document provider
            /// will be used.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and the best-matching provider is used. Failure
            /// of the selected provider will cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A document range semantic tokens provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDocumentRangeSemanticTokensProvider($1...)")>]
            abstract member registerDocumentRangeSemanticTokensProvider: selector: DocumentSelector * provider: DocumentRangeSemanticTokensProvider * legend: SemanticTokensLegend -> Disposable
            /// <summary>
            /// Register a formatting provider for a document.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and the best-matching provider is used. Failure
            /// of the selected provider will cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A document formatting edit provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDocumentFormattingEditProvider($1...)")>]
            abstract member registerDocumentFormattingEditProvider: selector: DocumentSelector * provider: DocumentFormattingEditProvider -> Disposable
            /// <summary>
            /// Register a formatting provider for a document range.
            ///
            /// *Note:* A document range provider is also a <see href="DocumentFormattingEditProviderdocument">formatter</see>"
            /// which means there is no need to <see href="languages.registerDocumentFormattingEditProviderregister">languages.registerDocumentFormattingEditProviderregister</see> a document
            /// formatter when also registering a range provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and the best-matching provider is used. Failure
            /// of the selected provider will cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A document range formatting edit provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDocumentRangeFormattingEditProvider($1...)")>]
            abstract member registerDocumentRangeFormattingEditProvider: selector: DocumentSelector * provider: DocumentRangeFormattingEditProvider -> Disposable
            /// <summary>
            /// Register a formatting provider that works on type. The provider is active when the user enables the setting <c>editor.formatOnType</c>.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and the best-matching provider is used. Failure
            /// of the selected provider will cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// An on type formatting edit provider.
            /// </param>
            /// <param name="firstTriggerCharacter">
            /// A character on which formatting should be triggered, like <c>}</c>.
            /// </param>
            /// <param name="moreTriggerCharacter">
            /// More trigger characters.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerOnTypeFormattingEditProvider($1...)")>]
            abstract member registerOnTypeFormattingEditProvider: selector: DocumentSelector * provider: OnTypeFormattingEditProvider * firstTriggerCharacter: string * [<ParamArray>] moreTriggerCharacter: string [] -> Disposable
            /// <summary>
            /// Register a signature help provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and called sequentially until a provider returns a
            /// valid result.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A signature help provider.
            /// </param>
            /// <param name="triggerCharacters">
            /// Trigger signature help when the user types one of the characters, like <c>,</c> or <c>(</c>.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerSignatureHelpProvider($1...)")>]
            abstract member registerSignatureHelpProvider: selector: DocumentSelector * provider: SignatureHelpProvider * [<ParamArray>] triggerCharacters: string [] -> Disposable
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A signature help provider.
            /// </param>
            /// <param name="metadata">
            /// Information about the provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerSignatureHelpProvider($1...)")>]
            abstract member registerSignatureHelpProvider: selector: DocumentSelector * provider: SignatureHelpProvider * metadata: SignatureHelpProviderMetadata -> Disposable
            /// <summary>
            /// Register a document link provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A document link provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDocumentLinkProvider($1...)")>]
            abstract member registerDocumentLinkProvider: selector: DocumentSelector * provider: DocumentLinkProvider -> Disposable
            /// <summary>
            /// Register a color provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A color provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerColorProvider($1...)")>]
            abstract member registerColorProvider: selector: DocumentSelector * provider: DocumentColorProvider -> Disposable
            /// <summary>
            /// Register a inlay hints provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// An inlay hints provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerInlayHintsProvider($1...)")>]
            abstract member registerInlayHintsProvider: selector: DocumentSelector * provider: InlayHintsProvider -> Disposable
            /// <summary>
            /// Register a folding range provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged.
            /// If multiple folding ranges start at the same position, only the range of the first registered provider is used.
            /// If a folding range overlaps with an other range that has a smaller position, it is also ignored.
            ///
            /// A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A folding range provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerFoldingRangeProvider($1...)")>]
            abstract member registerFoldingRangeProvider: selector: DocumentSelector * provider: FoldingRangeProvider -> Disposable
            /// <summary>
            /// Register a selection range provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are asked in
            /// parallel and the results are merged. A failing provider (rejected promise or exception) will
            /// not cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A selection range provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerSelectionRangeProvider($1...)")>]
            abstract member registerSelectionRangeProvider: selector: DocumentSelector * provider: SelectionRangeProvider -> Disposable
            /// <summary>
            /// Register a call hierarchy provider.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A call hierarchy provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerCallHierarchyProvider($1...)")>]
            abstract member registerCallHierarchyProvider: selector: DocumentSelector * provider: CallHierarchyProvider -> Disposable
            /// <summary>
            /// Register a type hierarchy provider.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A type hierarchy provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerTypeHierarchyProvider($1...)")>]
            abstract member registerTypeHierarchyProvider: selector: DocumentSelector * provider: TypeHierarchyProvider -> Disposable
            /// <summary>
            /// Register a linked editing range provider.
            ///
            /// Multiple providers can be registered for a language. In that case providers are sorted
            /// by their <see href="languages.matchscore">languages.matchscore</see> and the best-matching provider that has a result is used. Failure
            /// of the selected provider will cause a failure of the whole operation.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider is applicable to.
            /// </param>
            /// <param name="provider">
            /// A linked editing range provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerLinkedEditingRangeProvider($1...)")>]
            abstract member registerLinkedEditingRangeProvider: selector: DocumentSelector * provider: LinkedEditingRangeProvider -> Disposable
            /// <summary>
            /// Registers a new <see href="DocumentDropEditProvider">DocumentDropEditProvider</see>.
            ///
            /// Multiple drop providers can be registered for a language. When dropping content into an editor, all
            /// registered providers for the editor's language will be invoked based on the mimetypes they handle
            /// as specified by their {@linkcode DocumentDropEditProviderMetadata}.
            ///
            /// Each provider can return one or more {@linkcode DocumentDropEditDocumentDropEdits}. The edits are sorted
            /// using the {@linkcode DocumentDropEdit.yieldTo} property. By default the first edit will be applied. If there
            /// are any additional edits, these will be shown to the user as selectable drop options in the drop widget.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider applies to.
            /// </param>
            /// <param name="provider">
            /// A drop provider.
            /// </param>
            /// <param name="metadata">
            /// Additional metadata about the provider.
            /// </param>
            /// <returns>
            /// A {@linkcode Disposable } that unregisters this provider when disposed of.
            /// </returns>
            [<Emit("$0.registerDocumentDropEditProvider($1...)")>]
            abstract member registerDocumentDropEditProvider: selector: DocumentSelector * provider: DocumentDropEditProvider * ?metadata: DocumentDropEditProviderMetadata -> Disposable
            /// <summary>
            /// Registers a new {@linkcode DocumentPasteEditProvider}.
            ///
            /// Multiple providers can be registered for a language. All registered providers for a language will be invoked
            /// for copy and paste operations based on their handled mimetypes as specified by the {@linkcode DocumentPasteProviderMetadata}.
            ///
            /// For <see href="DocumentPasteEditProvider.prepareDocumentPastecopy">operations</see>", changes to the {@linkcode DataTransfer}
            /// made by each provider will be merged into a single {@linkcode DataTransfer} that is used to populate the clipboard.
            ///
            /// For <see href="DocumentPasteEditProvider.providerDocumentPasteEdits">paste operations</see>", each provider will be invoked
            /// and can return one or more {@linkcode DocumentPasteEditDocumentPasteEdits}. The edits are sorted using
            /// the {@linkcode DocumentPasteEdit.yieldTo} property. By default the first edit will be applied
            /// and the rest of the edits will be shown to the user as selectable paste options in the paste widget.
            /// </summary>
            /// <param name="selector">
            /// A selector that defines the documents this provider applies to.
            /// </param>
            /// <param name="provider">
            /// A paste editor provider.
            /// </param>
            /// <param name="metadata">
            /// Additional metadata about the provider.
            /// </param>
            /// <returns>
            /// A {@linkcode Disposable } that unregisters this provider when disposed of.
            /// </returns>
            [<Emit("$0.registerDocumentPasteEditProvider($1...)")>]
            abstract member registerDocumentPasteEditProvider: selector: DocumentSelector * provider: DocumentPasteEditProvider * metadata: DocumentPasteProviderMetadata -> Disposable
            /// <summary>
            /// Set a <see href="LanguageConfigurationlanguage">configuration</see>" for a language.
            /// </summary>
            /// <param name="language">
            /// A language identifier like <c>typescript</c>.
            /// </param>
            /// <param name="configuration">
            /// Language configuration.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unsets this configuration.
            /// </returns>
            [<Emit("$0.setLanguageConfiguration($1...)")>]
            abstract member setLanguageConfiguration: language: string * configuration: LanguageConfiguration -> Disposable

    [<RequireQualifiedAccess>]
    type NotebookEditorRevealType =
        | Default = 0
        | InCenter = 1
        | InCenterIfOutsideViewport = 2
        | AtTop = 3

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookEditor =
        /// <summary>
        /// The <see href="NotebookDocumentnotebook">document</see>" associated with this notebook editor.
        /// </summary>
        abstract member notebook: NotebookDocument with get
        /// <summary>
        /// The primary selection in this notebook editor.
        /// </summary>
        abstract member selection: NotebookRange with get, set
        /// <summary>
        /// All selections in this notebook editor.
        ///
        /// The primary selection (or focused range) is <c>selections[0]</c>. When the document has no cells, the primary selection is empty <c>{ start: 0, end: 0 }</c>;
        /// </summary>
        abstract member selections: ReadonlyArray<NotebookRange> with get, set
        /// <summary>
        /// The current visible ranges in the editor (vertically).
        /// </summary>
        abstract member visibleRanges: ReadonlyArray<NotebookRange> with get
        /// <summary>
        /// The column in which this editor shows.
        /// </summary>
        abstract member viewColumn: ViewColumn option with get
        /// <summary>
        /// Scroll as indicated by <c>revealType</c> in order to reveal the given range.
        /// </summary>
        /// <param name="range">
        /// A range.
        /// </param>
        /// <param name="revealType">
        /// The scrolling strategy for revealing <c>range</c>.
        /// </param>
        abstract member revealRange: range: NotebookRange * ?revealType: NotebookEditorRevealType -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookRendererMessaging =
        /// <summary>
        /// An event that fires when a message is received from a renderer.
        /// </summary>
        abstract member onDidReceiveMessage: Event<NotebookRendererMessaging.onDidReceiveMessage> with get
        /// <summary>
        /// Send a message to one or all renderer.
        /// </summary>
        /// <param name="message">
        /// Message to send
        /// </param>
        /// <param name="editor">
        /// Editor to target with the message. If not provided, the
        /// message is sent to all renderers.
        /// </param>
        /// <returns>
        /// a boolean indicating whether the message was successfully
        /// delivered to any renderer.
        /// </returns>
        abstract member postMessage: message: obj * ?editor: NotebookEditor -> Thenable<bool>

    [<RequireQualifiedAccess>]
    type NotebookCellKind =
        | Markup = 1
        | Code = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookCell =
        /// <summary>
        /// The index of this cell in its <see href="NotebookDocument.cellAtcontaining">notebook</see>". The
        /// index is updated when a cell is moved within its notebook. The index is <c>-1</c>
        /// when the cell has been removed from its notebook.
        /// </summary>
        abstract member index: float with get
        /// <summary>
        /// The <see href="NotebookDocumentnotebook">NotebookDocumentnotebook</see> that contains this cell.
        /// </summary>
        abstract member notebook: NotebookDocument with get
        /// <summary>
        /// The kind of this cell.
        /// </summary>
        abstract member kind: NotebookCellKind with get
        /// <summary>
        /// The <see href="TextDocumenttext">TextDocumenttext</see> of this cell, represented as text document.
        /// </summary>
        abstract member document: TextDocument with get
        /// <summary>
        /// The metadata of this cell. Can be anything but must be JSON-stringifyable.
        /// </summary>
        abstract member metadata: NotebookCell.metadata with get
        /// <summary>
        /// The outputs of this cell.
        /// </summary>
        abstract member outputs: ReadonlyArray<NotebookCellOutput> with get
        /// <summary>
        /// The most recent <see href="NotebookCellExecutionSummaryexecution">summary</see>" for this cell.
        /// </summary>
        abstract member executionSummary: NotebookCellExecutionSummary option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookDocument =
        /// <summary>
        /// The associated uri for this notebook.
        ///
        /// *Note* that most notebooks use the <c>file</c>-scheme, which means they are files on disk. However, **not** all notebooks are
        /// saved on disk and therefore the <c>scheme</c> must be checked before trying to access the underlying file or siblings on disk.
        /// </summary>
        abstract member uri: Uri with get
        /// <summary>
        /// The type of notebook.
        /// </summary>
        abstract member notebookType: string with get
        /// <summary>
        /// The version number of this notebook (it will strictly increase after each
        /// change, including undo/redo).
        /// </summary>
        abstract member version: float with get
        /// <summary>
        /// <c>true</c> if there are unpersisted changes.
        /// </summary>
        abstract member isDirty: bool with get
        /// <summary>
        /// Is this notebook representing an untitled file which has not been saved yet.
        /// </summary>
        abstract member isUntitled: bool with get
        /// <summary>
        /// <c>true</c> if the notebook has been closed. A closed notebook isn't synchronized anymore
        /// and won't be re-used when the same resource is opened again.
        /// </summary>
        abstract member isClosed: bool with get
        /// <summary>
        /// Arbitrary metadata for this notebook. Can be anything but must be JSON-stringifyable.
        /// </summary>
        abstract member metadata: NotebookDocument.metadata with get
        /// <summary>
        /// The number of cells in the notebook.
        /// </summary>
        abstract member cellCount: float with get
        /// <summary>
        /// Return the cell at the specified index. The index will be adjusted to the notebook.
        /// </summary>
        /// <param name="index">
        /// The index of the cell to retrieve.
        /// </param>
        /// <returns>
        /// A <see href="NotebookCell">cell</see>".
        /// </returns>
        abstract member cellAt: index: float -> NotebookCell
        /// <summary>
        /// Get the cells of this notebook. A subset can be retrieved by providing
        /// a range. The range will be adjusted to the notebook.
        /// </summary>
        /// <param name="range">
        /// A notebook range.
        /// </param>
        /// <returns>
        /// The cells contained by the range or all cells.
        /// </returns>
        abstract member getCells: ?range: NotebookRange -> ResizeArray<NotebookCell>
        /// <summary>
        /// Save the document. The saving will be handled by the corresponding <see href="NotebookSerializerserializer">NotebookSerializerserializer</see>.
        /// </summary>
        /// <returns>
        /// A promise that will resolve to true when the document
        /// has been saved. Will return false if the file was not dirty or when save failed.
        /// </returns>
        abstract member save: unit -> Thenable<bool>

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookDocumentCellChange =
        /// <summary>
        /// The affected cell.
        /// </summary>
        abstract member cell: NotebookCell with get
        /// <summary>
        /// The document of the cell or <c>undefined</c> when it did not change.
        ///
        /// *Note* that you should use the <see href="workspace.onDidChangeTextDocumentonDidChangeTextDocument">workspace.onDidChangeTextDocumentonDidChangeTextDocument</see>-event
        /// for detailed change information, like what edits have been performed.
        /// </summary>
        abstract member document: TextDocument option with get
        /// <summary>
        /// The new metadata of the cell or <c>undefined</c> when it did not change.
        /// </summary>
        abstract member metadata: NotebookDocumentCellChange.metadata option with get
        /// <summary>
        /// The new outputs of the cell or <c>undefined</c> when they did not change.
        /// </summary>
        abstract member outputs: ReadonlyArray<NotebookCellOutput> option with get
        /// <summary>
        /// The new execution summary of the cell or <c>undefined</c> when it did not change.
        /// </summary>
        abstract member executionSummary: NotebookCellExecutionSummary option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookDocumentContentChange =
        /// <summary>
        /// The range at which cells have been either added or removed.
        ///
        /// Note that no cells have been <see href="NotebookDocumentContentChange.removedCellsremoved">NotebookDocumentContentChange.removedCellsremoved</see>
        /// when this range is <see href="NotebookRange.isEmptyempty">NotebookRange.isEmptyempty</see>.
        /// </summary>
        abstract member range: NotebookRange with get
        /// <summary>
        /// Cells that have been added to the document.
        /// </summary>
        abstract member addedCells: ReadonlyArray<NotebookCell> with get
        /// <summary>
        /// Cells that have been removed from the document.
        /// </summary>
        abstract member removedCells: ReadonlyArray<NotebookCell> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookDocumentChangeEvent =
        /// <summary>
        /// The affected notebook.
        /// </summary>
        abstract member notebook: NotebookDocument with get
        /// <summary>
        /// The new metadata of the notebook or <c>undefined</c> when it did not change.
        /// </summary>
        abstract member metadata: NotebookDocumentChangeEvent.metadata option with get
        /// <summary>
        /// An array of content changes describing added or removed <see href="NotebookCellcells">NotebookCellcells</see>.
        /// </summary>
        abstract member contentChanges: ReadonlyArray<NotebookDocumentContentChange> with get
        /// <summary>
        /// An array of <see href="NotebookDocumentCellChangecell">changes</see>".
        /// </summary>
        abstract member cellChanges: ReadonlyArray<NotebookDocumentCellChange> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookDocumentWillSaveEvent =
        /// <summary>
        /// A cancellation token.
        /// </summary>
        abstract member token: CancellationToken with get
        /// <summary>
        /// The <see href="NotebookDocumentnotebook">document</see>" that will be saved.
        /// </summary>
        abstract member notebook: NotebookDocument with get
        /// <summary>
        /// The reason why save was triggered.
        /// </summary>
        abstract member reason: TextDocumentSaveReason with get
        /// <summary>
        /// Allows to pause the event loop and to apply <see href="WorkspaceEditworkspace">edit</see>".
        /// Edits of subsequent calls to this function will be applied in order. The
        /// edits will be *ignored* if concurrent modifications of the notebook document happened.
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillSaveNotebookDocument(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event loop until the provided thenable resolved.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that resolves to <see href="WorkspaceEdit">workspace edit</see>".
        /// </param>
        abstract member waitUntil: thenable: Thenable<WorkspaceEdit> -> unit
        /// <summary>
        /// Allows to pause the event loop and to apply <see href="WorkspaceEditworkspace">edit</see>".
        /// Edits of subsequent calls to this function will be applied in order. The
        /// edits will be *ignored* if concurrent modifications of the notebook document happened.
        ///
        /// *Note:* This function can only be called during event dispatch and not
        /// in an asynchronous manner:
        ///
        /// <code lang="ts">
        /// workspace.onWillSaveNotebookDocument(event => {
        /// 	// async, will *throw* an error
        /// 	setTimeout(() => event.waitUntil(promise));
        ///
        /// 	// sync, OK
        /// 	event.waitUntil(promise);
        /// })
        /// </code>
        /// Allows to pause the event loop until the provided thenable resolved.
        ///
        /// *Note:* This function can only be called during event dispatch.
        /// </summary>
        /// <param name="thenable">
        /// A thenable that delays saving.
        /// </param>
        abstract member waitUntil: thenable: Thenable<obj> -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookCellExecutionSummary =
        /// <summary>
        /// The order in which the execution happened.
        /// </summary>
        abstract member executionOrder: float option with get
        /// <summary>
        /// If the execution finished successfully.
        /// </summary>
        abstract member success: bool option with get
        /// <summary>
        /// The times at which execution started and ended, as unix timestamps
        /// </summary>
        abstract member timing: NotebookCellExecutionSummary.timing option with get

    /// <summary>
    /// A notebook range represents an ordered pair of two cell indices.
    /// It is guaranteed that start is less than or equal to end.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookRange =
        /// <summary>
        /// The zero-based start index of this range.
        /// </summary>
        abstract member start: float with get
        /// <summary>
        /// The exclusive end index of this range (zero-based).
        /// </summary>
        abstract member ``end``: float with get
        /// <summary>
        /// <c>true</c> if <c>start</c> and <c>end</c> are equal.
        /// </summary>
        abstract member isEmpty: bool with get
        /// <summary>
        /// Derive a new range for this range.
        /// </summary>
        /// <param name="change">
        /// An object that describes a change to this range.
        /// </param>
        /// <returns>
        /// A range that reflects the given change. Will return <c>this</c> range if the change
        /// is not changing anything.
        /// </returns>
        abstract member ``with``: change: NotebookRange.``with``.change -> NotebookRange

    /// <summary>
    /// One representation of a <see href="NotebookCellOutputnotebook">output</see>", defined by MIME type and data.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookCellOutputItem =
        /// <summary>
        /// Factory function to create a <c>NotebookCellOutputItem</c> from a string.
        ///
        /// *Note* that an UTF-8 encoder is used to create bytes for the string.
        /// </summary>
        /// <param name="value">
        /// A string.
        /// </param>
        /// <param name="mime">
        /// Optional MIME type, defaults to <c>text/plain</c>.
        /// </param>
        /// <returns>
        /// A new output item object.
        /// </returns>
        static member inline text (value: string, ?mime: string): NotebookCellOutputItem =
            emitJsExpr (value, mime) $$"""
import { NotebookCellOutputItem } from "vscode";
NotebookCellOutputItem.text($0, $1)"""
        /// <summary>
        /// Factory function to create a <c>NotebookCellOutputItem</c> from
        /// a JSON object.
        ///
        /// *Note* that this function is not expecting "stringified JSON" but
        /// an object that can be stringified. This function will throw an error
        /// when the passed value cannot be JSON-stringified.
        /// </summary>
        /// <param name="value">
        /// A JSON-stringifyable value.
        /// </param>
        /// <param name="mime">
        /// Optional MIME type, defaults to <c>application/json</c>
        /// </param>
        /// <returns>
        /// A new output item object.
        /// </returns>
        static member inline json (value: obj, ?mime: string): NotebookCellOutputItem =
            emitJsExpr (value, mime) $$"""
import { NotebookCellOutputItem } from "vscode";
NotebookCellOutputItem.json($0, $1)"""
        /// <summary>
        /// Factory function to create a <c>NotebookCellOutputItem</c> that uses
        /// uses the <c>application/vnd.code.notebook.stdout</c> mime type.
        /// </summary>
        /// <param name="value">
        /// A string.
        /// </param>
        /// <returns>
        /// A new output item object.
        /// </returns>
        static member inline stdout (value: string): NotebookCellOutputItem =
            emitJsExpr (value) $$"""
import { NotebookCellOutputItem } from "vscode";
NotebookCellOutputItem.stdout($0)"""
        /// <summary>
        /// Factory function to create a <c>NotebookCellOutputItem</c> that uses
        /// uses the <c>application/vnd.code.notebook.stderr</c> mime type.
        /// </summary>
        /// <param name="value">
        /// A string.
        /// </param>
        /// <returns>
        /// A new output item object.
        /// </returns>
        static member inline stderr (value: string): NotebookCellOutputItem =
            emitJsExpr (value) $$"""
import { NotebookCellOutputItem } from "vscode";
NotebookCellOutputItem.stderr($0)"""
        /// <summary>
        /// Factory function to create a <c>NotebookCellOutputItem</c> that uses
        /// uses the <c>application/vnd.code.notebook.error</c> mime type.
        /// </summary>
        /// <param name="value">
        /// An error object.
        /// </param>
        /// <returns>
        /// A new output item object.
        /// </returns>
        static member inline error (value: Exception): NotebookCellOutputItem =
            emitJsExpr (value) $$"""
import { NotebookCellOutputItem } from "vscode";
NotebookCellOutputItem.error($0)"""
        /// <summary>
        /// The mime type which determines how the {@linkcode NotebookCellOutputItem.datadata}-property
        /// is interpreted.
        ///
        /// Notebooks have built-in support for certain mime-types, extensions can add support for new
        /// types and override existing types.
        /// </summary>
        abstract member mime: string with get, set
        /// <summary>
        /// The data of this output item. Must always be an array of unsigned 8-bit integers.
        /// </summary>
        abstract member data: JS.Uint8Array with get, set

    /// <summary>
    /// Notebook cell output represents a result of executing a cell. It is a container type for multiple
    /// <see href="NotebookCellOutputItemoutput">items</see>" where contained items represent the same result but
    /// use different MIME types.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookCellOutput =
        /// <summary>
        /// The output items of this output. Each item must represent the same result. _Note_ that repeated
        /// MIME types per output is invalid and that the editor will just pick one of them.
        ///
        /// <code lang="ts">
        /// new vscode.NotebookCellOutput([
        /// 	vscode.NotebookCellOutputItem.text('Hello', 'text/plain'),
        /// 	vscode.NotebookCellOutputItem.text('<i>Hello</i>', 'text/html'),
        /// 	vscode.NotebookCellOutputItem.text('_Hello_', 'text/markdown'),
        /// 	vscode.NotebookCellOutputItem.text('Hey', 'text/plain'), // INVALID: repeated type, editor will pick just one
        /// ])
        /// </code>
        /// </summary>
        abstract member items: ResizeArray<NotebookCellOutputItem> with get, set
        /// <summary>
        /// Arbitrary metadata for this cell output. Can be anything but must be JSON-stringifyable.
        /// </summary>
        abstract member metadata: NotebookCellOutput.metadata option with get, set

    /// <summary>
    /// NotebookCellData is the raw representation of notebook cells. Its is part of {@linkcode NotebookData}.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookCellData =
        /// <summary>
        /// The <see href="NotebookCellKindkind">NotebookCellKindkind</see> of this cell data.
        /// </summary>
        abstract member kind: NotebookCellKind with get, set
        /// <summary>
        /// The source value of this cell data - either source code or formatted text.
        /// </summary>
        abstract member value: string with get, set
        /// <summary>
        /// The language identifier of the source value of this cell data. Any value from
        /// {@linkcode languages.getLanguagesgetLanguages} is possible.
        /// </summary>
        abstract member languageId: string with get, set
        /// <summary>
        /// The outputs of this cell data.
        /// </summary>
        abstract member outputs: ResizeArray<NotebookCellOutput> option with get, set
        /// <summary>
        /// Arbitrary metadata of this cell data. Can be anything but must be JSON-stringifyable.
        /// </summary>
        abstract member metadata: NotebookCellData.metadata option with get, set
        /// <summary>
        /// The execution summary of this cell data.
        /// </summary>
        abstract member executionSummary: NotebookCellExecutionSummary option with get, set

    /// <summary>
    /// Raw representation of a notebook.
    ///
    /// Extensions are responsible for creating {@linkcode NotebookData} so that the editor
    /// can create a {@linkcode NotebookDocument}.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookData =
        /// <summary>
        /// The cell data of this notebook data.
        /// </summary>
        abstract member cells: ResizeArray<NotebookCellData> with get, set
        /// <summary>
        /// Arbitrary metadata of notebook data.
        /// </summary>
        abstract member metadata: NotebookData.metadata option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookSerializer =
        /// <summary>
        /// Deserialize contents of a notebook file into the notebook data structure.
        /// </summary>
        /// <param name="content">
        /// Contents of a notebook file.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// Notebook data or a thenable that resolves to such.
        /// </returns>
        abstract member deserializeNotebook: content: JS.Uint8Array * token: CancellationToken -> U2<NotebookData, Thenable<NotebookData>>
        /// <summary>
        /// Serialize notebook data into file contents.
        /// </summary>
        /// <param name="data">
        /// A notebook data structure.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of bytes or a thenable that resolves to such.
        /// </returns>
        abstract member serializeNotebook: data: NotebookData * token: CancellationToken -> U2<JS.Uint8Array, Thenable<JS.Uint8Array>>

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookDocumentContentOptions =
        /// <summary>
        /// Controls if output change events will trigger notebook document content change events and
        /// if it will be used in the diff editor, defaults to false. If the content provider doesn't
        /// persist the outputs in the file document, this should be set to true.
        /// </summary>
        abstract member transientOutputs: bool option with get, set
        /// <summary>
        /// Controls if a cell metadata property change event will trigger notebook document content
        /// change events and if it will be used in the diff editor, defaults to false. If the
        /// content provider doesn't persist a metadata property in the file document, it should be
        /// set to true.
        /// </summary>
        abstract member transientCellMetadata: NotebookDocumentContentOptions.transientCellMetadata option with get, set
        /// <summary>
        /// Controls if a document metadata property change event will trigger notebook document
        /// content change event and if it will be used in the diff editor, defaults to false. If the
        /// content provider doesn't persist a metadata property in the file document, it should be
        /// set to true.
        /// </summary>
        abstract member transientDocumentMetadata: NotebookDocumentContentOptions.transientDocumentMetadata option with get, set

    [<RequireQualifiedAccess>]
    type NotebookControllerAffinity =
        | Default = 1
        | Preferred = 2

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookController =
        /// <summary>
        /// The identifier of this notebook controller.
        ///
        /// _Note_ that controllers are remembered by their identifier and that extensions should use
        /// stable identifiers across sessions.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The notebook type this controller is for.
        /// </summary>
        abstract member notebookType: string with get
        /// <summary>
        /// An array of language identifiers that are supported by this
        /// controller. Any language identifier from {@linkcode languages.getLanguagesgetLanguages}
        /// is possible. When falsy all languages are supported.
        ///
        /// Samples:
        /// <code lang="js">
        /// // support JavaScript and TypeScript
        /// myController.supportedLanguages = ['javascript', 'typescript']
        ///
        /// // support all languages
        /// myController.supportedLanguages = undefined; // falsy
        /// myController.supportedLanguages = []; // falsy
        /// </code>
        /// </summary>
        abstract member supportedLanguages: ResizeArray<string> option with get, set
        /// <summary>
        /// The human-readable label of this notebook controller.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// The human-readable description which is rendered less prominent.
        /// </summary>
        abstract member description: string option with get, set
        /// <summary>
        /// The human-readable detail which is rendered less prominent.
        /// </summary>
        abstract member detail: string option with get, set
        /// <summary>
        /// Whether this controller supports execution order so that the
        /// editor can render placeholders for them.
        /// </summary>
        abstract member supportsExecutionOrder: bool option with get, set
        /// <summary>
        /// Create a cell execution task.
        ///
        /// _Note_ that there can only be one execution per cell at a time and that an error is thrown if
        /// a cell execution is created while another is still active.
        ///
        /// This should be used in response to the <see href="NotebookController.executeHandlerexecution">handler</see>"
        /// being called or when cell execution has been started else, e.g when a cell was already
        /// executing or when cell execution was triggered from another source.
        /// </summary>
        /// <param name="cell">
        /// The notebook cell for which to create the execution.
        /// </param>
        /// <returns>
        /// A notebook cell execution.
        /// </returns>
        abstract member createNotebookCellExecution: cell: NotebookCell -> NotebookCellExecution
        /// <summary>
        /// The execute handler is invoked when the run gestures in the UI are selected, e.g Run Cell, Run All,
        /// Run Selection etc. The execute handler is responsible for creating and managing <see href="NotebookCellExecutionexecution">NotebookCellExecutionexecution</see>-objects.
        /// </summary>
        abstract member executeHandler: NotebookController.executeHandler with get, set
        /// <summary>
        /// Optional interrupt handler.
        ///
        /// By default cell execution is canceled via <see href="NotebookCellExecution.tokentokens">NotebookCellExecution.tokentokens</see>. Cancellation
        /// tokens require that a controller can keep track of its execution so that it can cancel a specific execution at a later
        /// point. Not all scenarios allow for that, eg. REPL-style controllers often work by interrupting whatever is currently
        /// running. For those cases the interrupt handler exists - it can be thought of as the equivalent of <c>SIGINT</c>
        /// or <c>Control+C</c> in terminals.
        ///
        /// _Note_ that supporting <see href="NotebookCellExecution.tokencancellation">tokens</see>" is preferred and that interrupt handlers should
        /// only be used when tokens cannot be supported.
        /// </summary>
        abstract member interruptHandler: (NotebookDocument -> U2<unit, Thenable<unit>>) option with get, set
        /// <summary>
        /// An event that fires whenever a controller has been selected or un-selected for a notebook document.
        ///
        /// There can be multiple controllers for a notebook and in that case a controllers needs to be _selected_. This is a user gesture
        /// and happens either explicitly or implicitly when interacting with a notebook for which a controller was _suggested_. When possible,
        /// the editor _suggests_ a controller that is most likely to be _selected_.
        ///
        /// _Note_ that controller selection is persisted (by the controllers <see href="NotebookController.idid">NotebookController.idid</see>) and restored as soon as a
        /// controller is re-created or as a notebook is <see href="workspace.onDidOpenNotebookDocumentopened">workspace.onDidOpenNotebookDocumentopened</see>.
        /// </summary>
        abstract member onDidChangeSelectedNotebooks: Event<NotebookController.onDidChangeSelectedNotebooks> with get
        /// <summary>
        /// A controller can set affinities for specific notebook documents. This allows a controller
        /// to be presented more prominent for some notebooks.
        /// </summary>
        /// <param name="notebook">
        /// The notebook for which a priority is set.
        /// </param>
        /// <param name="affinity">
        /// A controller affinity
        /// </param>
        abstract member updateNotebookAffinity: notebook: NotebookDocument * affinity: NotebookControllerAffinity -> unit
        /// <summary>
        /// Dispose and free associated resources.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookCellExecution =
        /// <summary>
        /// The <see href="NotebookCellcell">NotebookCellcell</see> for which this execution has been created.
        /// </summary>
        abstract member cell: NotebookCell with get
        /// <summary>
        /// A cancellation token which will be triggered when the cell execution is canceled
        /// from the UI.
        ///
        /// _Note_ that the cancellation token will not be triggered when the <see href="NotebookControllercontroller">NotebookControllercontroller</see>
        /// that created this execution uses an <see href="NotebookController.interruptHandlerinterrupt-handler">NotebookController.interruptHandlerinterrupt-handler</see>.
        /// </summary>
        abstract member token: CancellationToken with get
        /// <summary>
        /// Set and unset the order of this cell execution.
        /// </summary>
        abstract member executionOrder: float option with get, set
        /// <summary>
        /// Signal that the execution has begun.
        /// </summary>
        /// <param name="startTime">
        /// The time that execution began, in milliseconds in the Unix epoch. Used to drive the clock
        /// that shows for how long a cell has been running. If not given, the clock won't be shown.
        /// </param>
        abstract member start: ?startTime: float -> unit
        /// <summary>
        /// Signal that execution has ended.
        /// </summary>
        /// <param name="success">
        /// If true, a green check is shown on the cell status bar.
        /// If false, a red X is shown.
        /// If undefined, no check or X icon is shown.
        /// </param>
        /// <param name="endTime">
        /// The time that execution finished, in milliseconds in the Unix epoch.
        /// </param>
        abstract member ``end``: success: bool option * ?endTime: float -> unit
        /// <summary>
        /// Clears the output of the cell that is executing or of another cell that is affected by this execution.
        /// </summary>
        /// <param name="cell">
        /// Cell for which output is cleared. Defaults to the <see href="NotebookCellExecution.cell">cell</see>" of
        /// this execution.
        /// </param>
        /// <returns>
        /// A thenable that resolves when the operation finished.
        /// </returns>
        abstract member clearOutput: ?cell: NotebookCell -> Thenable<unit>
        /// <summary>
        /// Replace the output of the cell that is executing or of another cell that is affected by this execution.
        /// </summary>
        /// <param name="out">
        /// Output that replaces the current output.
        /// </param>
        /// <param name="cell">
        /// Cell for which output is cleared. Defaults to the <see href="NotebookCellExecution.cell">cell</see>" of
        /// this execution.
        /// </param>
        /// <returns>
        /// A thenable that resolves when the operation finished.
        /// </returns>
        abstract member replaceOutput: out: U2<NotebookCellOutput, ReadonlyArray<NotebookCellOutput>> * ?cell: NotebookCell -> Thenable<unit>
        /// <summary>
        /// Append to the output of the cell that is executing or to another cell that is affected by this execution.
        /// </summary>
        /// <param name="out">
        /// Output that is appended to the current output.
        /// </param>
        /// <param name="cell">
        /// Cell for which output is cleared. Defaults to the <see href="NotebookCellExecution.cell">cell</see>" of
        /// this execution.
        /// </param>
        /// <returns>
        /// A thenable that resolves when the operation finished.
        /// </returns>
        abstract member appendOutput: out: U2<NotebookCellOutput, ReadonlyArray<NotebookCellOutput>> * ?cell: NotebookCell -> Thenable<unit>
        /// <summary>
        /// Replace all output items of existing cell output.
        /// </summary>
        /// <param name="items">
        /// Output items that replace the items of existing output.
        /// </param>
        /// <param name="output">
        /// Output object that already exists.
        /// </param>
        /// <returns>
        /// A thenable that resolves when the operation finished.
        /// </returns>
        abstract member replaceOutputItems: items: U2<NotebookCellOutputItem, ReadonlyArray<NotebookCellOutputItem>> * output: NotebookCellOutput -> Thenable<unit>
        /// <summary>
        /// Append output items to existing cell output.
        /// </summary>
        /// <param name="items">
        /// Output items that are append to existing output.
        /// </param>
        /// <param name="output">
        /// Output object that already exists.
        /// </param>
        /// <returns>
        /// A thenable that resolves when the operation finished.
        /// </returns>
        abstract member appendOutputItems: items: U2<NotebookCellOutputItem, ReadonlyArray<NotebookCellOutputItem>> * output: NotebookCellOutput -> Thenable<unit>

    [<RequireQualifiedAccess>]
    type NotebookCellStatusBarAlignment =
        | Left = 1
        | Right = 2

    /// <summary>
    /// A contribution to a cell's status bar
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookCellStatusBarItem =
        /// <summary>
        /// The text to show for the item.
        /// </summary>
        abstract member text: string with get, set
        /// <summary>
        /// Whether the item is aligned to the left or right.
        /// </summary>
        abstract member alignment: NotebookCellStatusBarAlignment with get, set
        /// <summary>
        /// An optional {@linkcode Command} or identifier of a command to run on click.
        ///
        /// The command must be <see href="commands.getCommandsknown">commands.getCommandsknown</see>.
        ///
        /// Note that if this is a {@linkcode Command} object, only the {@linkcode Command.commandcommand} and {@linkcode Command.argumentsarguments}
        /// are used by the editor.
        /// </summary>
        abstract member command: U2<string, Command> option with get, set
        /// <summary>
        /// A tooltip to show when the item is hovered.
        /// </summary>
        abstract member tooltip: string option with get, set
        /// <summary>
        /// The priority of the item. A higher value item will be shown more to the left.
        /// </summary>
        abstract member priority: float option with get, set
        /// <summary>
        /// Accessibility information used when a screen reader interacts with this item.
        /// </summary>
        abstract member accessibilityInformation: AccessibilityInformation option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type NotebookCellStatusBarItemProvider =
        /// <summary>
        /// An optional event to signal that statusbar items have changed. The provide method will be called again.
        /// </summary>
        abstract member onDidChangeCellStatusBarItems: Event<unit> option with get, set
        /// <summary>
        /// The provider will be called when the cell scrolls into view, when its content, outputs, language, or metadata change, and when it changes execution state.
        /// </summary>
        /// <param name="cell">
        /// The cell for which to return items.
        /// </param>
        /// <param name="token">
        /// A token triggered if this request should be cancelled.
        /// </param>
        /// <returns>
        /// One or more <see href="NotebookCellStatusBarItem">cell statusbar items</see>"
        /// </returns>
        abstract member provideCellStatusBarItems: cell: NotebookCell * token: CancellationToken -> ProviderResult<U2<NotebookCellStatusBarItem, ResizeArray<NotebookCellStatusBarItem>>>

    module notebooks =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Creates a new notebook controller.
            /// </summary>
            /// <param name="id">
            /// Identifier of the controller. Must be unique per extension.
            /// </param>
            /// <param name="notebookType">
            /// A notebook type for which this controller is for.
            /// </param>
            /// <param name="label">
            /// The label of the controller.
            /// </param>
            /// <param name="handler">
            /// The execute-handler of the controller.
            /// </param>
            /// <returns>
            /// A new notebook controller.
            /// </returns>
            [<Emit("$0.createNotebookController($1...)")>]
            abstract member createNotebookController: id: string * notebookType: string * label: string * ?handler: Exports.createNotebookController.handler -> NotebookController
            /// <summary>
            /// Register a <see href="NotebookCellStatusBarItemProvidercell">statusbar item provider</see>" for the given notebook type.
            /// </summary>
            /// <param name="notebookType">
            /// The notebook type to register for.
            /// </param>
            /// <param name="provider">
            /// A cell status bar provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerNotebookCellStatusBarItemProvider($1...)")>]
            abstract member registerNotebookCellStatusBarItemProvider: notebookType: string * provider: NotebookCellStatusBarItemProvider -> Disposable
            /// <summary>
            /// Creates a new messaging instance used to communicate with a specific renderer.
            ///
            /// * *Note 1:* Extensions can only create renderer that they have defined in their <c>package.json</c>-file
            /// * *Note 2:* A renderer only has access to messaging if <c>requiresMessaging</c> is set to <c>always</c> or <c>optional</c> in
            /// its <c>notebookRenderer</c> contribution.
            /// </summary>
            /// <param name="rendererId">
            /// The renderer ID to communicate with
            /// </param>
            /// <returns>
            /// A new notebook renderer messaging object.
            /// </returns>
            [<Emit("$0.createRendererMessaging($1...)")>]
            abstract member createRendererMessaging: rendererId: string -> NotebookRendererMessaging

        module Exports =

            module createNotebookController =

                type handler =
                    delegate of cells: ResizeArray<NotebookCell> * notebook: NotebookDocument * controller: NotebookController -> U2<unit, Thenable<unit>>

    [<AllowNullLiteral>]
    [<Interface>]
    type SourceControlInputBox =
        /// <summary>
        /// Setter and getter for the contents of the input box.
        /// </summary>
        abstract member value: string with get, set
        /// <summary>
        /// A string to show as placeholder in the input box to guide the user.
        /// </summary>
        abstract member placeholder: string with get, set
        /// <summary>
        /// Controls whether the input box is enabled (default is <c>true</c>).
        /// </summary>
        abstract member enabled: bool with get, set
        /// <summary>
        /// Controls whether the input box is visible (default is <c>true</c>).
        /// </summary>
        abstract member visible: bool with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type QuickDiffProvider =
        /// <summary>
        /// Provide a <see href="Uri">Uri</see> to the original resource of any given resource uri.
        /// </summary>
        /// <param name="uri">
        /// The uri of the resource open in a text editor.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// A thenable that resolves to uri of the matching original resource.
        /// </returns>
        abstract member provideOriginalResource: uri: Uri * token: CancellationToken -> ProviderResult<Uri>

    [<AllowNullLiteral>]
    [<Interface>]
    type SourceControlResourceThemableDecorations =
        /// <summary>
        /// The icon path for a specific
        /// <see href="SourceControlResourceStatesource">control resource state</see>".
        /// </summary>
        abstract member iconPath: U3<string, Uri, ThemeIcon> option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type SourceControlResourceDecorations =
        inherit SourceControlResourceThemableDecorations
        /// <summary>
        /// Whether the <see href="SourceControlResourceStatesource">control resource state</see>" should
        /// be striked-through in the UI.
        /// </summary>
        abstract member strikeThrough: bool option with get
        /// <summary>
        /// Whether the <see href="SourceControlResourceStatesource">control resource state</see>" should
        /// be faded in the UI.
        /// </summary>
        abstract member faded: bool option with get
        /// <summary>
        /// The title for a specific
        /// <see href="SourceControlResourceStatesource">control resource state</see>".
        /// </summary>
        abstract member tooltip: string option with get
        /// <summary>
        /// The light theme decorations.
        /// </summary>
        abstract member light: SourceControlResourceThemableDecorations option with get
        /// <summary>
        /// The dark theme decorations.
        /// </summary>
        abstract member dark: SourceControlResourceThemableDecorations option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type SourceControlResourceState =
        /// <summary>
        /// The <see href="Uri">Uri</see> of the underlying resource inside the workspace.
        /// </summary>
        abstract member resourceUri: Uri with get
        /// <summary>
        /// The <see href="Command">Command</see> which should be run when the resource
        /// state is open in the Source Control viewlet.
        /// </summary>
        abstract member command: Command option with get
        /// <summary>
        /// The <see href="SourceControlResourceDecorationsdecorations">SourceControlResourceDecorationsdecorations</see> for this source control
        /// resource state.
        /// </summary>
        abstract member decorations: SourceControlResourceDecorations option with get
        /// <summary>
        /// Context value of the resource state. This can be used to contribute resource specific actions.
        /// For example, if a resource is given a context value as <c>diffable</c>. When contributing actions to <c>scm/resourceState/context</c>
        /// using <c>menus</c> extension point, you can specify context value for key <c>scmResourceState</c> in <c>when</c> expressions, like <c>scmResourceState == diffable</c>.
        /// <code lang="json">
        /// "contributes": {
        ///   "menus": {
        ///     "scm/resourceState/context": [
        ///       {
        ///         "command": "extension.diff",
        ///         "when": "scmResourceState == diffable"
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// This will show action <c>extension.diff</c> only for resources with <c>contextValue</c> is <c>diffable</c>.
        /// </summary>
        abstract member contextValue: string option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type SourceControlResourceGroup =
        /// <summary>
        /// The id of this source control resource group.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The label of this source control resource group.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// Whether this source control resource group is hidden when it contains
        /// no <see href="SourceControlResourceStatesource">control resource states</see>".
        /// </summary>
        abstract member hideWhenEmpty: bool option with get, set
        /// <summary>
        /// Context value of the resource group. This can be used to contribute resource group specific actions.
        /// For example, if a resource group is given a context value of <c>exportable</c>, when contributing actions to <c>scm/resourceGroup/context</c>
        /// using <c>menus</c> extension point, you can specify context value for key <c>scmResourceGroupState</c> in <c>when</c> expressions, like <c>scmResourceGroupState == exportable</c>.
        /// <code lang="json">
        /// "contributes": {
        ///   "menus": {
        ///     "scm/resourceGroup/context": [
        ///       {
        ///         "command": "extension.export",
        ///         "when": "scmResourceGroupState == exportable"
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// This will show action <c>extension.export</c> only for resource groups with <c>contextValue</c> equal to <c>exportable</c>.
        /// </summary>
        abstract member contextValue: string option with get, set
        /// <summary>
        /// This group's collection of
        /// <see href="SourceControlResourceStatesource">control resource states</see>".
        /// </summary>
        abstract member resourceStates: ResizeArray<SourceControlResourceState> with get, set
        /// <summary>
        /// Dispose this source control resource group.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type SourceControl =
        /// <summary>
        /// The id of this source control.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The human-readable label of this source control.
        /// </summary>
        abstract member label: string with get
        /// <summary>
        /// The (optional) Uri of the root of this source control.
        /// </summary>
        abstract member rootUri: Uri option with get
        /// <summary>
        /// The <see href="SourceControlInputBoxinput">box</see>" for this source control.
        /// </summary>
        abstract member inputBox: SourceControlInputBox with get
        /// <summary>
        /// The UI-visible count of <see href="SourceControlResourceStateresource">states</see>" of
        /// this source control.
        ///
        /// If undefined, this source control will
        /// - display its UI-visible count as zero, and
        /// - contribute the count of its <see href="SourceControlResourceStateresource">states</see>" to the UI-visible aggregated count for all source controls
        /// </summary>
        abstract member count: float option with get, set
        /// <summary>
        /// An optional <see href="QuickDiffProviderquick">diff provider</see>".
        /// </summary>
        abstract member quickDiffProvider: QuickDiffProvider option with get, set
        /// <summary>
        /// Optional commit template string.
        ///
        /// The Source Control viewlet will populate the Source Control
        /// input with this value when appropriate.
        /// </summary>
        abstract member commitTemplate: string option with get, set
        /// <summary>
        /// Optional accept input command.
        ///
        /// This command will be invoked when the user accepts the value
        /// in the Source Control input.
        /// </summary>
        abstract member acceptInputCommand: Command option with get, set
        /// <summary>
        /// Optional status bar commands.
        ///
        /// These commands will be displayed in the editor's status bar.
        /// </summary>
        abstract member statusBarCommands: ResizeArray<Command> option with get, set
        /// <summary>
        /// Create a new <see href="SourceControlResourceGroupresource">group</see>".
        /// </summary>
        abstract member createResourceGroup: id: string * label: string -> SourceControlResourceGroup
        /// <summary>
        /// Dispose this source control.
        /// </summary>
        abstract member dispose: unit -> unit

    module scm =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// The <see href="SourceControlInputBoxinput">box</see>" for the last source control
            /// created by the extension.
            /// </summary>
            [<Emit("$0.inputBox")>]
            [<Obsolete("Use SourceControl.inputBox instead")>]
            abstract member inputBox: SourceControlInputBox
            /// <summary>
            /// Creates a new <see href="SourceControlsource">control</see>" instance.
            /// </summary>
            /// <param name="id">
            /// An <c>id</c> for the source control. Something short, e.g.: <c>git</c>.
            /// </param>
            /// <param name="label">
            /// A human-readable string for the source control. E.g.: <c>Git</c>.
            /// </param>
            /// <param name="rootUri">
            /// An optional Uri of the root of the source control. E.g.: <c>Uri.parse(workspaceRoot)</c>.
            /// </param>
            /// <returns>
            /// An instance of <see href="SourceControl">source control</see>".
            /// </returns>
            [<Emit("$0.createSourceControl($1...)")>]
            abstract member createSourceControl: id: string * label: string * ?rootUri: Uri -> SourceControl

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugProtocolMessage =
        interface end

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugProtocolSource =
        interface end

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugProtocolBreakpoint =
        interface end

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugConfiguration =
        /// <summary>
        /// The type of the debug session.
        /// </summary>
        abstract member ``type``: string with get, set
        /// <summary>
        /// The name of the debug session.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The request type of the debug session.
        /// </summary>
        abstract member request: string with get, set
        [<EmitIndexer>]
        abstract member Item: key: string -> obj with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugSession =
        /// <summary>
        /// The unique ID of this debug session.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The debug session's type from the <see href="DebugConfigurationdebug">configuration</see>".
        /// </summary>
        abstract member ``type``: string with get
        /// <summary>
        /// The parent session of this debug session, if it was created as a child.
        /// </summary>
        abstract member parentSession: DebugSession option with get
        /// <summary>
        /// The debug session's name is initially taken from the <see href="DebugConfigurationdebug">configuration</see>".
        /// Any changes will be properly reflected in the UI.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The workspace folder of this session or <c>undefined</c> for a folderless setup.
        /// </summary>
        abstract member workspaceFolder: WorkspaceFolder option with get
        /// <summary>
        /// The "resolved" <see href="DebugConfigurationdebug">configuration</see>" of this session.
        /// "Resolved" means that
        /// - all variables have been substituted and
        /// - platform specific attribute sections have been "flattened" for the matching platform and removed for non-matching platforms.
        /// </summary>
        abstract member configuration: DebugConfiguration with get
        /// <summary>
        /// Send a custom request to the debug adapter.
        /// </summary>
        abstract member customRequest: command: string * ?args: obj -> Thenable<obj>
        /// <summary>
        /// Maps a breakpoint in the editor to the corresponding Debug Adapter Protocol (DAP) breakpoint that is managed by the debug adapter of the debug session.
        /// If no DAP breakpoint exists (either because the editor breakpoint was not yet registered or because the debug adapter is not interested in the breakpoint), the value <c>undefined</c> is returned.
        /// </summary>
        /// <param name="breakpoint">
        /// A <see href="Breakpoint">Breakpoint</see> in the editor.
        /// </param>
        /// <returns>
        /// A promise that resolves to the Debug Adapter Protocol breakpoint or <c>undefined</c>.
        /// </returns>
        abstract member getDebugProtocolBreakpoint: breakpoint: Breakpoint -> Thenable<DebugProtocolBreakpoint option>

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugSessionCustomEvent =
        /// <summary>
        /// The <see href="DebugSessiondebug">session</see>" for which the custom event was received.
        /// </summary>
        abstract member session: DebugSession with get
        /// <summary>
        /// Type of event.
        /// </summary>
        abstract member event: string with get
        /// <summary>
        /// Event specific information.
        /// </summary>
        abstract member body: obj with get

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugConfigurationProvider =
        /// <summary>
        /// Provides <see href="DebugConfigurationdebug">configuration</see>" to the debug service. If more than one debug configuration provider is
        /// registered for the same type, debug configurations are concatenated in arbitrary order.
        /// </summary>
        /// <param name="folder">
        /// The workspace folder for which the configurations are used or <c>undefined</c> for a folderless setup.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of <see href="DebugConfiguration">debug configurations</see>".
        /// </returns>
        abstract member provideDebugConfigurations: folder: WorkspaceFolder option * ?token: CancellationToken -> ProviderResult<ResizeArray<DebugConfiguration>>
        /// <summary>
        /// Resolves a <see href="DebugConfigurationdebug">configuration</see>" by filling in missing values or by adding/changing/removing attributes.
        /// If more than one debug configuration provider is registered for the same type, the resolveDebugConfiguration calls are chained
        /// in arbitrary order and the initial debug configuration is piped through the chain.
        /// Returning the value 'undefined' prevents the debug session from starting.
        /// Returning the value 'null' prevents the debug session from starting and opens the underlying debug configuration instead.
        /// </summary>
        /// <param name="folder">
        /// The workspace folder from which the configuration originates from or <c>undefined</c> for a folderless setup.
        /// </param>
        /// <param name="debugConfiguration">
        /// The <see href="DebugConfiguration">debug configuration</see>" to resolve.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved debug configuration or undefined or null.
        /// </returns>
        abstract member resolveDebugConfiguration: folder: WorkspaceFolder option * debugConfiguration: DebugConfiguration * ?token: CancellationToken -> ProviderResult<DebugConfiguration>
        /// <summary>
        /// This hook is directly called after 'resolveDebugConfiguration' but with all variables substituted.
        /// It can be used to resolve or verify a <see href="DebugConfigurationdebug">configuration</see>" by filling in missing values or by adding/changing/removing attributes.
        /// If more than one debug configuration provider is registered for the same type, the 'resolveDebugConfigurationWithSubstitutedVariables' calls are chained
        /// in arbitrary order and the initial debug configuration is piped through the chain.
        /// Returning the value 'undefined' prevents the debug session from starting.
        /// Returning the value 'null' prevents the debug session from starting and opens the underlying debug configuration instead.
        /// </summary>
        /// <param name="folder">
        /// The workspace folder from which the configuration originates from or <c>undefined</c> for a folderless setup.
        /// </param>
        /// <param name="debugConfiguration">
        /// The <see href="DebugConfiguration">debug configuration</see>" to resolve.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved debug configuration or undefined or null.
        /// </returns>
        abstract member resolveDebugConfigurationWithSubstitutedVariables: folder: WorkspaceFolder option * debugConfiguration: DebugConfiguration * ?token: CancellationToken -> ProviderResult<DebugConfiguration>

    /// <summary>
    /// Represents a debug adapter executable and optional arguments and runtime options passed to it.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapterExecutable =
        /// <summary>
        /// The command or path of the debug adapter executable.
        /// A command must be either an absolute path of an executable or the name of an command to be looked up via the PATH environment variable.
        /// The special value 'node' will be mapped to the editor's built-in Node.js runtime.
        /// </summary>
        abstract member command: string with get
        /// <summary>
        /// The arguments passed to the debug adapter executable. Defaults to an empty array.
        /// </summary>
        abstract member args: ResizeArray<string> with get
        /// <summary>
        /// Optional options to be used when the debug adapter is started.
        /// Defaults to undefined.
        /// </summary>
        abstract member options: DebugAdapterExecutableOptions option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapterExecutableOptions =
        /// <summary>
        /// The additional environment of the executed program or shell. If omitted
        /// the parent process' environment is used. If provided it is merged with
        /// the parent process' environment.
        /// </summary>
        abstract member env: DebugAdapterExecutableOptions.env option with get, set
        /// <summary>
        /// The current working directory for the executed debug adapter.
        /// </summary>
        abstract member cwd: string option with get, set

    /// <summary>
    /// Represents a debug adapter running as a socket based server.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapterServer =
        /// <summary>
        /// The port.
        /// </summary>
        abstract member port: float with get
        /// <summary>
        /// The host.
        /// </summary>
        abstract member host: string option with get

    /// <summary>
    /// Represents a debug adapter running as a Named Pipe (on Windows)/UNIX Domain Socket (on non-Windows) based server.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapterNamedPipeServer =
        /// <summary>
        /// The path to the NamedPipe/UNIX Domain Socket.
        /// </summary>
        abstract member path: string with get

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapter =
        inherit Disposable
        /// <summary>
        /// An event which fires after the debug adapter has sent a Debug Adapter Protocol message to the editor.
        /// Messages can be requests, responses, or events.
        /// </summary>
        abstract member onDidSendMessage: Event<DebugProtocolMessage> with get
        /// <summary>
        /// Handle a Debug Adapter Protocol message.
        /// Messages can be requests, responses, or events.
        /// Results or errors are returned via onSendMessage events.
        /// </summary>
        /// <param name="message">
        /// A Debug Adapter Protocol message
        /// </param>
        abstract member handleMessage: message: DebugProtocolMessage -> unit

    /// <summary>
    /// A debug adapter descriptor for an inline implementation.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapterInlineImplementation =
        interface end

    /// <summary>
    /// Represents the different types of debug adapters
    /// </summary>
    type DebugAdapterDescriptor =
        U4<DebugAdapterExecutable, DebugAdapterServer, DebugAdapterNamedPipeServer, DebugAdapterInlineImplementation>

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapterDescriptorFactory =
        /// <summary>
        /// 'createDebugAdapterDescriptor' is called at the start of a debug session to provide details about the debug adapter to use.
        /// These details must be returned as objects of type <see href="DebugAdapterDescriptor">DebugAdapterDescriptor</see>.
        /// Currently two types of debug adapters are supported:
        /// - a debug adapter executable is specified as a command path and arguments (see <see href="DebugAdapterExecutable">DebugAdapterExecutable</see>),
        /// - a debug adapter server reachable via a communication port (see <see href="DebugAdapterServer">DebugAdapterServer</see>).
        /// If the method is not implemented the default behavior is this:
        ///   createDebugAdapter(session: DebugSession, executable: DebugAdapterExecutable) {
        ///      if (typeof session.configuration.debugServer === 'number') {
        ///         return new DebugAdapterServer(session.configuration.debugServer);
        ///      }
        ///      return executable;
        ///   }
        /// </summary>
        /// <param name="session">
        /// The <see href="DebugSession">debug session</see>" for which the debug adapter will be used.
        /// </param>
        /// <param name="executable">
        /// The debug adapter's executable information as specified in the package.json (or undefined if no such information exists).
        /// </param>
        /// <returns>
        /// a <see href="DebugAdapterDescriptor">debug adapter descriptor</see>" or undefined.
        /// </returns>
        abstract member createDebugAdapterDescriptor: session: DebugSession * executable: DebugAdapterExecutable option -> ProviderResult<DebugAdapterDescriptor>

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapterTracker =
        /// <summary>
        /// A session with the debug adapter is about to be started.
        /// </summary>
        abstract member onWillStartSession: unit -> unit
        /// <summary>
        /// The debug adapter is about to receive a Debug Adapter Protocol message from the editor.
        /// </summary>
        abstract member onWillReceiveMessage: message: obj -> unit
        /// <summary>
        /// The debug adapter has sent a Debug Adapter Protocol message to the editor.
        /// </summary>
        abstract member onDidSendMessage: message: obj -> unit
        /// <summary>
        /// The debug adapter session is about to be stopped.
        /// </summary>
        abstract member onWillStopSession: unit -> unit
        /// <summary>
        /// An error with the debug adapter has occurred.
        /// </summary>
        abstract member onError: error: Exception -> unit
        /// <summary>
        /// The debug adapter has exited with the given exit code or signal.
        /// </summary>
        abstract member onExit: code: float option * signal: string option -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugAdapterTrackerFactory =
        /// <summary>
        /// The method 'createDebugAdapterTracker' is called at the start of a debug session in order
        /// to return a "tracker" object that provides read-access to the communication between the editor and a debug adapter.
        /// </summary>
        /// <param name="session">
        /// The <see href="DebugSession">debug session</see>" for which the debug adapter tracker will be used.
        /// </param>
        /// <returns>
        /// A <see href="DebugAdapterTracker">debug adapter tracker</see>" or undefined.
        /// </returns>
        abstract member createDebugAdapterTracker: session: DebugSession -> ProviderResult<DebugAdapterTracker>

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugConsole =
        /// <summary>
        /// Append the given value to the debug console.
        /// </summary>
        /// <param name="value">
        /// A string, falsy values will not be printed.
        /// </param>
        abstract member append: value: string -> unit
        /// <summary>
        /// Append the given value and a line feed character
        /// to the debug console.
        /// </summary>
        /// <param name="value">
        /// A string, falsy values will be printed.
        /// </param>
        abstract member appendLine: value: string -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type BreakpointsChangeEvent =
        /// <summary>
        /// Added breakpoints.
        /// </summary>
        abstract member added: ReadonlyArray<Breakpoint> with get
        /// <summary>
        /// Removed breakpoints.
        /// </summary>
        abstract member removed: ReadonlyArray<Breakpoint> with get
        /// <summary>
        /// Changed breakpoints.
        /// </summary>
        abstract member changed: ReadonlyArray<Breakpoint> with get

    /// <summary>
    /// The base class of all breakpoint types.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type Breakpoint =
        /// <summary>
        /// The unique ID of the breakpoint.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// Is breakpoint enabled.
        /// </summary>
        abstract member enabled: bool with get
        /// <summary>
        /// An optional expression for conditional breakpoints.
        /// </summary>
        abstract member condition: string option with get
        /// <summary>
        /// An optional expression that controls how many hits of the breakpoint are ignored.
        /// </summary>
        abstract member hitCondition: string option with get
        /// <summary>
        /// An optional message that gets logged when this breakpoint is hit. Embedded expressions within {} are interpolated by the debug adapter.
        /// </summary>
        abstract member logMessage: string option with get

    /// <summary>
    /// A breakpoint specified by a source location.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type SourceBreakpoint =
        inherit Breakpoint
        /// <summary>
        /// The source and line position of this breakpoint.
        /// </summary>
        abstract member location: Location with get

    /// <summary>
    /// A breakpoint specified by a function name.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type FunctionBreakpoint =
        inherit Breakpoint
        /// <summary>
        /// The name of the function to which this breakpoint is attached.
        /// </summary>
        abstract member functionName: string with get

    [<RequireQualifiedAccess>]
    type DebugConsoleMode =
        | Separate = 0
        | MergeWithParent = 1

    [<AllowNullLiteral>]
    [<Interface>]
    type DebugSessionOptions =
        /// <summary>
        /// When specified the newly created debug session is registered as a "child" session of this
        /// "parent" debug session.
        /// </summary>
        abstract member parentSession: DebugSession option with get, set
        /// <summary>
        /// Controls whether lifecycle requests like 'restart' are sent to the newly created session or its parent session.
        /// By default (if the property is false or missing), lifecycle requests are sent to the new session.
        /// This property is ignored if the session has no parent session.
        /// </summary>
        abstract member lifecycleManagedByParent: bool option with get, set
        /// <summary>
        /// Controls whether this session should have a separate debug console or share it
        /// with the parent session. Has no effect for sessions which do not have a parent session.
        /// Defaults to Separate.
        /// </summary>
        abstract member consoleMode: DebugConsoleMode option with get, set
        /// <summary>
        /// Controls whether this session should run without debugging, thus ignoring breakpoints.
        /// When this property is not specified, the value from the parent session (if there is one) is used.
        /// </summary>
        abstract member noDebug: bool option with get, set
        /// <summary>
        /// Controls if the debug session's parent session is shown in the CALL STACK view even if it has only a single child.
        /// By default, the debug session will never hide its parent.
        /// If compact is true, debug sessions with a single child are hidden in the CALL STACK view to make the tree more compact.
        /// </summary>
        abstract member compact: bool option with get, set
        /// <summary>
        /// When true, a save will not be triggered for open editors when starting a debug session, regardless of the value of the <c>debug.saveBeforeStart</c> setting.
        /// </summary>
        abstract member suppressSaveBeforeStart: bool option with get, set
        /// <summary>
        /// When true, the debug toolbar will not be shown for this session.
        /// </summary>
        abstract member suppressDebugToolbar: bool option with get, set
        /// <summary>
        /// When true, the window statusbar color will not be changed for this session.
        /// </summary>
        abstract member suppressDebugStatusbar: bool option with get, set
        /// <summary>
        /// When true, the debug viewlet will not be automatically revealed for this session.
        /// </summary>
        abstract member suppressDebugView: bool option with get, set
        /// <summary>
        /// Signals to the editor that the debug session was started from a test run
        /// request. This is used to link the lifecycle of the debug session and
        /// test run in UI actions.
        /// </summary>
        abstract member testRun: TestRun option with get, set

    [<RequireQualifiedAccess>]
    type DebugConfigurationProviderTriggerKind =
        | Initial = 1
        | Dynamic = 2

    /// <summary>
    /// Represents a thread in a debug session.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DebugThread =
        /// <summary>
        /// Debug session for thread.
        /// </summary>
        abstract member session: DebugSession with get
        /// <summary>
        /// ID of the associated thread in the debug protocol.
        /// </summary>
        abstract member threadId: float with get

    /// <summary>
    /// Represents a stack frame in a debug session.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DebugStackFrame =
        /// <summary>
        /// Debug session for thread.
        /// </summary>
        abstract member session: DebugSession with get
        /// <summary>
        /// ID of the associated thread in the debug protocol.
        /// </summary>
        abstract member threadId: float with get
        /// <summary>
        /// ID of the stack frame in the debug protocol.
        /// </summary>
        abstract member frameId: float with get

    module debug =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// The currently active <see href="DebugSessiondebug">session</see>" or <c>undefined</c>. The active debug session is the one
            /// represented by the debug action floating window or the one currently shown in the drop down menu of the debug action floating window.
            /// If no debug session is active, the value is <c>undefined</c>.
            /// </summary>
            [<Emit("$0.activeDebugSession")>]
            abstract member activeDebugSession: DebugSession option
            /// <summary>
            /// The currently active <see href="DebugConsoledebug">console</see>".
            /// If no debug session is active, output sent to the debug console is not shown.
            /// </summary>
            [<Emit("$0.activeDebugConsole")>]
            abstract member activeDebugConsole: DebugConsole
            /// <summary>
            /// List of breakpoints.
            /// </summary>
            [<Emit("$0.breakpoints")>]
            abstract member breakpoints: ReadonlyArray<Breakpoint>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the <see href="debug.activeDebugSessionactive">debug session</see>"
            /// has changed. *Note* that the event also fires when the active debug session changes
            /// to <c>undefined</c>.
            /// </summary>
            [<Emit("$0.onDidChangeActiveDebugSession")>]
            abstract member onDidChangeActiveDebugSession: Event<DebugSession option>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when a new <see href="DebugSessiondebug">session</see>" has been started.
            /// </summary>
            [<Emit("$0.onDidStartDebugSession")>]
            abstract member onDidStartDebugSession: Event<DebugSession>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when a custom DAP event is received from the <see href="DebugSessiondebug">session</see>".
            /// </summary>
            [<Emit("$0.onDidReceiveDebugSessionCustomEvent")>]
            abstract member onDidReceiveDebugSessionCustomEvent: Event<DebugSessionCustomEvent>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when a <see href="DebugSessiondebug">session</see>" has terminated.
            /// </summary>
            [<Emit("$0.onDidTerminateDebugSession")>]
            abstract member onDidTerminateDebugSession: Event<DebugSession>
            /// <summary>
            /// An <see href="Event">Event</see> that is emitted when the set of breakpoints is added, removed, or changed.
            /// </summary>
            [<Emit("$0.onDidChangeBreakpoints")>]
            abstract member onDidChangeBreakpoints: Event<BreakpointsChangeEvent>
            /// <summary>
            /// The currently focused thread or stack frame, or <c>undefined</c> if no
            /// thread or stack is focused. A thread can be focused any time there is
            /// an active debug session, while a stack frame can only be focused when
            /// a session is paused and the call stack has been retrieved.
            /// </summary>
            [<Emit("$0.activeStackItem")>]
            abstract member activeStackItem: U2<DebugThread, DebugStackFrame> option
            /// <summary>
            /// An event which fires when the <see href="debug.activeStackItem">debug.activeStackItem</see> has changed.
            /// </summary>
            [<Emit("$0.onDidChangeActiveStackItem")>]
            abstract member onDidChangeActiveStackItem: Event<U2<DebugThread, DebugStackFrame> option>
            /// <summary>
            /// Register a <see href="DebugConfigurationProviderdebug">configuration provider</see>" for a specific debug type.
            /// The optional <see href="DebugConfigurationProviderTriggerKindtriggerKind">DebugConfigurationProviderTriggerKindtriggerKind</see> can be used to specify when the <c>provideDebugConfigurations</c> method of the provider is triggered.
            /// Currently two trigger kinds are possible: with the value <c>Initial</c> (or if no trigger kind argument is given) the <c>provideDebugConfigurations</c> method is used to provide the initial debug configurations to be copied into a newly created launch.json.
            /// With the trigger kind <c>Dynamic</c> the <c>provideDebugConfigurations</c> method is used to dynamically determine debug configurations to be presented to the user (in addition to the static configurations from the launch.json).
            /// Please note that the <c>triggerKind</c> argument only applies to the <c>provideDebugConfigurations</c> method: so the <c>resolveDebugConfiguration</c> methods are not affected at all.
            /// Registering a single provider with resolve methods for different trigger kinds, results in the same resolve methods called multiple times.
            /// More than one provider can be registered for the same type.
            /// </summary>
            /// <param name="debugType">
            /// The debug type for which the provider is registered.
            /// </param>
            /// <param name="provider">
            /// The <see href="DebugConfigurationProvider">debug configuration provider</see>" to register.
            /// </param>
            /// <param name="triggerKind">
            /// The <see href="DebugConfigurationProviderTriggerKind">trigger</see>" for which the 'provideDebugConfiguration' method of the provider is registered. If <c>triggerKind</c> is missing, the value <c>DebugConfigurationProviderTriggerKind.Initial</c> is assumed.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerDebugConfigurationProvider($1...)")>]
            abstract member registerDebugConfigurationProvider: debugType: string * provider: DebugConfigurationProvider * ?triggerKind: DebugConfigurationProviderTriggerKind -> Disposable
            /// <summary>
            /// Register a <see href="DebugAdapterDescriptorFactorydebug">adapter descriptor factory</see>" for a specific debug type.
            /// An extension is only allowed to register a DebugAdapterDescriptorFactory for the debug type(s) defined by the extension. Otherwise an error is thrown.
            /// Registering more than one DebugAdapterDescriptorFactory for a debug type results in an error.
            /// </summary>
            /// <param name="debugType">
            /// The debug type for which the factory is registered.
            /// </param>
            /// <param name="factory">
            /// The <see href="DebugAdapterDescriptorFactory">debug adapter descriptor factory</see>" to register.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this factory when being disposed.
            /// </returns>
            [<Emit("$0.registerDebugAdapterDescriptorFactory($1...)")>]
            abstract member registerDebugAdapterDescriptorFactory: debugType: string * factory: DebugAdapterDescriptorFactory -> Disposable
            /// <summary>
            /// Register a debug adapter tracker factory for the given debug type.
            /// </summary>
            /// <param name="debugType">
            /// The debug type for which the factory is registered or '*' for matching all debug types.
            /// </param>
            /// <param name="factory">
            /// The <see href="DebugAdapterTrackerFactory">debug adapter tracker factory</see>" to register.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this factory when being disposed.
            /// </returns>
            [<Emit("$0.registerDebugAdapterTrackerFactory($1...)")>]
            abstract member registerDebugAdapterTrackerFactory: debugType: string * factory: DebugAdapterTrackerFactory -> Disposable
            /// <summary>
            /// Start debugging by using either a named launch or named compound configuration,
            /// or by directly passing a <see href="DebugConfiguration">DebugConfiguration</see>.
            /// The named configurations are looked up in '.vscode/launch.json' found in the given folder.
            /// Before debugging starts, all unsaved files are saved and the launch configurations are brought up-to-date.
            /// Folder specific variables used in the configuration (e.g. '${workspaceFolder}') are resolved against the given folder.
            /// </summary>
            /// <param name="folder">
            /// The <see href="WorkspaceFolder">workspace folder</see>" for looking up named configurations and resolving variables or <c>undefined</c> for a non-folder setup.
            /// </param>
            /// <param name="nameOrConfiguration">
            /// Either the name of a debug or compound configuration or a <see href="DebugConfiguration">DebugConfiguration</see> object.
            /// </param>
            /// <param name="parentSessionOrOptions">
            /// Debug session options. When passed a parent <see href="DebugSession">debug session</see>", assumes options with just this parent session.
            /// </param>
            /// <returns>
            /// A thenable that resolves when debugging could be successfully started.
            /// </returns>
            [<Emit("$0.startDebugging($1...)")>]
            abstract member startDebugging: folder: WorkspaceFolder option * nameOrConfiguration: U2<string, DebugConfiguration> * ?parentSessionOrOptions: U2<DebugSession, DebugSessionOptions> -> Thenable<bool>
            /// <summary>
            /// Stop the given debug session or stop all debug sessions if session is omitted.
            /// </summary>
            /// <param name="session">
            /// The <see href="DebugSession">debug session</see>" to stop; if omitted all sessions are stopped.
            /// </param>
            /// <returns>
            /// A thenable that resolves when the session(s) have been stopped.
            /// </returns>
            [<Emit("$0.stopDebugging($1...)")>]
            abstract member stopDebugging: ?session: DebugSession -> Thenable<unit>
            /// <summary>
            /// Add breakpoints.
            /// </summary>
            /// <param name="breakpoints">
            /// The breakpoints to add.
            /// </param>
            [<Emit("$0.addBreakpoints($1...)")>]
            abstract member addBreakpoints: breakpoints: ReadonlyArray<Breakpoint> -> unit
            /// <summary>
            /// Remove breakpoints.
            /// </summary>
            /// <param name="breakpoints">
            /// The breakpoints to remove.
            /// </param>
            [<Emit("$0.removeBreakpoints($1...)")>]
            abstract member removeBreakpoints: breakpoints: ReadonlyArray<Breakpoint> -> unit
            /// <summary>
            /// Converts a "Source" descriptor object received via the Debug Adapter Protocol into a Uri that can be used to load its contents.
            /// If the source descriptor is based on a path, a file Uri is returned.
            /// If the source descriptor uses a reference number, a specific debug Uri (scheme 'debug') is constructed that requires a corresponding ContentProvider and a running debug session
            ///
            /// If the "Source" descriptor has insufficient information for creating the Uri, an error is thrown.
            /// </summary>
            /// <param name="source">
            /// An object conforming to the [Source](https://microsoft.github.io/debug-adapter-protocol/specification#Types_Source) type defined in the Debug Adapter Protocol.
            /// </param>
            /// <param name="session">
            /// An optional debug session that will be used when the source descriptor uses a reference number to load the contents from an active debug session.
            /// </param>
            /// <returns>
            /// A uri that can be used to load the contents of the source.
            /// </returns>
            [<Emit("$0.asDebugSourceUri($1...)")>]
            abstract member asDebugSourceUri: source: DebugProtocolSource * ?session: DebugSession -> Uri

    module extensions =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Get an extension by its full identifier in the form of: <c>publisher.name</c>.
            /// </summary>
            /// <param name="extensionId">
            /// An extension identifier.
            /// </param>
            /// <returns>
            /// An extension or <c>undefined</c>.
            /// </returns>
            [<Emit("$0.getExtension($1...)")>]
            abstract member getExtension<'T>: extensionId: string -> Extension<'T> option
            /// <summary>
            /// All extensions currently known to the system.
            /// </summary>
            [<Emit("$0.all")>]
            abstract member all: ReadonlyArray<Extension<obj>>
            /// <summary>
            /// An event which fires when <c>extensions.all</c> changes. This can happen when extensions are
            /// installed, uninstalled, enabled or disabled.
            /// </summary>
            [<Emit("$0.onDidChange")>]
            abstract member onDidChange: Event<unit>

    [<RequireQualifiedAccess>]
    type CommentThreadCollapsibleState =
        | Collapsed = 0
        | Expanded = 1

    [<RequireQualifiedAccess>]
    type CommentMode =
        | Editing = 0
        | Preview = 1

    [<RequireQualifiedAccess>]
    type CommentThreadState =
        | Unresolved = 0
        | Resolved = 1

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentThread =
        /// <summary>
        /// The uri of the document the thread has been created on.
        /// </summary>
        abstract member uri: Uri with get
        /// <summary>
        /// The range the comment thread is located within the document. The thread icon will be shown
        /// at the last line of the range. When set to undefined, the comment will be associated with the
        /// file, and not a specific range.
        /// </summary>
        abstract member range: Range option with get, set
        /// <summary>
        /// The ordered comments of the thread.
        /// </summary>
        abstract member comments: ReadonlyArray<Comment> with get, set
        /// <summary>
        /// Whether the thread should be collapsed or expanded when opening the document.
        /// Defaults to Collapsed.
        /// </summary>
        abstract member collapsibleState: CommentThreadCollapsibleState with get, set
        /// <summary>
        /// Whether the thread supports reply.
        /// Defaults to true.
        /// </summary>
        abstract member canReply: U2<bool, CommentAuthorInformation> with get, set
        /// <summary>
        /// Context value of the comment thread. This can be used to contribute thread specific actions.
        /// For example, a comment thread is given a context value as <c>editable</c>. When contributing actions to <c>comments/commentThread/title</c>
        /// using <c>menus</c> extension point, you can specify context value for key <c>commentThread</c> in <c>when</c> expression like <c>commentThread == editable</c>.
        /// <code lang="json">
        /// "contributes": {
        ///   "menus": {
        ///     "comments/commentThread/title": [
        ///       {
        ///         "command": "extension.deleteCommentThread",
        ///         "when": "commentThread == editable"
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// This will show action <c>extension.deleteCommentThread</c> only for comment threads with <c>contextValue</c> is <c>editable</c>.
        /// </summary>
        abstract member contextValue: string option with get, set
        /// <summary>
        /// The optional human-readable label describing the <see href="CommentThreadComment">Thread</see>"
        /// </summary>
        abstract member label: string option with get, set
        /// <summary>
        /// The optional state of a comment thread, which may affect how the comment is displayed.
        /// </summary>
        abstract member state: CommentThreadState option with get, set
        /// <summary>
        /// Dispose this comment thread.
        ///
        /// Once disposed, this comment thread will be removed from visible editors and Comment Panel when appropriate.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentAuthorInformation =
        /// <summary>
        /// The display name of the author of the comment
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The optional icon path for the author
        /// </summary>
        abstract member iconPath: Uri option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentReaction =
        /// <summary>
        /// The human-readable label for the reaction
        /// </summary>
        abstract member label: string with get
        /// <summary>
        /// Icon for the reaction shown in UI.
        /// </summary>
        abstract member iconPath: U2<string, Uri> with get
        /// <summary>
        /// The number of users who have reacted to this reaction
        /// </summary>
        abstract member count: float with get
        /// <summary>
        /// Whether the <see href="CommentAuthorInformationauthor">CommentAuthorInformationauthor</see> of the comment has reacted to this reaction
        /// </summary>
        abstract member authorHasReacted: bool with get

    [<AllowNullLiteral>]
    [<Interface>]
    type Comment =
        /// <summary>
        /// The human-readable comment body
        /// </summary>
        abstract member body: U2<string, MarkdownString> with get, set
        /// <summary>
        /// <see href="CommentModeComment">mode</see>" of the comment
        /// </summary>
        abstract member mode: CommentMode with get, set
        /// <summary>
        /// The <see href="CommentAuthorInformationauthor">information</see>" of the comment
        /// </summary>
        abstract member author: CommentAuthorInformation with get, set
        /// <summary>
        /// Context value of the comment. This can be used to contribute comment specific actions.
        /// For example, a comment is given a context value as <c>editable</c>. When contributing actions to <c>comments/comment/title</c>
        /// using <c>menus</c> extension point, you can specify context value for key <c>comment</c> in <c>when</c> expression like <c>comment == editable</c>.
        /// <code lang="json">
        /// "contributes": {
        /// 	"menus": {
        /// 		"comments/comment/title": [
        /// 			{
        /// 				"command": "extension.deleteComment",
        /// 				"when": "comment == editable"
        /// 			}
        /// 		]
        /// 	}
        /// }
        /// </code>
        /// This will show action <c>extension.deleteComment</c> only for comments with <c>contextValue</c> is <c>editable</c>.
        /// </summary>
        abstract member contextValue: string option with get, set
        /// <summary>
        /// Optional reactions of the <see href="Comment">Comment</see>
        /// </summary>
        abstract member reactions: ResizeArray<CommentReaction> option with get, set
        /// <summary>
        /// Optional label describing the <see href="Comment">Comment</see>
        /// Label will be rendered next to authorName if exists.
        /// </summary>
        abstract member label: string option with get, set
        /// <summary>
        /// Optional timestamp that will be displayed in comments.
        /// The date will be formatted according to the user's locale and settings.
        /// </summary>
        abstract member timestamp: JS.Date option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentReply =
        /// <summary>
        /// The active <see href="CommentThreadcomment">thread</see>"
        /// </summary>
        abstract member thread: CommentThread with get, set
        /// <summary>
        /// The value in the comment editor
        /// </summary>
        abstract member text: string with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentingRanges =
        /// <summary>
        /// Enables comments to be added to a file without a specific range.
        /// </summary>
        abstract member enableFileComments: bool with get, set
        /// <summary>
        /// The ranges which allow new comment threads creation.
        /// </summary>
        abstract member ranges: ResizeArray<Range> option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentingRangeProvider =
        /// <summary>
        /// Provide a list of ranges which allow new comment threads creation or null for a given document
        /// </summary>
        abstract member provideCommentingRanges: document: TextDocument * token: CancellationToken -> ProviderResult<U2<ResizeArray<Range>, CommentingRanges>>

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentOptions =
        /// <summary>
        /// An optional string to show on the comment input box when it's collapsed.
        /// </summary>
        abstract member prompt: string option with get, set
        /// <summary>
        /// An optional string to show as placeholder in the comment input box when it's focused.
        /// </summary>
        abstract member placeHolder: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type CommentController =
        /// <summary>
        /// The id of this comment controller.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The human-readable label of this comment controller.
        /// </summary>
        abstract member label: string with get
        /// <summary>
        /// Comment controller options
        /// </summary>
        abstract member options: CommentOptions option with get, set
        /// <summary>
        /// Optional commenting range provider. Provide a list <see href="Rangeranges">Rangeranges</see> which support commenting to any given resource uri.
        ///
        /// If not provided, users cannot leave any comments.
        /// </summary>
        abstract member commentingRangeProvider: CommentingRangeProvider option with get, set
        /// <summary>
        /// Create a <see href="CommentThreadcomment">thread</see>". The comment thread will be displayed in visible text editors (if the resource matches)
        /// and Comments Panel once created.
        /// </summary>
        /// <param name="uri">
        /// The uri of the document the thread has been created on.
        /// </param>
        /// <param name="range">
        /// The range the comment thread is located within the document.
        /// </param>
        /// <param name="comments">
        /// The ordered comments of the thread.
        /// </param>
        abstract member createCommentThread: uri: Uri * range: Range * comments: ReadonlyArray<Comment> -> CommentThread
        /// <summary>
        /// Optional reaction handler for creating and deleting reactions on a <see href="Comment">Comment</see>.
        /// </summary>
        abstract member reactionHandler: CommentController.reactionHandler option with get, set
        /// <summary>
        /// Dispose this comment controller.
        ///
        /// Once disposed, all <see href="CommentThreadcomment">threads</see>" created by this comment controller will also be removed from the editor
        /// and Comments Panel.
        /// </summary>
        abstract member dispose: unit -> unit

    module comments =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Creates a new <see href="CommentControllercomment">controller</see>" instance.
            /// </summary>
            /// <param name="id">
            /// An <c>id</c> for the comment controller.
            /// </param>
            /// <param name="label">
            /// A human-readable string for the comment controller.
            /// </param>
            /// <returns>
            /// An instance of <see href="CommentController">comment controller</see>".
            /// </returns>
            [<Emit("$0.createCommentController($1...)")>]
            abstract member createCommentController: id: string * label: string -> CommentController

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationSession =
        /// <summary>
        /// The identifier of the authentication session.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The access token. This token should be used to authenticate requests to a service. Popularized by OAuth.
        /// </summary>
        abstract member accessToken: string with get
        /// <summary>
        /// The ID token. This token contains identity information about the user. Popularized by OpenID Connect.
        /// </summary>
        abstract member idToken: string option with get
        /// <summary>
        /// The account associated with the session.
        /// </summary>
        abstract member account: AuthenticationSessionAccountInformation with get
        /// <summary>
        /// The permissions granted by the session's access token. Available scopes
        /// are defined by the <see href="AuthenticationProvider">AuthenticationProvider</see>.
        /// </summary>
        abstract member scopes: ReadonlyArray<string> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationSessionAccountInformation =
        /// <summary>
        /// The unique identifier of the account.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The human-readable name of the account.
        /// </summary>
        abstract member label: string with get

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationGetSessionPresentationOptions =
        /// <summary>
        /// An optional message that will be displayed to the user when we ask to re-authenticate. Providing additional context
        /// as to why you are asking a user to re-authenticate can help increase the odds that they will accept.
        /// </summary>
        abstract member detail: string option with get, set

    /// <summary>
    /// Optional options to be used when calling <see href="authentication.getSession">authentication.getSession</see> with the flag <c>forceNewSession</c>.
    /// </summary>
    [<Obsolete("Use {@link AuthenticationGetSessionPresentationOptions } instead.")>]
    type AuthenticationForceNewSessionOptions =
        AuthenticationGetSessionPresentationOptions

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationGetSessionOptions =
        /// <summary>
        /// Whether the existing session preference should be cleared.
        ///
        /// For authentication providers that support being signed into multiple accounts at once, the user will be
        /// prompted to select an account to use when <see href="authentication.getSessiongetSession">authentication.getSessiongetSession</see> is called. This preference
        /// is remembered until <see href="authentication.getSessiongetSession">authentication.getSessiongetSession</see> is called with this flag.
        ///
        /// Note:
        /// The preference is extension specific. So if one extension calls <see href="authentication.getSessiongetSession">authentication.getSessiongetSession</see>, it will not
        /// affect the session preference for another extension calling <see href="authentication.getSessiongetSession">authentication.getSessiongetSession</see>. Additionally,
        /// the preference is set for the current workspace and also globally. This means that new workspaces will use the "global"
        /// value at first and then when this flag is provided, a new value can be set for that workspace. This also means
        /// that pre-existing workspaces will not lose their preference if a new workspace sets this flag.
        ///
        /// Defaults to false.
        /// </summary>
        abstract member clearSessionPreference: bool option with get, set
        /// <summary>
        /// Whether login should be performed if there is no matching session.
        ///
        /// If true, a modal dialog will be shown asking the user to sign in. If false, a numbered badge will be shown
        /// on the accounts activity bar icon. An entry for the extension will be added under the menu to sign in. This
        /// allows quietly prompting the user to sign in.
        ///
        /// If you provide options, you will also see the dialog but with the additional context provided.
        ///
        /// If there is a matching session but the extension has not been granted access to it, setting this to true
        /// will also result in an immediate modal dialog, and false will add a numbered badge to the accounts icon.
        ///
        /// Defaults to false.
        ///
        /// Note: you cannot use this option with <see href="AuthenticationGetSessionOptions.silentsilent">AuthenticationGetSessionOptions.silentsilent</see>.
        /// </summary>
        abstract member createIfNone: U2<bool, AuthenticationGetSessionPresentationOptions> option with get, set
        /// <summary>
        /// Whether we should attempt to reauthenticate even if there is already a session available.
        ///
        /// If true, a modal dialog will be shown asking the user to sign in again. This is mostly used for scenarios
        /// where the token needs to be re minted because it has lost some authorization.
        ///
        /// If you provide options, you will also see the dialog but with the additional context provided.
        ///
        /// If there are no existing sessions and forceNewSession is true, it will behave identically to
        /// <see href="AuthenticationGetSessionOptions.createIfNonecreateIfNone">AuthenticationGetSessionOptions.createIfNonecreateIfNone</see>.
        ///
        /// This defaults to false.
        /// </summary>
        abstract member forceNewSession: U3<bool, AuthenticationGetSessionPresentationOptions, AuthenticationForceNewSessionOptions> option with get, set
        /// <summary>
        /// Whether we should show the indication to sign in in the Accounts menu.
        ///
        /// If false, the user will be shown a badge on the Accounts menu with an option to sign in for the extension.
        /// If true, no indication will be shown.
        ///
        /// Defaults to false.
        ///
        /// Note: you cannot use this option with any other options that prompt the user like <see href="AuthenticationGetSessionOptions.createIfNonecreateIfNone">AuthenticationGetSessionOptions.createIfNonecreateIfNone</see>.
        /// </summary>
        abstract member silent: bool option with get, set
        /// <summary>
        /// The account that you would like to get a session for. This is passed down to the Authentication Provider to be used for creating the correct session.
        /// </summary>
        abstract member account: AuthenticationSessionAccountInformation option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationWwwAuthenticateRequest =
        /// <summary>
        /// The raw WWW-Authenticate header value that triggered this challenge.
        /// This will be parsed by the authentication provider to extract the necessary
        /// challenge information.
        /// </summary>
        abstract member wwwAuthenticate: string with get
        /// <summary>
        /// The fallback scopes to use if no scopes are found in the WWW-Authenticate header.
        /// </summary>
        abstract member fallbackScopes: ReadonlyArray<string> option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationProviderInformation =
        /// <summary>
        /// The unique identifier of the authentication provider.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The human-readable name of the authentication provider.
        /// </summary>
        abstract member label: string with get

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationSessionsChangeEvent =
        /// <summary>
        /// The <see href="AuthenticationProvider">AuthenticationProvider</see> that has had its sessions change.
        /// </summary>
        abstract member provider: AuthenticationProviderInformation with get

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationProviderOptions =
        /// <summary>
        /// Whether it is possible to be signed into multiple accounts at once with this provider.
        /// If not specified, will default to false.
        /// </summary>
        abstract member supportsMultipleAccounts: bool option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationProviderAuthenticationSessionsChangeEvent =
        /// <summary>
        /// The <see href="AuthenticationSessionAuthenticationSessions">AuthenticationSessionAuthenticationSessions</see> of the <see href="AuthenticationProvider">AuthenticationProvider</see> that have been added.
        /// </summary>
        abstract member added: ReadonlyArray<AuthenticationSession> option with get
        /// <summary>
        /// The <see href="AuthenticationSessionAuthenticationSessions">AuthenticationSessionAuthenticationSessions</see> of the <see href="AuthenticationProvider">AuthenticationProvider</see> that have been removed.
        /// </summary>
        abstract member removed: ReadonlyArray<AuthenticationSession> option with get
        /// <summary>
        /// The <see href="AuthenticationSessionAuthenticationSessions">AuthenticationSessionAuthenticationSessions</see> of the <see href="AuthenticationProvider">AuthenticationProvider</see> that have been changed.
        /// A session changes when its data excluding the id are updated. An example of this is a session refresh that results in a new
        /// access token being set for the session.
        /// </summary>
        abstract member changed: ReadonlyArray<AuthenticationSession> option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationProviderSessionOptions =
        /// <summary>
        /// The account that is being asked about. If this is passed in, the provider should
        /// attempt to return the sessions that are only related to this account.
        /// </summary>
        abstract member account: AuthenticationSessionAccountInformation option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type AuthenticationProvider =
        /// <summary>
        /// An <see href="Event">Event</see> which fires when the array of sessions has changed, or data
        /// within a session has changed.
        /// </summary>
        abstract member onDidChangeSessions: Event<AuthenticationProviderAuthenticationSessionsChangeEvent> with get
        /// <summary>
        /// Get a list of sessions.
        /// </summary>
        /// <param name="scopes">
        /// An optional list of scopes. If provided, the sessions returned should match
        /// these permissions, otherwise all sessions should be returned.
        /// </param>
        /// <param name="options">
        /// Additional options for getting sessions.
        /// </param>
        /// <returns>
        /// A promise that resolves to an array of authentication sessions.
        /// </returns>
        abstract member getSessions: scopes: ReadonlyArray<string> option * options: AuthenticationProviderSessionOptions -> Thenable<ResizeArray<AuthenticationSession>>
        /// <summary>
        /// Prompts a user to login.
        ///
        /// If login is successful, the onDidChangeSessions event should be fired.
        ///
        /// If login fails, a rejected promise should be returned.
        ///
        /// If the provider has specified that it does not support multiple accounts,
        /// then this should never be called if there is already an existing session matching these
        /// scopes.
        /// </summary>
        /// <param name="scopes">
        /// A list of scopes, permissions, that the new session should be created with.
        /// </param>
        /// <param name="options">
        /// Additional options for creating a session.
        /// </param>
        /// <returns>
        /// A promise that resolves to an authentication session.
        /// </returns>
        abstract member createSession: scopes: ReadonlyArray<string> * options: AuthenticationProviderSessionOptions -> Thenable<AuthenticationSession>
        /// <summary>
        /// Removes the session corresponding to session id.
        ///
        /// If the removal is successful, the onDidChangeSessions event should be fired.
        ///
        /// If a session cannot be removed, the provider should reject with an error message.
        /// </summary>
        /// <param name="sessionId">
        /// The id of the session to remove.
        /// </param>
        abstract member removeSession: sessionId: string -> Thenable<unit>

    module authentication =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Get an authentication session matching the desired scopes or satisfying the WWW-Authenticate request. Rejects if
            /// a provider with providerId is not registered, or if the user does not consent to sharing authentication information
            /// with the extension. If there are multiple sessions with the same scopes, the user will be shown a quickpick to
            /// select which account they would like to use.
            ///
            /// Built-in auth providers include:
            /// * 'github' - For GitHub.com
            /// * 'microsoft' For both personal & organizational Microsoft accounts
            /// * (less common) 'github-enterprise' - for alternative GitHub hostings, GHE.com, GitHub Enterprise Server
            /// * (less common) 'microsoft-sovereign-cloud' - for alternative Microsoft clouds
            /// </summary>
            /// <param name="providerId">
            /// The id of the provider to use
            /// </param>
            /// <param name="scopeListOrRequest">
            /// A scope list of permissions requested or a WWW-Authenticate request. These are dependent on the authentication provider.
            /// </param>
            /// <param name="options">
            /// The <see href="AuthenticationGetSessionOptions">AuthenticationGetSessionOptions</see> to use
            /// </param>
            /// <returns>
            /// A thenable that resolves to an authentication session
            /// </returns>
            [<Emit("$0.getSession($1...)")>]
            abstract member getSession: providerId: string * scopeListOrRequest: U2<ReadonlyArray<string>, AuthenticationWwwAuthenticateRequest> * options: obj -> Thenable<AuthenticationSession>
            /// <summary>
            /// Get an authentication session matching the desired scopes or request. Rejects if a provider with providerId is not
            /// registered, or if the user does not consent to sharing authentication information with the extension. If there
            /// are multiple sessions with the same scopes, the user will be shown a quickpick to select which account they would like to use.
            ///
            /// Built-in auth providers include:
            /// * 'github' - For GitHub.com
            /// * 'microsoft' For both personal & organizational Microsoft accounts
            /// * (less common) 'github-enterprise' - for alternative GitHub hostings, GHE.com, GitHub Enterprise Server
            /// * (less common) 'microsoft-sovereign-cloud' - for alternative Microsoft clouds
            /// </summary>
            /// <param name="providerId">
            /// The id of the provider to use
            /// </param>
            /// <param name="scopeListOrRequest">
            /// A scope list of permissions requested or a WWW-Authenticate request. These are dependent on the authentication provider.
            /// </param>
            /// <param name="options">
            /// The <see href="AuthenticationGetSessionOptions">AuthenticationGetSessionOptions</see> to use
            /// </param>
            /// <returns>
            /// A thenable that resolves to an authentication session or undefined if a silent flow was used and no session was found
            /// </returns>
            [<Emit("$0.getSession($1...)")>]
            abstract member getSession: providerId: string * scopeListOrRequest: U2<ReadonlyArray<string>, AuthenticationWwwAuthenticateRequest> * ?options: AuthenticationGetSessionOptions -> Thenable<AuthenticationSession option>
            /// <summary>
            /// Get all accounts that the user is logged in to for the specified provider.
            /// Use this paired with <see href="getSession">getSession</see> in order to get an authentication session for a specific account.
            ///
            /// Currently, there are only two authentication providers that are contributed from built in extensions
            /// to the editor that implement GitHub and Microsoft authentication: their providerId's are 'github' and 'microsoft'.
            ///
            /// Note: Getting accounts does not imply that your extension has access to that account or its authentication sessions. You can verify access to the account by calling <see href="getSession">getSession</see>.
            /// </summary>
            /// <param name="providerId">
            /// The id of the provider to use
            /// </param>
            /// <returns>
            /// A thenable that resolves to a readonly array of authentication accounts.
            /// </returns>
            [<Emit("$0.getAccounts($1...)")>]
            abstract member getAccounts: providerId: string -> Thenable<ReadonlyArray<AuthenticationSessionAccountInformation>>
            /// <summary>
            /// An <see href="Event">Event</see> which fires when the authentication sessions of an authentication provider have
            /// been added, removed, or changed.
            /// </summary>
            [<Emit("$0.onDidChangeSessions")>]
            abstract member onDidChangeSessions: Event<AuthenticationSessionsChangeEvent>
            /// <summary>
            /// Register an authentication provider.
            ///
            /// There can only be one provider per id and an error is being thrown when an id
            /// has already been used by another provider. Ids are case-sensitive.
            /// </summary>
            /// <param name="id">
            /// The unique identifier of the provider.
            /// </param>
            /// <param name="label">
            /// The human-readable name of the provider.
            /// </param>
            /// <param name="provider">
            /// The authentication provider provider.
            /// </param>
            /// <param name="options">
            /// Additional options for the provider.
            /// </param>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters this provider when being disposed.
            /// </returns>
            [<Emit("$0.registerAuthenticationProvider($1...)")>]
            abstract member registerAuthenticationProvider: id: string * label: string * provider: AuthenticationProvider * ?options: AuthenticationProviderOptions -> Disposable

    module l10n =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Marks a string for localization. If a localized bundle is available for the language specified by
            /// <see href="env.language">env.language</see> and the bundle has a localized value for this message, then that localized
            /// value will be returned (with injected <see href="args">args</see> values for any templated values).
            /// </summary>
            /// <example>
            /// l10n.t('Hello {0}!', 'World');
            /// </example>
            /// <param name="message">
            /// The message to localize. Supports index templating where strings like <c>{0}</c> and <c>{1}</c> are
            /// replaced by the item at that index in the <see href="args">args</see> array.
            /// </param>
            /// <param name="args">
            /// The arguments to be used in the localized string. The index of the argument is used to
            /// match the template placeholder in the localized string.
            /// </param>
            /// <returns>
            /// localized string with injected arguments.
            /// </returns>
            [<Emit("$0.t($1...)")>]
            abstract member t: message: string * [<ParamArray>] args: ResizeArray<U3<string, float, bool>> [] -> string
            /// <summary>
            /// Marks a string for localization. If a localized bundle is available for the language specified by
            /// <see href="env.language">env.language</see> and the bundle has a localized value for this message, then that localized
            /// value will be returned (with injected <see href="args">args</see> values for any templated values).
            /// </summary>
            /// <example>
            /// l10n.t('Hello {name}', { name: 'Erich' });
            /// </example>
            /// <param name="message">
            /// The message to localize. Supports named templating where strings like <c>{foo}</c> and <c>{bar}</c> are
            /// replaced by the value in the Record for that key (foo, bar, etc).
            /// </param>
            /// <param name="args">
            /// The arguments to be used in the localized string. The name of the key in the record is used to
            /// match the template placeholder in the localized string.
            /// </param>
            /// <returns>
            /// localized string with injected arguments.
            /// </returns>
            [<Emit("$0.t($1...)")>]
            abstract member t: message: string * args: Exports.t.args -> string
            /// <summary>
            /// Marks a string for localization. If a localized bundle is available for the language specified by
            /// <see href="env.language">env.language</see> and the bundle has a localized value for this message, then that localized
            /// value will be returned (with injected args values for any templated values).
            /// </summary>
            /// <param name="options">
            /// The options to use when localizing the message.
            /// </param>
            /// <returns>
            /// localized string with injected arguments.
            /// </returns>
            [<Emit("$0.t($1...)")>]
            abstract member t: options: Exports.t.options -> string
            /// <summary>
            /// The bundle of localized strings that have been loaded for the extension.
            /// It's undefined if no bundle has been loaded. The bundle is typically not loaded if
            /// there was no bundle found or when we are running with the default language.
            /// </summary>
            [<Emit("$0.bundle")>]
            abstract member bundle: Exports.bundle option
            /// <summary>
            /// The URI of the localization bundle that has been loaded for the extension.
            /// It's undefined if no bundle has been loaded. The bundle is typically not loaded if
            /// there was no bundle found or when we are running with the default language.
            /// </summary>
            [<Emit("$0.uri")>]
            abstract member uri: Uri option

        module Exports =

            [<AllowNullLiteral>]
            [<Interface>]
            type bundle =
                [<EmitIndexer>]
                abstract member Item: key: string -> string with get, set

            module t =

                [<AllowNullLiteral>]
                [<Interface>]
                type args =
                    [<EmitIndexer>]
                    abstract member Item: key: string -> U3<string, float, bool> with get, set

                [<Global>]
                [<AllowNullLiteral>]
                type options
                    [<ParamObject; Emit("$0")>]
                    (
                        message: string,
                        comment: U2<string, ResizeArray<string>>,
                        ?args: U2<ResizeArray<U3<string, float, bool>>, Exports.t.options.args.U2.Case2>
                    ) =

                    member val message : string = nativeOnly with get, set
                    member val comment : U2<string, ResizeArray<string>> = nativeOnly with get, set
                    member val args : U2<ResizeArray<U3<string, float, bool>>, Exports.t.options.args.U2.Case2> option = nativeOnly with get, set

                module options =

                    module args =

                        module U2 =

                            [<AllowNullLiteral>]
                            [<Interface>]
                            type Case2 =
                                [<EmitIndexer>]
                                abstract member Item: key: string -> U3<string, float, bool> with get, set

    module tests =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Creates a new test controller.
            /// </summary>
            /// <param name="id">
            /// Identifier for the controller, must be globally unique.
            /// </param>
            /// <param name="label">
            /// A human-readable label for the controller.
            /// </param>
            /// <returns>
            /// An instance of the <see href="TestController">TestController</see>.
            /// </returns>
            [<Emit("$0.createTestController($1...)")>]
            abstract member createTestController: id: string * label: string -> TestController

    [<RequireQualifiedAccess>]
    type TestRunProfileKind =
        | Run = 1
        | Debug = 2
        | Coverage = 3

    /// <summary>
    /// Tags can be associated with <see href="TestItemTestItems">TestItemTestItems</see> and
    /// <see href="TestRunProfileTestRunProfiles">TestRunProfileTestRunProfiles</see>. A profile with a tag can only
    /// execute tests that include that tag in their <see href="TestItem.tags">TestItem.tags</see> array.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TestTag =
        /// <summary>
        /// ID of the test tag. <c>TestTag</c> instances with the same ID are considered
        /// to be identical.
        /// </summary>
        abstract member id: string with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TestRunProfile =
        /// <summary>
        /// Label shown to the user in the UI.
        ///
        /// Note that the label has some significance if the user requests that
        /// tests be re-run in a certain way. For example, if tests were run
        /// normally and the user requests to re-run them in debug mode, the editor
        /// will attempt use a configuration with the same label of the <c>Debug</c>
        /// kind. If there is no such configuration, the default will be used.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// Configures what kind of execution this profile controls. If there
        /// are no profiles for a kind, it will not be available in the UI.
        /// </summary>
        abstract member kind: TestRunProfileKind with get
        /// <summary>
        /// Controls whether this profile is the default action that will
        /// be taken when its kind is actioned. For example, if the user clicks
        /// the generic "run all" button, then the default profile for
        /// <see href="TestRunProfileKind.Run">TestRunProfileKind.Run</see> will be executed, although the
        /// user can configure this.
        ///
        /// Changes the user makes in their default profiles will be reflected
        /// in this property after a <see href="onDidChangeDefault">onDidChangeDefault</see> event.
        /// </summary>
        abstract member isDefault: bool with get, set
        /// <summary>
        /// Fired when a user has changed whether this is a default profile. The
        /// event contains the new value of <see href="isDefault">isDefault</see>
        /// </summary>
        abstract member onDidChangeDefault: Event<bool> with get
        /// <summary>
        /// Whether this profile supports continuous running of requests. If so,
        /// then <see href="TestRunRequest.continuous">TestRunRequest.continuous</see> may be set to <c>true</c>. Defaults
        /// to false.
        /// </summary>
        abstract member supportsContinuousRun: bool with get, set
        /// <summary>
        /// Associated tag for the profile. If this is set, only <see href="TestItem">TestItem</see>
        /// instances with the same tag will be eligible to execute in this profile.
        /// </summary>
        abstract member tag: TestTag option with get, set
        /// <summary>
        /// If this method is present, a configuration gear will be present in the
        /// UI, and this method will be invoked when it's clicked. When called,
        /// you can take other editor actions, such as showing a quick pick or
        /// opening a configuration file.
        /// </summary>
        abstract member configureHandler: (unit -> unit) option with get, set
        /// <summary>
        /// Handler called to start a test run. When invoked, the function should call
        /// <see href="TestController.createTestRun">TestController.createTestRun</see> at least once, and all test runs
        /// associated with the request should be created before the function returns
        /// or the returned promise is resolved.
        ///
        /// If <see href="supportsContinuousRun">supportsContinuousRun</see> is set, then <see href="TestRunRequest.continuous">TestRunRequest.continuous</see>
        /// may be <c>true</c>. In this case, the profile should observe changes to
        /// source code and create new test runs by calling <see href="TestController.createTestRun">TestController.createTestRun</see>,
        /// until the cancellation is requested on the <c>token</c>.
        /// </summary>
        /// <param name="request">
        /// Request information for the test run.
        /// </param>
        /// <param name="cancellationToken">
        /// Token that signals the used asked to abort the
        /// test run. If cancellation is requested on this token, all <see href="TestRun">TestRun</see>instances associated with the request will be
        /// automatically cancelled as well.
        /// </param>
        abstract member runHandler: TestRunProfile.runHandler with get, set
        /// <summary>
        /// An extension-provided function that provides detailed statement and
        /// function-level coverage for a file. The editor will call this when more
        /// detail is needed for a file, such as when it's opened in an editor or
        /// expanded in the **Test Coverage** view.
        ///
        /// The <see href="FileCoverage">FileCoverage</see> object passed to this function is the same instance
        /// emitted on <see href="TestRun.addCoverage">TestRun.addCoverage</see> calls associated with this profile.
        /// </summary>
        abstract member loadDetailedCoverage: TestRunProfile.loadDetailedCoverage option with get, set
        /// <summary>
        /// An extension-provided function that provides detailed statement and
        /// function-level coverage for a single test in a file. This is the per-test
        /// sibling of <see href="TestRunProfile.loadDetailedCoverage">TestRunProfile.loadDetailedCoverage</see>, called only if
        /// a test item is provided in <see href="FileCoverage.includesTests">FileCoverage.includesTests</see> and only
        /// for files where such data is reported.
        ///
        /// Often <see href="TestRunProfile.loadDetailedCoverage">TestRunProfile.loadDetailedCoverage</see> will be called first
        /// when a user opens a file, and then this method will be called if they
        /// drill down into specific per-test coverage information. This method
        /// should then return coverage data only for statements and declarations
        /// executed by the specific test during the run.
        ///
        /// The <see href="FileCoverage">FileCoverage</see> object passed to this function is the same
        /// instance emitted on <see href="TestRun.addCoverage">TestRun.addCoverage</see> calls associated with this profile.
        /// </summary>
        /// <param name="testRun">
        /// The test run that generated the coverage data.
        /// </param>
        /// <param name="fileCoverage">
        /// The file coverage object to load detailed coverage for.
        /// </param>
        /// <param name="fromTestItem">
        /// The test item to request coverage information for.
        /// </param>
        /// <param name="token">
        /// A cancellation token that indicates the operation should be cancelled.
        /// </param>
        abstract member loadDetailedCoverageForTest: TestRunProfile.loadDetailedCoverageForTest option with get, set
        /// <summary>
        /// Deletes the run profile.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type TestController =
        /// <summary>
        /// The id of the controller passed in <see href="tests.createTestController">tests.createTestController</see>.
        /// This must be globally unique.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// Human-readable label for the test controller.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// A collection of "top-level" <see href="TestItem">TestItem</see> instances, which can in
        /// turn have their own <see href="TestItem.childrenchildren">TestItem.childrenchildren</see> to form the
        /// "test tree."
        ///
        /// The extension controls when to add tests. For example, extensions should
        /// add tests for a file when <see href="workspace.onDidOpenTextDocument">workspace.onDidOpenTextDocument</see>
        /// fires in order for decorations for tests within a file to be visible.
        ///
        /// However, the editor may sometimes explicitly request children using the
        /// <see href="resolveHandler">resolveHandler</see> See the documentation on that method for more details.
        /// </summary>
        abstract member items: TestItemCollection with get
        /// <summary>
        /// Creates a profile used for running tests. Extensions must create
        /// at least one profile in order for tests to be run.
        /// </summary>
        /// <param name="label">
        /// A human-readable label for this profile.
        /// </param>
        /// <param name="kind">
        /// Configures what kind of execution this profile manages.
        /// </param>
        /// <param name="runHandler">
        /// Function called to start a test run.
        /// </param>
        /// <param name="isDefault">
        /// Whether this is the default action for its kind.
        /// </param>
        /// <param name="tag">
        /// Profile test tag.
        /// </param>
        /// <param name="supportsContinuousRun">
        /// Whether the profile supports continuous running.
        /// </param>
        /// <returns>
        /// An instance of a <see href="TestRunProfile">TestRunProfile</see>, which is automatically
        /// associated with this controller.
        /// </returns>
        abstract member createRunProfile: label: string * kind: TestRunProfileKind * runHandler: TestController.createRunProfile.runHandler * ?isDefault: bool * ?tag: TestTag * ?supportsContinuousRun: bool -> TestRunProfile
        /// <summary>
        /// A function provided by the extension that the editor may call to request
        /// children of a test item, if the <see href="TestItem.canResolveChildren">TestItem.canResolveChildren</see> is
        /// <c>true</c>. When called, the item should discover children and call
        /// <see href="TestController.createTestItem">TestController.createTestItem</see> as children are discovered.
        ///
        /// Generally the extension manages the lifecycle of test items, but under
        /// certain conditions the editor may request the children of a specific
        /// item to be loaded. For example, if the user requests to re-run tests
        /// after reloading the editor, the editor may need to call this method
        /// to resolve the previously-run tests.
        ///
        /// The item in the explorer will automatically be marked as "busy" until
        /// the function returns or the returned thenable resolves.
        /// </summary>
        /// <param name="item">
        /// An unresolved test item for which children are being
        /// requested, or <c>undefined</c> to resolve the controller's initial <see href="TestController.items">items</see>".
        /// </param>
        abstract member resolveHandler: (TestItem option -> U2<Thenable<unit>, unit>) option with get, set
        /// <summary>
        /// If this method is present, a refresh button will be present in the
        /// UI, and this method will be invoked when it's clicked. When called,
        /// the extension should scan the workspace for any new, changed, or
        /// removed tests.
        ///
        /// It's recommended that extensions try to update tests in realtime, using
        /// a <see href="FileSystemWatcher">FileSystemWatcher</see> for example, and use this method as a fallback.
        /// </summary>
        /// <returns>
        /// A thenable that resolves when tests have been refreshed.
        /// </returns>
        abstract member refreshHandler: (CancellationToken -> U2<Thenable<unit>, unit>) option with get, set
        /// <summary>
        /// Creates a <see href="TestRun">TestRun</see>. This should be called by the
        /// <see href="TestRunProfile">TestRunProfile</see> when a request is made to execute tests, and may
        /// also be called if a test run is detected externally. Once created, tests
        /// that are included in the request will be moved into the queued state.
        ///
        /// All runs created using the same <c>request</c> instance will be grouped
        /// together. This is useful if, for example, a single suite of tests is
        /// run on multiple platforms.
        /// </summary>
        /// <param name="request">
        /// Test run request. Only tests inside the <c>include</c> may be
        /// modified, and tests in its <c>exclude</c> are ignored.
        /// </param>
        /// <param name="name">
        /// The human-readable name of the run. This can be used to
        /// disambiguate multiple sets of results in a test run. It is useful if
        /// tests are run across multiple platforms, for example.
        /// </param>
        /// <param name="persist">
        /// Whether the results created by the run should be
        /// persisted in the editor. This may be false if the results are coming from
        /// a file already saved externally, such as a coverage information file.
        /// </param>
        /// <returns>
        /// An instance of the <see href="TestRun">TestRun</see>. It will be considered "running"
        /// from the moment this method is invoked until <see href="TestRun.end">TestRun.end</see> is called.
        /// </returns>
        abstract member createTestRun: request: TestRunRequest * ?name: string * ?persist: bool -> TestRun
        /// <summary>
        /// Creates a new managed <see href="TestItem">TestItem</see> instance. It can be added into
        /// the <see href="TestItem.children">TestItem.children</see> of an existing item, or into the
        /// <see href="TestController.items">TestController.items</see>.
        /// </summary>
        /// <param name="id">
        /// Identifier for the TestItem. The test item's ID must be unique
        /// in the <see href="TestItemCollection">TestItemCollection</see> it's added to.
        /// </param>
        /// <param name="label">
        /// Human-readable label of the test item.
        /// </param>
        /// <param name="uri">
        /// URI this TestItem is associated with. May be a file or directory.
        /// </param>
        abstract member createTestItem: id: string * label: string * ?uri: Uri -> TestItem
        /// <summary>
        /// Marks an item's results as being outdated. This is commonly called when
        /// code or configuration changes and previous results should no longer
        /// be considered relevant. The same logic used to mark results as outdated
        /// may be used to drive <see href="TestRunRequest.continuouscontinuous">test runs</see>".
        ///
        /// If an item is passed to this method, test results for the item and all of
        /// its children will be marked as outdated. If no item is passed, then all
        /// test owned by the TestController will be marked as outdated.
        ///
        /// Any test runs started before the moment this method is called, including
        /// runs which may still be ongoing, will be marked as outdated and deprioritized
        /// in the editor's UI.
        /// </summary>
        /// <param name="items">
        /// Item to mark as outdated. If undefined, all the controller's items are marked outdated.
        /// </param>
        abstract member invalidateTestResults: ?items: U2<TestItem, ReadonlyArray<TestItem>> -> unit
        /// <summary>
        /// Unregisters the test controller, disposing of its associated tests
        /// and unpersisted results.
        /// </summary>
        abstract member dispose: unit -> unit

    /// <summary>
    /// A TestRunRequest is a precursor to a <see href="TestRun">TestRun</see>, which in turn is
    /// created by passing a request to <see href="TestController.createTestRun">TestController.createTestRun</see>. The
    /// TestRunRequest contains information about which tests should be run, which
    /// should not be run, and how they are run (via the <see href="TestRunRequest.profileprofile">TestRunRequest.profileprofile</see>).
    ///
    /// In general, TestRunRequests are created by the editor and pass to
    /// <see href="TestRunProfile.runHandler">TestRunProfile.runHandler</see>, however you can also create test
    /// requests and runs outside of the <c>runHandler</c>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TestRunRequest =
        /// <summary>
        /// A filter for specific tests to run. If given, the extension should run
        /// all of the included tests and all their children, excluding any tests
        /// that appear in <see href="TestRunRequest.exclude">TestRunRequest.exclude</see>. If this property is
        /// undefined, then the extension should simply run all tests.
        ///
        /// The process of running tests should resolve the children of any test
        /// items who have not yet been resolved.
        /// </summary>
        abstract member ``include``: ReadonlyArray<TestItem> option with get
        /// <summary>
        /// An array of tests the user has marked as excluded from the test included
        /// in this run; exclusions should apply after inclusions.
        ///
        /// May be omitted if no exclusions were requested. Test controllers should
        /// not run excluded tests or any children of excluded tests.
        /// </summary>
        abstract member exclude: ReadonlyArray<TestItem> option with get
        /// <summary>
        /// The profile used for this request. This will always be defined
        /// for requests issued from the editor UI, though extensions may
        /// programmatically create requests not associated with any profile.
        /// </summary>
        abstract member profile: TestRunProfile option with get
        /// <summary>
        /// Whether the profile should run continuously as source code changes. Only
        /// relevant for profiles that set <see href="TestRunProfile.supportsContinuousRun">TestRunProfile.supportsContinuousRun</see>.
        /// </summary>
        abstract member continuous: bool option with get
        /// <summary>
        /// Controls how test Test Results view is focused.  If true, the editor
        /// will keep the maintain the user's focus. If false, the editor will
        /// prefer to move focus into the Test Results view, although
        /// this may be configured by users.
        /// </summary>
        abstract member preserveFocus: bool with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TestRun =
        /// <summary>
        /// The human-readable name of the run. This can be used to
        /// disambiguate multiple sets of results in a test run. It is useful if
        /// tests are run across multiple platforms, for example.
        /// </summary>
        abstract member name: string option with get
        /// <summary>
        /// A cancellation token which will be triggered when the test run is
        /// canceled from the UI.
        /// </summary>
        abstract member token: CancellationToken with get
        /// <summary>
        /// Whether the test run will be persisted across reloads by the editor.
        /// </summary>
        abstract member isPersisted: bool with get
        /// <summary>
        /// Indicates a test is queued for later execution.
        /// </summary>
        /// <param name="test">
        /// Test item to update.
        /// </param>
        abstract member enqueued: test: TestItem -> unit
        /// <summary>
        /// Indicates a test has started running.
        /// </summary>
        /// <param name="test">
        /// Test item to update.
        /// </param>
        abstract member started: test: TestItem -> unit
        /// <summary>
        /// Indicates a test has been skipped.
        /// </summary>
        /// <param name="test">
        /// Test item to update.
        /// </param>
        abstract member skipped: test: TestItem -> unit
        /// <summary>
        /// Indicates a test has failed. You should pass one or more
        /// <see href="TestMessageTestMessages">TestMessageTestMessages</see> to describe the failure.
        /// </summary>
        /// <param name="test">
        /// Test item to update.
        /// </param>
        /// <param name="message">
        /// Messages associated with the test failure.
        /// </param>
        /// <param name="duration">
        /// How long the test took to execute, in milliseconds.
        /// </param>
        abstract member failed: test: TestItem * message: U2<TestMessage, ReadonlyArray<TestMessage>> * ?duration: float -> unit
        /// <summary>
        /// Indicates a test has errored. You should pass one or more
        /// <see href="TestMessageTestMessages">TestMessageTestMessages</see> to describe the failure. This differs
        /// from the "failed" state in that it indicates a test that couldn't be
        /// executed at all, from a compilation error for example.
        /// </summary>
        /// <param name="test">
        /// Test item to update.
        /// </param>
        /// <param name="message">
        /// Messages associated with the test failure.
        /// </param>
        /// <param name="duration">
        /// How long the test took to execute, in milliseconds.
        /// </param>
        abstract member errored: test: TestItem * message: U2<TestMessage, ReadonlyArray<TestMessage>> * ?duration: float -> unit
        /// <summary>
        /// Indicates a test has passed.
        /// </summary>
        /// <param name="test">
        /// Test item to update.
        /// </param>
        /// <param name="duration">
        /// How long the test took to execute, in milliseconds.
        /// </param>
        abstract member passed: test: TestItem * ?duration: float -> unit
        /// <summary>
        /// Appends raw output from the test runner. On the user's request, the
        /// output will be displayed in a terminal. ANSI escape sequences,
        /// such as colors and text styles, are supported. New lines must be given
        /// as CRLF (<c>\r\n</c>) rather than LF (<c>\n</c>).
        /// </summary>
        /// <param name="output">
        /// Output text to append.
        /// </param>
        /// <param name="location">
        /// Indicate that the output was logged at the given
        /// location.
        /// </param>
        /// <param name="test">
        /// Test item to associate the output with.
        /// </param>
        abstract member appendOutput: output: string * ?location: Location * ?test: TestItem -> unit
        /// <summary>
        /// Adds coverage for a file in the run.
        /// </summary>
        abstract member addCoverage: fileCoverage: FileCoverage -> unit
        /// <summary>
        /// Signals the end of the test run. Any tests included in the run whose
        /// states have not been updated will have their state reset.
        /// </summary>
        abstract member ``end``: unit -> unit
        /// <summary>
        /// An event fired when the editor is no longer interested in data
        /// associated with the test run.
        /// </summary>
        abstract member onDidDispose: Event<unit> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TestItemCollection =
        inherit Iterable<string * TestItem>
        /// <summary>
        /// Gets the number of items in the collection.
        /// </summary>
        abstract member size: float with get
        /// <summary>
        /// Replaces the items stored by the collection.
        /// </summary>
        /// <param name="items">
        /// Items to store.
        /// </param>
        abstract member replace: items: ReadonlyArray<TestItem> -> unit
        /// <summary>
        /// Iterate over each entry in this collection.
        /// </summary>
        /// <param name="callback">
        /// Function to execute for each entry.
        /// </param>
        /// <param name="thisArg">
        /// The <c>this</c> context used when invoking the handler function.
        /// </param>
        abstract member forEach: callback: TestItemCollection.forEach.callback * ?thisArg: obj -> unit
        /// <summary>
        /// Adds the test item to the children. If an item with the same ID already
        /// exists, it'll be replaced.
        /// </summary>
        /// <param name="item">
        /// Item to add.
        /// </param>
        abstract member add: item: TestItem -> unit
        /// <summary>
        /// Removes a single test item from the collection.
        /// </summary>
        /// <param name="itemId">
        /// Item ID to delete.
        /// </param>
        abstract member delete: itemId: string -> unit
        /// <summary>
        /// Efficiently gets a test item by ID, if it exists, in the children.
        /// </summary>
        /// <param name="itemId">
        /// Item ID to get.
        /// </param>
        /// <returns>
        /// The found item or undefined if it does not exist.
        /// </returns>
        abstract member get: itemId: string -> TestItem option

    [<AllowNullLiteral>]
    [<Interface>]
    type TestItem =
        /// <summary>
        /// Identifier for the <c>TestItem</c>. This is used to correlate
        /// test results and tests in the document with those in the workspace
        /// (test explorer). This cannot change for the lifetime of the <c>TestItem</c>,
        /// and must be unique among its parent's direct children.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// URI this <c>TestItem</c> is associated with. May be a file or directory.
        /// </summary>
        abstract member uri: Uri option with get
        /// <summary>
        /// The children of this test item. For a test suite, this may contain the
        /// individual test cases or nested suites.
        /// </summary>
        abstract member children: TestItemCollection with get
        /// <summary>
        /// The parent of this item. It's set automatically, and is undefined
        /// top-level items in the <see href="TestController.items">TestController.items</see> and for items that
        /// aren't yet included in another item's <see href="TestItem.childrenchildren">TestItem.childrenchildren</see>.
        /// </summary>
        abstract member parent: TestItem option with get
        /// <summary>
        /// Tags associated with this test item. May be used in combination with
        /// <see href="TestRunProfile.tagtags">TestRunProfile.tagtags</see>, or simply as an organizational feature.
        /// </summary>
        abstract member tags: ReadonlyArray<TestTag> with get, set
        /// <summary>
        /// Indicates whether this test item may have children discovered by resolving.
        ///
        /// If true, this item is shown as expandable in the Test Explorer view and
        /// expanding the item will cause <see href="TestController.resolveHandler">TestController.resolveHandler</see>
        /// to be invoked with the item.
        ///
        /// Default to <c>false</c>.
        /// </summary>
        abstract member canResolveChildren: bool with get, set
        /// <summary>
        /// Controls whether the item is shown as "busy" in the Test Explorer view.
        /// This is useful for showing status while discovering children.
        ///
        /// Defaults to <c>false</c>.
        /// </summary>
        abstract member busy: bool with get, set
        /// <summary>
        /// Display name describing the test case.
        /// </summary>
        abstract member label: string with get, set
        /// <summary>
        /// Optional description that appears next to the label.
        /// </summary>
        abstract member description: string option with get, set
        /// <summary>
        /// A string that should be used when comparing this item
        /// with other items. When <c>falsy</c> the <see href="TestItem.labellabel">TestItem.labellabel</see>
        /// is used.
        /// </summary>
        abstract member sortText: string option with get, set
        /// <summary>
        /// Location of the test item in its <see href="TestItem.uriuri">TestItem.uriuri</see>.
        ///
        /// This is only meaningful if the <c>uri</c> points to a file.
        /// </summary>
        abstract member range: Range option with get, set
        /// <summary>
        /// Optional error encountered while loading the test.
        ///
        /// Note that this is not a test result and should only be used to represent errors in
        /// test discovery, such as syntax errors.
        /// </summary>
        abstract member error: U2<string, MarkdownString> option with get, set

    /// <summary>
    /// A stack frame found in the <see href="TestMessage.stackTrace">TestMessage.stackTrace</see>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TestMessageStackFrame =
        /// <summary>
        /// The location of this stack frame. This should be provided as a URI if the
        /// location of the call frame can be accessed by the editor.
        /// </summary>
        abstract member uri: Uri option with get, set
        /// <summary>
        /// Position of the stack frame within the file.
        /// </summary>
        abstract member position: Position option with get, set
        /// <summary>
        /// The name of the stack frame, typically a method or function name.
        /// </summary>
        abstract member label: string with get, set

    /// <summary>
    /// Message associated with the test state. Can be linked to a specific
    /// source range -- useful for assertion failures, for example.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TestMessage =
        /// <summary>
        /// Human-readable message text to display.
        /// </summary>
        abstract member message: U2<string, MarkdownString> with get, set
        /// <summary>
        /// Expected test output. If given with <see href="TestMessage.actualOutputactualOutput">TestMessage.actualOutputactualOutput</see>, a diff view will be shown.
        /// </summary>
        abstract member expectedOutput: string option with get, set
        /// <summary>
        /// Actual test output. If given with <see href="TestMessage.expectedOutputexpectedOutput">TestMessage.expectedOutputexpectedOutput</see>, a diff view will be shown.
        /// </summary>
        abstract member actualOutput: string option with get, set
        /// <summary>
        /// Associated file location.
        /// </summary>
        abstract member location: Location option with get, set
        /// <summary>
        /// Context value of the test item. This can be used to contribute message-
        /// specific actions to the test peek view. The value set here can be found
        /// in the <c>testMessage</c> property of the following <c>menus</c> contribution points:
        ///
        /// - <c>testing/message/context</c> - context menu for the message in the results tree
        /// - <c>testing/message/content</c> - a prominent button overlaying editor content where
        ///    the message is displayed.
        ///
        /// For example:
        ///
        /// <code lang="json">
        /// "contributes": {
        ///   "menus": {
        ///     "testing/message/content": [
        ///       {
        ///         "command": "extension.deleteCommentThread",
        ///         "when": "testMessage == canApplyRichDiff"
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        ///
        /// The command will be called with an object containing:
        /// - <c>test</c>: the <see href="TestItem">TestItem</see> the message is associated with, *if* it
        ///    is still present in the <see href="TestController.items">TestController.items</see> collection.
        /// - <c>message</c>: the <see href="TestMessage">TestMessage</see> instance.
        /// </summary>
        abstract member contextValue: string option with get, set
        /// <summary>
        /// The stack trace associated with the message or failure.
        /// </summary>
        abstract member stackTrace: ResizeArray<TestMessageStackFrame> option with get, set
        /// <summary>
        /// Creates a new TestMessage that will present as a diff in the editor.
        /// </summary>
        /// <param name="message">
        /// Message to display to the user.
        /// </param>
        /// <param name="expected">
        /// Expected output.
        /// </param>
        /// <param name="actual">
        /// Actual output.
        /// </param>
        static member inline diff (message: U2<string, MarkdownString>, expected: string, actual: string): TestMessage =
            emitJsExpr (message, expected, actual) $$"""
import { TestMessage } from "vscode";
TestMessage.diff($0, $1, $2)"""

    /// <summary>
    /// A class that contains information about a covered resource. A count can
    /// be give for lines, branches, and declarations in a file.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TestCoverageCount =
        /// <summary>
        /// Number of items covered in the file.
        /// </summary>
        abstract member covered: float with get, set
        /// <summary>
        /// Total number of covered items in the file.
        /// </summary>
        abstract member total: float with get, set

    /// <summary>
    /// Contains coverage metadata for a file.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type FileCoverage =
        /// <summary>
        /// File URI.
        /// </summary>
        abstract member uri: Uri with get
        /// <summary>
        /// Statement coverage information. If the reporter does not provide statement
        /// coverage information, this can instead be used to represent line coverage.
        /// </summary>
        abstract member statementCoverage: TestCoverageCount with get, set
        /// <summary>
        /// Branch coverage information.
        /// </summary>
        abstract member branchCoverage: TestCoverageCount option with get, set
        /// <summary>
        /// Declaration coverage information. Depending on the reporter and
        /// language, this may be types such as functions, methods, or namespaces.
        /// </summary>
        abstract member declarationCoverage: TestCoverageCount option with get, set
        /// <summary>
        /// A list of <see href="TestItemtest">cases</see>" that generated coverage in this
        /// file. If set, then <see href="TestRunProfile.loadDetailedCoverageForTest">TestRunProfile.loadDetailedCoverageForTest</see>
        /// should also be defined in order to retrieve detailed coverage information.
        /// </summary>
        abstract member includesTests: ResizeArray<TestItem> option with get, set
        /// <summary>
        /// Creates a <see href="FileCoverage">FileCoverage</see> instance with counts filled in from
        /// the coverage details.
        /// </summary>
        /// <param name="uri">
        /// Covered file URI
        /// </param>
        /// <param name="details">
        /// Detailed coverage information
        /// </param>
        static member inline fromDetails (uri: Uri, details: ReadonlyArray<FileCoverageDetail>): FileCoverage =
            emitJsExpr (uri, details) $$"""
import { FileCoverage } from "vscode";
FileCoverage.fromDetails($0, $1)"""

    /// <summary>
    /// Contains coverage information for a single statement or line.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type StatementCoverage =
        /// <summary>
        /// The number of times this statement was executed, or a boolean indicating
        /// whether it was executed if the exact count is unknown. If zero or false,
        /// the statement will be marked as un-covered.
        /// </summary>
        abstract member executed: U2<float, bool> with get, set
        /// <summary>
        /// Statement location.
        /// </summary>
        abstract member location: U2<Position, Range> with get, set
        /// <summary>
        /// Coverage from branches of this line or statement. If it's not a
        /// conditional, this will be empty.
        /// </summary>
        abstract member branches: ResizeArray<BranchCoverage> with get, set

    /// <summary>
    /// Contains coverage information for a branch of a <see href="StatementCoverage">StatementCoverage</see>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type BranchCoverage =
        /// <summary>
        /// The number of times this branch was executed, or a boolean indicating
        /// whether it was executed if the exact count is unknown. If zero or false,
        /// the branch will be marked as un-covered.
        /// </summary>
        abstract member executed: U2<float, bool> with get, set
        /// <summary>
        /// Branch location.
        /// </summary>
        abstract member location: U2<Position, Range> option with get, set
        /// <summary>
        /// Label for the branch, used in the context of "the ${label} branch was
        /// not taken," for example.
        /// </summary>
        abstract member label: string option with get, set

    /// <summary>
    /// Contains coverage information for a declaration. Depending on the reporter
    /// and language, this may be types such as functions, methods, or namespaces.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type DeclarationCoverage =
        /// <summary>
        /// Name of the declaration.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The number of times this declaration was executed, or a boolean
        /// indicating whether it was executed if the exact count is unknown. If
        /// zero or false, the declaration will be marked as un-covered.
        /// </summary>
        abstract member executed: U2<float, bool> with get, set
        /// <summary>
        /// Declaration location.
        /// </summary>
        abstract member location: U2<Position, Range> with get, set

    /// <summary>
    /// Coverage details returned from <see href="TestRunProfile.loadDetailedCoverage">TestRunProfile.loadDetailedCoverage</see>.
    /// </summary>
    type FileCoverageDetail =
        U2<StatementCoverage, DeclarationCoverage>

    /// <summary>
    /// The tab represents a single text based resource.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TabInputText =
        /// <summary>
        /// The uri represented by the tab.
        /// </summary>
        abstract member uri: Uri with get

    /// <summary>
    /// The tab represents two text based resources
    /// being rendered as a diff.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TabInputTextDiff =
        /// <summary>
        /// The uri of the original text resource.
        /// </summary>
        abstract member original: Uri with get
        /// <summary>
        /// The uri of the modified text resource.
        /// </summary>
        abstract member modified: Uri with get

    /// <summary>
    /// The tab represents a custom editor.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TabInputCustom =
        /// <summary>
        /// The uri that the tab is representing.
        /// </summary>
        abstract member uri: Uri with get
        /// <summary>
        /// The type of custom editor.
        /// </summary>
        abstract member viewType: string with get

    /// <summary>
    /// The tab represents a webview.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TabInputWebview =
        /// <summary>
        /// The type of webview. Maps to {@linkcode WebviewPanel.viewTypeWebviewPanel's viewType}
        /// </summary>
        abstract member viewType: string with get

    /// <summary>
    /// The tab represents a notebook.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TabInputNotebook =
        /// <summary>
        /// The uri that the tab is representing.
        /// </summary>
        abstract member uri: Uri with get
        /// <summary>
        /// The type of notebook. Maps to {@linkcode NotebookDocument.notebookTypeNotebookDocuments's notebookType}
        /// </summary>
        abstract member notebookType: string with get

    /// <summary>
    /// The tabs represents two notebooks in a diff configuration.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TabInputNotebookDiff =
        /// <summary>
        /// The uri of the original notebook.
        /// </summary>
        abstract member original: Uri with get
        /// <summary>
        /// The uri of the modified notebook.
        /// </summary>
        abstract member modified: Uri with get
        /// <summary>
        /// The type of notebook. Maps to {@linkcode NotebookDocument.notebookTypeNotebookDocuments's notebookType}
        /// </summary>
        abstract member notebookType: string with get

    /// <summary>
    /// The tab represents a terminal in the editor area.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TabInputTerminal =
        interface end

    [<AllowNullLiteral>]
    [<Interface>]
    type Tab =
        /// <summary>
        /// The text displayed on the tab.
        /// </summary>
        abstract member label: string with get
        /// <summary>
        /// The group which the tab belongs to.
        /// </summary>
        abstract member group: TabGroup with get
        /// <summary>
        /// Defines the structure of the tab i.e. text, notebook, custom, etc.
        /// Resource and other useful properties are defined on the tab kind.
        /// </summary>
        abstract member input: U8<TabInputText, TabInputTextDiff, TabInputCustom, TabInputWebview, TabInputNotebook, TabInputNotebookDiff, TabInputTerminal, obj> with get
        /// <summary>
        /// Whether or not the tab is currently active.
        /// This is dictated by being the selected tab in the group.
        /// </summary>
        abstract member isActive: bool with get
        /// <summary>
        /// Whether or not the dirty indicator is present on the tab.
        /// </summary>
        abstract member isDirty: bool with get
        /// <summary>
        /// Whether or not the tab is pinned (pin icon is present).
        /// </summary>
        abstract member isPinned: bool with get
        /// <summary>
        /// Whether or not the tab is in preview mode.
        /// </summary>
        abstract member isPreview: bool with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TabChangeEvent =
        /// <summary>
        /// The tabs that have been opened.
        /// </summary>
        abstract member opened: ReadonlyArray<Tab> with get
        /// <summary>
        /// The tabs that have been closed.
        /// </summary>
        abstract member closed: ReadonlyArray<Tab> with get
        /// <summary>
        /// Tabs that have changed, e.g have changed
        /// their <see href="Tab.isActiveactive">Tab.isActiveactive</see> state.
        /// </summary>
        abstract member changed: ReadonlyArray<Tab> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TabGroupChangeEvent =
        /// <summary>
        /// Tab groups that have been opened.
        /// </summary>
        abstract member opened: ReadonlyArray<TabGroup> with get
        /// <summary>
        /// Tab groups that have been closed.
        /// </summary>
        abstract member closed: ReadonlyArray<TabGroup> with get
        /// <summary>
        /// Tab groups that have changed, e.g have changed
        /// their <see href="TabGroup.isActiveactive">TabGroup.isActiveactive</see> state.
        /// </summary>
        abstract member changed: ReadonlyArray<TabGroup> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TabGroup =
        /// <summary>
        /// Whether or not the group is currently active.
        ///
        /// *Note* that only one tab group is active at a time, but that multiple tab
        /// groups can have an <see href="activeTabactive">tab</see>".
        /// </summary>
        abstract member isActive: bool with get
        /// <summary>
        /// The view column of the group.
        /// </summary>
        abstract member viewColumn: ViewColumn with get
        /// <summary>
        /// The active <see href="Tabtab">Tabtab</see> in the group. This is the tab whose contents are currently
        /// being rendered.
        ///
        /// *Note* that there can be one active tab per group but there can only be one <see href="TabGroups.activeTabGroupactive">group</see>".
        /// </summary>
        abstract member activeTab: Tab option with get
        /// <summary>
        /// The list of tabs contained within the group.
        /// This can be empty if the group has no tabs open.
        /// </summary>
        abstract member tabs: ReadonlyArray<Tab> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type TabGroups =
        /// <summary>
        /// All the groups within the group container.
        /// </summary>
        abstract member all: ReadonlyArray<TabGroup> with get
        /// <summary>
        /// The currently active group.
        /// </summary>
        abstract member activeTabGroup: TabGroup with get
        /// <summary>
        /// An <see href="Eventevent">Eventevent</see> which fires when <see href="TabGrouptab">groups</see>" have changed.
        /// </summary>
        abstract member onDidChangeTabGroups: Event<TabGroupChangeEvent> with get
        /// <summary>
        /// An <see href="Eventevent">Eventevent</see> which fires when <see href="Tabtabs">Tabtabs</see> have changed.
        /// </summary>
        abstract member onDidChangeTabs: Event<TabChangeEvent> with get
        /// <summary>
        /// Closes the tab. This makes the tab object invalid and the tab
        /// should no longer be used for further actions.
        /// Note: In the case of a dirty tab, a confirmation dialog will be shown which may be cancelled. If cancelled the tab is still valid
        /// Closes the tab group. This makes the tab group object invalid and the tab group
        /// should no longer be used for further actions.
        /// </summary>
        /// <param name="tab">
        /// The tab to close.
        /// </param>
        /// <param name="preserveFocus">
        /// When <c>true</c> focus will remain in its current position. If <c>false</c> it will jump to the next tab.
        /// </param>
        /// <returns>
        /// A promise that resolves to <c>true</c> when all tabs have been closed.
        /// </returns>
        abstract member close: tab: U2<Tab, ReadonlyArray<Tab>> * ?preserveFocus: bool -> Thenable<bool>
        /// <summary>
        /// Closes the tab. This makes the tab object invalid and the tab
        /// should no longer be used for further actions.
        /// Note: In the case of a dirty tab, a confirmation dialog will be shown which may be cancelled. If cancelled the tab is still valid
        /// Closes the tab group. This makes the tab group object invalid and the tab group
        /// should no longer be used for further actions.
        /// </summary>
        /// <param name="tabGroup">
        /// The tab group to close.
        /// </param>
        /// <param name="preserveFocus">
        /// When <c>true</c> focus will remain in its current position.
        /// </param>
        /// <returns>
        /// A promise that resolves to <c>true</c> when all tab groups have been closed.
        /// </returns>
        abstract member close: tabGroup: U2<TabGroup, ReadonlyArray<TabGroup>> * ?preserveFocus: bool -> Thenable<bool>

    /// <summary>
    /// A special value wrapper denoting a value that is safe to not clean.
    /// This is to be used when you can guarantee no identifiable information is contained in the value and the cleaning is improperly redacting it.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type TelemetryTrustedValue<'T> =
        /// <summary>
        /// The value that is trusted to not contain PII.
        /// </summary>
        abstract member value: 'T with get

    type TelemetryTrustedValue =
        TelemetryTrustedValue<obj>

    [<AllowNullLiteral>]
    [<Interface>]
    type TelemetryLogger =
        /// <summary>
        /// An <see href="Event">Event</see> which fires when the enablement state of usage or error telemetry changes.
        /// </summary>
        abstract member onDidChangeEnableStates: Event<TelemetryLogger> with get
        /// <summary>
        /// Whether or not usage telemetry is enabled for this logger.
        /// </summary>
        abstract member isUsageEnabled: bool with get
        /// <summary>
        /// Whether or not error telemetry is enabled for this logger.
        /// </summary>
        abstract member isErrorsEnabled: bool with get
        /// <summary>
        /// Log a usage event.
        ///
        /// After completing cleaning, telemetry setting checks, and data mix-in calls <c>TelemetrySender.sendEventData</c> to log the event.
        /// Automatically supports echoing to extension telemetry output channel.
        /// </summary>
        /// <param name="eventName">
        /// The event name to log
        /// </param>
        /// <param name="data">
        /// The data to log
        /// </param>
        abstract member logUsage: eventName: string * ?data: TelemetryLogger.logUsage.data -> unit
        /// <summary>
        /// Log an error event.
        ///
        /// After completing cleaning, telemetry setting checks, and data mix-in calls <c>TelemetrySender.sendEventData</c> to log the event. Differs from <c>logUsage</c> in that it will log the event if the telemetry setting is Error+.
        /// Automatically supports echoing to extension telemetry output channel.
        /// Log an error event.
        ///
        /// Calls <c>TelemetrySender.sendErrorData</c>. Does cleaning, telemetry checks, and data mix-in.
        /// Automatically supports echoing to extension telemetry output channel.
        /// Will also automatically log any exceptions thrown within the extension host process.
        /// </summary>
        /// <param name="eventName">
        /// The event name to log
        /// </param>
        /// <param name="data">
        /// The data to log
        /// </param>
        abstract member logError: eventName: string * ?data: TelemetryLogger.logError.data -> unit
        /// <summary>
        /// Log an error event.
        ///
        /// After completing cleaning, telemetry setting checks, and data mix-in calls <c>TelemetrySender.sendEventData</c> to log the event. Differs from <c>logUsage</c> in that it will log the event if the telemetry setting is Error+.
        /// Automatically supports echoing to extension telemetry output channel.
        /// Log an error event.
        ///
        /// Calls <c>TelemetrySender.sendErrorData</c>. Does cleaning, telemetry checks, and data mix-in.
        /// Automatically supports echoing to extension telemetry output channel.
        /// Will also automatically log any exceptions thrown within the extension host process.
        /// </summary>
        /// <param name="error">
        /// The error object which contains the stack trace cleaned of PII
        /// </param>
        /// <param name="data">
        /// Additional data to log alongside the stack trace
        /// </param>
        abstract member logError: error: Exception * ?data: TelemetryLogger.logError.data_1 -> unit
        /// <summary>
        /// Dispose this object and free resources.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type TelemetrySender =
        /// <summary>
        /// Function to send event data without a stacktrace. Used within a <see href="TelemetryLogger">TelemetryLogger</see>
        /// </summary>
        /// <param name="eventName">
        /// The name of the event which you are logging
        /// </param>
        /// <param name="data">
        /// A serializable key value pair that is being logged
        /// </param>
        abstract member sendEventData: eventName: string * ?data: TelemetrySender.sendEventData.data -> unit
        /// <summary>
        /// Function to send an error. Used within a <see href="TelemetryLogger">TelemetryLogger</see>
        /// </summary>
        /// <param name="error">
        /// The error being logged
        /// </param>
        /// <param name="data">
        /// Any additional data to be collected with the exception
        /// </param>
        abstract member sendErrorData: error: Exception * ?data: TelemetrySender.sendErrorData.data -> unit
        /// <summary>
        /// Optional flush function which will give this sender a chance to send any remaining events
        /// as its <see href="TelemetryLogger">TelemetryLogger</see> is being disposed
        /// </summary>
        abstract member flush: unit -> U2<unit, Thenable<unit>>

    [<AllowNullLiteral>]
    [<Interface>]
    type TelemetryLoggerOptions =
        /// <summary>
        /// Whether or not you want to avoid having the built-in common properties such as os, extension name, etc injected into the data object.
        /// Defaults to <c>false</c> if not defined.
        /// </summary>
        abstract member ignoreBuiltInCommonProperties: bool option with get
        /// <summary>
        /// Whether or not unhandled errors on the extension host caused by your extension should be logged to your sender.
        /// Defaults to <c>false</c> if not defined.
        /// </summary>
        abstract member ignoreUnhandledErrors: bool option with get
        /// <summary>
        /// Any additional common properties which should be injected into the data object.
        /// </summary>
        abstract member additionalCommonProperties: TelemetryLoggerOptions.additionalCommonProperties option with get

    /// <summary>
    /// Represents a user request in chat history.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ChatRequestTurn =
        /// <summary>
        /// The prompt as entered by the user.
        ///
        /// Information about references used in this request is stored in <see href="ChatRequestTurn.references">ChatRequestTurn.references</see>.
        ///
        /// *Note* that the <see href="ChatParticipant.name">name</see>" of the participant and the <see href="ChatCommand.name">command</see>"
        /// are not part of the prompt.
        /// </summary>
        abstract member prompt: string with get
        /// <summary>
        /// The id of the chat participant to which this request was directed.
        /// </summary>
        abstract member participant: string with get
        /// <summary>
        /// The name of the <see href="ChatCommand">command</see>" that was selected for this request.
        /// </summary>
        abstract member command: string option with get
        /// <summary>
        /// The references that were used in this message.
        /// </summary>
        abstract member references: ResizeArray<ChatPromptReference> with get
        /// <summary>
        /// The list of tools were attached to this request.
        /// </summary>
        abstract member toolReferences: ReadonlyArray<ChatLanguageModelToolReference> with get

    /// <summary>
    /// Represents a chat participant's response in chat history.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseTurn =
        /// <summary>
        /// The content that was received from the chat participant. Only the stream parts that represent actual content (not metadata) are represented.
        /// </summary>
        abstract member response: ReadonlyArray<U4<ChatResponseMarkdownPart, ChatResponseFileTreePart, ChatResponseAnchorPart, ChatResponseCommandButtonPart>> with get
        /// <summary>
        /// The result that was received from the chat participant.
        /// </summary>
        abstract member result: ChatResult with get
        /// <summary>
        /// The id of the chat participant that this response came from.
        /// </summary>
        abstract member participant: string with get
        /// <summary>
        /// The name of the command that this response came from.
        /// </summary>
        abstract member command: string option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatContext =
        /// <summary>
        /// All of the chat messages so far in the current chat session. Currently, only chat messages for the current participant are included.
        /// </summary>
        abstract member history: ReadonlyArray<U2<ChatRequestTurn, ChatResponseTurn>> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatErrorDetails =
        /// <summary>
        /// An error message that is shown to the user.
        /// </summary>
        abstract member message: string with get, set
        /// <summary>
        /// If set to true, the response will be partly blurred out.
        /// </summary>
        abstract member responseIsFiltered: bool option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResult =
        /// <summary>
        /// If the request resulted in an error, this property defines the error details.
        /// </summary>
        abstract member errorDetails: ChatErrorDetails option with get, set
        /// <summary>
        /// Arbitrary metadata for this result. Can be anything, but must be JSON-stringifyable.
        /// </summary>
        abstract member metadata: ChatResult.metadata option with get

    [<RequireQualifiedAccess>]
    type ChatResultFeedbackKind =
        | Unhelpful = 0
        | Helpful = 1

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResultFeedback =
        /// <summary>
        /// The ChatResult for which the user is providing feedback.
        /// This object has the same properties as the result returned from the participant callback, including <c>metadata</c>, but is not the same instance.
        /// </summary>
        abstract member result: ChatResult with get
        /// <summary>
        /// The kind of feedback that was received.
        /// </summary>
        abstract member kind: ChatResultFeedbackKind with get

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatFollowup =
        /// <summary>
        /// The message to send to the chat.
        /// </summary>
        abstract member prompt: string with get, set
        /// <summary>
        /// A title to show the user. The prompt will be shown by default, when this is unspecified.
        /// </summary>
        abstract member label: string option with get, set
        /// <summary>
        /// By default, the followup goes to the same participant/command. But this property can be set to invoke a different participant by ID.
        /// Followups can only invoke a participant that was contributed by the same extension.
        /// </summary>
        abstract member participant: string option with get, set
        /// <summary>
        /// By default, the followup goes to the same participant/command. But this property can be set to invoke a different command.
        /// </summary>
        abstract member command: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatFollowupProvider =
        /// <summary>
        /// Provide followups for the given result.
        /// </summary>
        /// <param name="result">
        /// This object has the same properties as the result returned from the participant callback, including <c>metadata</c>, but is not the same instance.
        /// </param>
        /// <param name="context">
        /// Extra context passed to a participant.
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        abstract member provideFollowups: result: ChatResult * context: ChatContext * token: CancellationToken -> ProviderResult<ResizeArray<ChatFollowup>>

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatRequestHandler =
        [<Emit("$0($1...)")>]
        abstract member Invoke: request: ChatRequest * context: ChatContext * response: ChatResponseStream * token: CancellationToken -> ProviderResult<U2<ChatResult, unit>>

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatParticipant =
        /// <summary>
        /// A unique ID for this participant.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// An icon for the participant shown in UI.
        /// </summary>
        abstract member iconPath: IconPath option with get, set
        /// <summary>
        /// The handler for requests to this participant.
        /// </summary>
        abstract member requestHandler: ChatRequestHandler with get, set
        /// <summary>
        /// This provider will be called once after each request to retrieve suggested followup questions.
        /// </summary>
        abstract member followupProvider: ChatFollowupProvider option with get, set
        /// <summary>
        /// An event that fires whenever feedback for a result is received, e.g. when a user up- or down-votes
        /// a result.
        ///
        /// The passed <see href="ChatResultFeedback.resultresult">ChatResultFeedback.resultresult</see> is guaranteed to have the same properties as the result that was
        /// previously returned from this chat participant's handler.
        /// </summary>
        abstract member onDidReceiveFeedback: Event<ChatResultFeedback> with get
        /// <summary>
        /// Dispose this participant and free resources.
        /// </summary>
        abstract member dispose: unit -> unit

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatPromptReference =
        /// <summary>
        /// A unique identifier for this kind of reference.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// The start and end index of the reference in the <see href="ChatRequest.promptprompt">ChatRequest.promptprompt</see>. When undefined, the reference was not part of the prompt text.
        ///
        /// *Note* that the indices take the leading <c>#</c>-character into account which means they can
        /// used to modify the prompt as-is.
        /// </summary>
        abstract member range: float * float option with get
        /// <summary>
        /// A description of this value that could be used in an LLM prompt.
        /// </summary>
        abstract member modelDescription: string option with get
        /// <summary>
        /// The value of this reference. The <c>string | Uri | Location</c> types are used today, but this could expand in the future.
        /// </summary>
        abstract member value: U4<string, Uri, Location, obj> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatRequest =
        /// <summary>
        /// The prompt as entered by the user.
        ///
        /// Information about references used in this request is stored in <see href="ChatRequest.references">ChatRequest.references</see>.
        ///
        /// *Note* that the <see href="ChatParticipant.name">name</see>" of the participant and the <see href="ChatCommand.name">command</see>"
        /// are not part of the prompt.
        /// </summary>
        abstract member prompt: string with get
        /// <summary>
        /// The name of the <see href="ChatCommand">command</see>" that was selected for this request.
        /// </summary>
        abstract member command: string option with get
        /// <summary>
        /// The list of references and their values that are referenced in the prompt.
        ///
        /// *Note* that the prompt contains references as authored and that it is up to the participant
        /// to further modify the prompt, for instance by inlining reference values or creating links to
        /// headings which contain the resolved values. References are sorted in reverse by their range
        /// in the prompt. That means the last reference in the prompt is the first in this list. This simplifies
        /// string-manipulation of the prompt.
        /// </summary>
        abstract member references: ReadonlyArray<ChatPromptReference> with get
        /// <summary>
        /// The list of tools that the user attached to their request.
        ///
        /// When a tool reference is present, the chat participant should make a chat request using
        /// <see href="LanguageModelChatToolMode.Required">LanguageModelChatToolMode.Required</see> to force the language model to generate input for the tool. Then, the
        /// participant can use <see href="lm.invokeTool">lm.invokeTool</see> to use the tool attach the result to its request for the user's prompt. The
        /// tool may contribute useful extra context for the user's request.
        /// </summary>
        abstract member toolReferences: ReadonlyArray<ChatLanguageModelToolReference> with get
        /// <summary>
        /// A token that can be passed to <see href="lm.invokeTool">lm.invokeTool</see> when invoking a tool inside the context of handling a chat request.
        /// This associates the tool invocation to a chat session.
        /// </summary>
        abstract member toolInvocationToken: ChatParticipantToolToken with get
        /// <summary>
        /// This is the model that is currently selected in the UI. Extensions can use this or use <see href="lm.selectChatModels">lm.selectChatModels</see> to
        /// pick another model. Don't hold onto this past the lifetime of the request.
        /// </summary>
        abstract member model: LanguageModelChat with get

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseStream =
        /// <summary>
        /// Push a markdown part to this stream. Short-hand for
        /// <c>push(new ChatResponseMarkdownPart(value))</c>.
        /// </summary>
        /// <param name="value">
        /// A markdown string or a string that should be interpreted as markdown. The boolean form of <see href="MarkdownString.isTrusted">MarkdownString.isTrusted</see> is NOT supported.
        /// </param>
        abstract member markdown: value: U2<string, MarkdownString> -> unit
        /// <summary>
        /// Push an anchor part to this stream. Short-hand for
        /// <c>push(new ChatResponseAnchorPart(value, title))</c>.
        /// An anchor is an inline reference to some type of resource.
        /// </summary>
        /// <param name="value">
        /// A uri or location.
        /// </param>
        /// <param name="title">
        /// An optional title that is rendered with value.
        /// </param>
        abstract member anchor: value: U2<Uri, Location> * ?title: string -> unit
        /// <summary>
        /// Push a command button part to this stream. Short-hand for
        /// <c>push(new ChatResponseCommandButtonPart(value, title))</c>.
        /// </summary>
        /// <param name="command">
        /// A Command that will be executed when the button is clicked.
        /// </param>
        abstract member button: command: Command -> unit
        /// <summary>
        /// Push a filetree part to this stream. Short-hand for
        /// <c>push(new ChatResponseFileTreePart(value))</c>.
        /// </summary>
        /// <param name="value">
        /// File tree data.
        /// </param>
        /// <param name="baseUri">
        /// The base uri to which this file tree is relative.
        /// </param>
        abstract member filetree: value: ResizeArray<ChatResponseFileTree> * baseUri: Uri -> unit
        /// <summary>
        /// Push a progress part to this stream. Short-hand for
        /// <c>push(new ChatResponseProgressPart(value))</c>.
        /// </summary>
        /// <param name="value">
        /// A progress message
        /// </param>
        abstract member progress: value: string -> unit
        /// <summary>
        /// Push a reference to this stream. Short-hand for
        /// <c>push(new ChatResponseReferencePart(value))</c>.
        ///
        /// *Note* that the reference is not rendered inline with the response.
        /// </summary>
        /// <param name="value">
        /// A uri or location
        /// </param>
        /// <param name="iconPath">
        /// Icon for the reference shown in UI
        /// </param>
        abstract member reference: value: U2<Uri, Location> * ?iconPath: IconPath -> unit
        /// <summary>
        /// Pushes a part to this stream.
        /// </summary>
        /// <param name="part">
        /// A response part, rendered or metadata
        /// </param>
        abstract member push: part: ChatResponsePart -> unit

    /// <summary>
    /// Represents a part of a chat response that is formatted as Markdown.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseMarkdownPart =
        /// <summary>
        /// A markdown string or a string that should be interpreted as markdown.
        /// </summary>
        abstract member value: MarkdownString with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseFileTree =
        /// <summary>
        /// The name of the file or directory.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// An array of child file trees, if the current file tree is a directory.
        /// </summary>
        abstract member children: ResizeArray<ChatResponseFileTree> option with get, set

    /// <summary>
    /// Represents a part of a chat response that is a file tree.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseFileTreePart =
        /// <summary>
        /// File tree data.
        /// </summary>
        abstract member value: ResizeArray<ChatResponseFileTree> with get, set
        /// <summary>
        /// The base uri to which this file tree is relative
        /// </summary>
        abstract member baseUri: Uri with get, set

    /// <summary>
    /// Represents a part of a chat response that is an anchor, that is rendered as a link to a target.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseAnchorPart =
        /// <summary>
        /// The target of this anchor.
        /// </summary>
        abstract member value: U2<Uri, Location> with get, set
        /// <summary>
        /// An optional title that is rendered with value.
        /// </summary>
        abstract member title: string option with get, set

    /// <summary>
    /// Represents a part of a chat response that is a progress message.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseProgressPart =
        /// <summary>
        /// The progress message
        /// </summary>
        abstract member value: string with get, set

    /// <summary>
    /// Represents a part of a chat response that is a reference, rendered separately from the content.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseReferencePart =
        /// <summary>
        /// The reference target.
        /// </summary>
        abstract member value: U2<Uri, Location> with get, set
        /// <summary>
        /// The icon for the reference.
        /// </summary>
        abstract member iconPath: IconPath option with get, set

    /// <summary>
    /// Represents a part of a chat response that is a button that executes a command.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type ChatResponseCommandButtonPart =
        /// <summary>
        /// The command that will be executed when the button is clicked.
        /// </summary>
        abstract member value: Command with get, set

    /// <summary>
    /// Represents the different chat response types.
    /// </summary>
    type ChatResponsePart =
        U6<ChatResponseMarkdownPart, ChatResponseFileTreePart, ChatResponseAnchorPart, ChatResponseProgressPart, ChatResponseReferencePart, ChatResponseCommandButtonPart>

    module chat =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// Create a new <see href="ChatParticipantchat">participant</see>" instance.
            /// </summary>
            /// <param name="id">
            /// A unique identifier for the participant.
            /// </param>
            /// <param name="handler">
            /// A request handler for the participant.
            /// </param>
            /// <returns>
            /// A new chat participant
            /// </returns>
            [<Emit("$0.createChatParticipant($1...)")>]
            abstract member createChatParticipant: id: string * handler: ChatRequestHandler -> ChatParticipant

    [<RequireQualifiedAccess>]
    type LanguageModelChatMessageRole =
        | User = 1
        | Assistant = 2

    /// <summary>
    /// Represents a message in a chat. Can assume different roles, like user or assistant.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatMessage =
        /// <summary>
        /// Utility to create a new user message.
        /// </summary>
        /// <param name="content">
        /// The content of the message.
        /// </param>
        /// <param name="name">
        /// The optional name of a user for the message.
        /// </param>
        static member inline User (content: U2<string, ResizeArray<U3<LanguageModelTextPart, LanguageModelToolResultPart, LanguageModelDataPart>>>, ?name: string): LanguageModelChatMessage =
            emitJsExpr (content, name) $$"""
import { LanguageModelChatMessage } from "vscode";
LanguageModelChatMessage.User($0, $1)"""
        /// <summary>
        /// Utility to create a new assistant message.
        /// </summary>
        /// <param name="content">
        /// The content of the message.
        /// </param>
        /// <param name="name">
        /// The optional name of a user for the message.
        /// </param>
        static member inline Assistant (content: U2<string, ResizeArray<U3<LanguageModelTextPart, LanguageModelToolCallPart, LanguageModelDataPart>>>, ?name: string): LanguageModelChatMessage =
            emitJsExpr (content, name) $$"""
import { LanguageModelChatMessage } from "vscode";
LanguageModelChatMessage.Assistant($0, $1)"""
        /// <summary>
        /// The role of this message.
        /// </summary>
        abstract member role: LanguageModelChatMessageRole with get, set
        /// <summary>
        /// A string or heterogeneous array of things that a message can contain as content. Some parts may be message-type
        /// specific for some models.
        /// </summary>
        abstract member content: ResizeArray<LanguageModelInputPart> with get, set
        /// <summary>
        /// The optional name of a user for this message.
        /// </summary>
        abstract member name: string option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatResponse =
        /// <summary>
        /// An async iterable that is a stream of text and tool-call parts forming the overall response. A
        /// <see href="LanguageModelTextPart">LanguageModelTextPart</see> is part of the assistant's response to be shown to the user. A
        /// <see href="LanguageModelToolCallPart">LanguageModelToolCallPart</see> is a request from the language model to call a tool. The latter will
        /// only be returned if tools were passed in the request via <see href="LanguageModelChatRequestOptions.tools">LanguageModelChatRequestOptions.tools</see>. The
        /// <c>unknown</c>-type is used as a placeholder for future parts, like image data parts.
        ///
        /// *Note* that this stream will error when during data receiving an error occurs. Consumers of the stream should handle
        /// the errors accordingly.
        ///
        /// To cancel the stream, the consumer can <see href="CancellationTokenSource.cancelcancel">CancellationTokenSource.cancelcancel</see> the token that was used to make
        /// the request or break from the for-loop.
        /// </summary>
        /// <example>
        /// <code lang="ts">
        /// try {
        ///   // consume stream
        ///   for await (const chunk of response.stream) {
        ///      if (chunk instanceof LanguageModelTextPart) {
        ///        console.log("TEXT", chunk);
        ///      } else if (chunk instanceof LanguageModelToolCallPart) {
        ///        console.log("TOOL CALL", chunk);
        ///      }
        ///   }
        ///
        /// } catch(e) {
        ///   // stream ended with an error
        ///   console.error(e);
        /// }
        /// </code>
        /// </example>
        abstract member stream: AsyncIterable<U4<LanguageModelTextPart, LanguageModelToolCallPart, LanguageModelDataPart, obj>> with get, set
        /// <summary>
        /// This is equivalent to filtering everything except for text parts from a <see href="LanguageModelChatResponse.stream">LanguageModelChatResponse.stream</see>.
        /// </summary>
        abstract member text: AsyncIterable<string> with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChat =
        /// <summary>
        /// Human-readable name of the language model.
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// Opaque identifier of the language model.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// A well-known identifier of the vendor of the language model. An example is <c>copilot</c>, but
        /// values are defined by extensions contributing chat models and need to be looked up with them.
        /// </summary>
        abstract member vendor: string with get
        /// <summary>
        /// Opaque family-name of the language model. Values might be <c>gpt-3.5-turbo</c>, <c>gpt4</c>, <c>phi2</c>, or <c>llama</c>
        /// but they are defined by extensions contributing languages and subject to change.
        /// </summary>
        abstract member family: string with get
        /// <summary>
        /// Opaque version string of the model. This is defined by the extension contributing the language model
        /// and subject to change.
        /// </summary>
        abstract member version: string with get
        /// <summary>
        /// The maximum number of tokens that can be sent to the model in a single request.
        /// </summary>
        abstract member maxInputTokens: float with get
        /// <summary>
        /// Make a chat request using a language model.
        ///
        /// *Note* that language model use may be subject to access restrictions and user consent. Calling this function
        /// for the first time (for an extension) will show a consent dialog to the user and because of that this function
        /// must _only be called in response to a user action!_ Extensions can use <see href="LanguageModelAccessInformation.canSendRequest">LanguageModelAccessInformation.canSendRequest</see>
        /// to check if they have the necessary permissions to make a request.
        ///
        /// This function will return a rejected promise if making a request to the language model is not
        /// possible. Reasons for this can be:
        ///
        /// - user consent not given, see <see href="LanguageModelError.NoPermissions<c>NoPermissions</c>">LanguageModelError.NoPermissions<c>NoPermissions</c></see>
        /// - model does not exist anymore, see <see href="LanguageModelError.NotFound<c>NotFound</c>">LanguageModelError.NotFound<c>NotFound</c></see>
        /// - quota limits exceeded, see <see href="LanguageModelError.Blocked<c>Blocked</c>">LanguageModelError.Blocked<c>Blocked</c></see>
        /// - other issues in which case extension must check <see href="LanguageModelError.cause"><c>LanguageModelError.cause</c></see>"
        ///
        /// An extension can make use of language model tool calling by passing a set of tools to
        /// <see href="LanguageModelChatRequestOptions.tools">LanguageModelChatRequestOptions.tools</see>. The language model will return a <see href="LanguageModelToolCallPart">LanguageModelToolCallPart</see> and
        /// the extension can invoke the tool and make another request with the result.
        /// </summary>
        /// <param name="messages">
        /// An array of message instances.
        /// </param>
        /// <param name="options">
        /// Options that control the request.
        /// </param>
        /// <param name="token">
        /// A cancellation token which controls the request. See <see href="CancellationTokenSource">CancellationTokenSource</see> for how to create one.
        /// </param>
        /// <returns>
        /// A thenable that resolves to a <see href="LanguageModelChatResponse">LanguageModelChatResponse</see>. The promise will reject when the request couldn't be made.
        /// </returns>
        abstract member sendRequest: messages: ResizeArray<LanguageModelChatMessage> * ?options: LanguageModelChatRequestOptions * ?token: CancellationToken -> Thenable<LanguageModelChatResponse>
        /// <summary>
        /// Count the number of tokens in a message using the model specific tokenizer-logic.
        /// </summary>
        /// <param name="text">
        /// A string or a message instance.
        /// </param>
        /// <param name="token">
        /// Optional cancellation token.  See <see href="CancellationTokenSource">CancellationTokenSource</see> for how to create one.
        /// </param>
        /// <returns>
        /// A thenable that resolves to the number of tokens.
        /// </returns>
        abstract member countTokens: text: U2<string, LanguageModelChatMessage> * ?token: CancellationToken -> Thenable<float>

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatSelector =
        /// <summary>
        /// A vendor of language models.
        /// </summary>
        abstract member vendor: string option with get, set
        /// <summary>
        /// A family of language models.
        /// </summary>
        abstract member family: string option with get, set
        /// <summary>
        /// The version of a language model.
        /// </summary>
        abstract member version: string option with get, set
        /// <summary>
        /// The identifier of a language model.
        /// </summary>
        abstract member id: string option with get, set

    /// <summary>
    /// An error type for language model specific errors.
    ///
    /// Consumers of language models should check the code property to determine specific
    /// failure causes, like <c>if(someError.code === vscode.LanguageModelError.NotFound.name) {...}</c>
    /// for the case of referring to an unknown language model. For unspecified errors the <c>cause</c>-property
    /// will contain the actual error.
    /// </summary>
    [<AllowNullLiteral>]
    [<AbstractClass>]
    type LanguageModelError =
        inherit Exception
        /// <summary>
        /// The requestor does not have permissions to use this
        /// language model
        /// </summary>
        static member inline NoPermissions (?message: string): LanguageModelError =
            emitJsExpr (message) $$"""
import { LanguageModelError } from "vscode";
LanguageModelError.NoPermissions($0)"""
        /// <summary>
        /// The requestor is blocked from using this language model.
        /// </summary>
        static member inline Blocked (?message: string): LanguageModelError =
            emitJsExpr (message) $$"""
import { LanguageModelError } from "vscode";
LanguageModelError.Blocked($0)"""
        /// <summary>
        /// The language model does not exist.
        /// </summary>
        static member inline NotFound (?message: string): LanguageModelError =
            emitJsExpr (message) $$"""
import { LanguageModelError } from "vscode";
LanguageModelError.NotFound($0)"""
        /// <summary>
        /// A code that identifies this error.
        ///
        /// Possible values are names of errors, like {@linkcode LanguageModelError.NotFoundNotFound},
        /// or <c>Unknown</c> for unspecified errors from the language model itself. In the latter case the
        /// <c>cause</c>-property will contain the actual error.
        /// </summary>
        abstract member code: string with get

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatRequestOptions =
        /// <summary>
        /// A human-readable message that explains why access to a language model is needed and what feature is enabled by it.
        /// </summary>
        abstract member justification: string option with get, set
        /// <summary>
        /// A set of options that control the behavior of the language model. These options are specific to the language model
        /// and need to be looked up in the respective documentation.
        /// </summary>
        abstract member modelOptions: LanguageModelChatRequestOptions.modelOptions option with get, set
        /// <summary>
        /// An optional list of tools that are available to the language model. These could be registered tools available via
        /// <see href="lm.tools">lm.tools</see>, or private tools that are just implemented within the calling extension.
        ///
        /// If the LLM requests to call one of these tools, it will return a <see href="LanguageModelToolCallPart">LanguageModelToolCallPart</see> in
        /// <see href="LanguageModelChatResponse.stream">LanguageModelChatResponse.stream</see>. It's the caller's responsibility to invoke the tool. If it's a tool
        /// registered in <see href="lm.tools">lm.tools</see>, that means calling <see href="lm.invokeTool">lm.invokeTool</see>.
        ///
        /// Then, the tool result can be provided to the LLM by creating an Assistant-type <see href="LanguageModelChatMessage">LanguageModelChatMessage</see> with a
        /// <see href="LanguageModelToolCallPart">LanguageModelToolCallPart</see>, followed by a User-type message with a <see href="LanguageModelToolResultPart">LanguageModelToolResultPart</see>.
        /// </summary>
        abstract member tools: ResizeArray<LanguageModelChatTool> option with get, set
        /// <summary>
        /// The tool-selecting mode to use. <see href="LanguageModelChatToolMode.Auto">LanguageModelChatToolMode.Auto</see> by default.
        /// </summary>
        abstract member toolMode: LanguageModelChatToolMode option with get, set

    /// <summary>
    /// McpStdioServerDefinition represents an MCP server available by running
    /// a local process and operating on its stdin and stdout streams. The process
    /// will be spawned as a child process of the extension host and by default
    /// will not run in a shell environment.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type McpStdioServerDefinition =
        /// <summary>
        /// The human-readable name of the server.
        /// </summary>
        abstract member label: string with get
        /// <summary>
        /// The working directory used to start the server.
        /// </summary>
        abstract member cwd: Uri option with get, set
        /// <summary>
        /// The command used to start the server. Node.js-based servers may use
        /// <c>process.execPath</c> to use the editor's version of Node.js to run the script.
        /// </summary>
        abstract member command: string with get, set
        /// <summary>
        /// Additional command-line arguments passed to the server.
        /// </summary>
        abstract member args: ResizeArray<string> with get, set
        /// <summary>
        /// Optional additional environment information for the server. Variables
        /// in this environment will overwrite or remove (if null) the default
        /// environment variables of the editor's extension host.
        /// </summary>
        abstract member env: McpStdioServerDefinition.env with get, set
        /// <summary>
        /// Optional version identification for the server. If this changes, the
        /// editor will indicate that tools have changed and prompt to refresh them.
        /// </summary>
        abstract member version: string option with get, set

    /// <summary>
    /// McpHttpServerDefinition represents an MCP server available using the
    /// Streamable HTTP transport.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type McpHttpServerDefinition =
        /// <summary>
        /// The human-readable name of the server.
        /// </summary>
        abstract member label: string with get
        /// <summary>
        /// The URI of the server. The editor will make a POST request to this URI
        /// to begin each session.
        /// </summary>
        abstract member uri: Uri with get, set
        /// <summary>
        /// Optional additional heads included with each request to the server.
        /// </summary>
        abstract member headers: McpHttpServerDefinition.headers with get, set
        /// <summary>
        /// Optional version identification for the server. If this changes, the
        /// editor will indicate that tools have changed and prompt to refresh them.
        /// </summary>
        abstract member version: string option with get, set

    /// <summary>
    /// Definitions that describe different types of Model Context Protocol servers,
    /// which can be returned from the <see href="McpServerDefinitionProvider">McpServerDefinitionProvider</see>.
    /// </summary>
    type McpServerDefinition =
        U2<McpStdioServerDefinition, McpHttpServerDefinition>

    [<AllowNullLiteral>]
    [<Interface>]
    type McpServerDefinitionProvider =
        /// <summary>
        /// Optional event fired to signal that the set of available servers has changed.
        /// </summary>
        abstract member onDidChangeMcpServerDefinitions: Event<unit> option with get
        /// <summary>
        /// Provides available MCP servers. The editor will call this method eagerly
        /// to ensure the availability of servers for the language model, and so
        /// extensions should not take actions which would require user
        /// interaction, such as authentication.
        /// </summary>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// An array of MCP available MCP servers
        /// </returns>
        abstract member provideMcpServerDefinitions: token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// This function will be called when the editor needs to start a MCP server.
        /// At this point, the extension may take any actions which may require user
        /// interaction, such as authentication. Any non-<c>readonly</c> property of the
        /// server may be modified, and the extension should return the resolved server.
        ///
        /// The extension may return undefined to indicate that the server
        /// should not be started, or throw an error. If there is a pending tool
        /// call, the editor will cancel it and return an error message to the
        /// language model.
        /// </summary>
        /// <param name="server">
        /// The MCP server to resolve
        /// </param>
        /// <param name="token">
        /// A cancellation token.
        /// </param>
        /// <returns>
        /// The resolved server or thenable that resolves to such. This may
        /// be the given <c>server</c> definition with non-readonly properties filled in.
        /// </returns>
        abstract member resolveMcpServerDefinition: server: 'T * token: CancellationToken -> ProviderResult<'T>

    [<AllowNullLiteral>]
    [<Interface>]
    type ProvideLanguageModelChatResponseOptions =
        /// <summary>
        /// A set of options that control the behavior of the language model. These options are specific to the language model.
        /// </summary>
        abstract member modelOptions: ProvideLanguageModelChatResponseOptions.modelOptions option with get
        /// <summary>
        /// An optional list of tools that are available to the language model. These could be registered tools available via
        /// <see href="lm.tools">lm.tools</see>, or private tools that are just implemented within the calling extension.
        ///
        /// If the LLM requests to call one of these tools, it will return a <see href="LanguageModelToolCallPart">LanguageModelToolCallPart</see> in
        /// <see href="LanguageModelChatResponse.stream">LanguageModelChatResponse.stream</see>. It's the caller's responsibility to invoke the tool. If it's a tool
        /// registered in <see href="lm.tools">lm.tools</see>, that means calling <see href="lm.invokeTool">lm.invokeTool</see>.
        ///
        /// Then, the tool result can be provided to the LLM by creating an Assistant-type <see href="LanguageModelChatMessage">LanguageModelChatMessage</see> with a
        /// <see href="LanguageModelToolCallPart">LanguageModelToolCallPart</see>, followed by a User-type message with a <see href="LanguageModelToolResultPart">LanguageModelToolResultPart</see>.
        /// </summary>
        abstract member tools: ReadonlyArray<LanguageModelChatTool> option with get
        /// <summary>
        /// The tool-selecting mode to use. The provider must implement respecting this.
        /// </summary>
        abstract member toolMode: LanguageModelChatToolMode with get

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatInformation =
        /// <summary>
        /// Unique identifier for the language model. Must be unique per provider, but not required to be globally unique.
        /// </summary>
        abstract member id: string with get
        /// <summary>
        /// Human-readable name of the language model.
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// Opaque family-name of the language model. Values might be <c>gpt-3.5-turbo</c>, <c>gpt4</c>, <c>phi2</c>, or <c>llama</c>
        /// </summary>
        abstract member family: string with get
        /// <summary>
        /// The tooltip to render when hovering the model. Used to provide more information about the model.
        /// </summary>
        abstract member tooltip: string option with get
        /// <summary>
        /// An optional, human-readable string which will be rendered alongside the model.
        /// Useful for distinguishing models of the same name in the UI.
        /// </summary>
        abstract member detail: string option with get
        /// <summary>
        /// Opaque version string of the model.
        /// This is used as a lookup value in {@linkcode LanguageModelChatSelector.version}
        /// An example is how GPT 4o has multiple versions like 2024-11-20 and 2024-08-06
        /// </summary>
        abstract member version: string with get
        /// <summary>
        /// The maximum number of tokens the model can accept as input.
        /// </summary>
        abstract member maxInputTokens: float with get
        /// <summary>
        /// The maximum number of tokens the model is capable of producing.
        /// </summary>
        abstract member maxOutputTokens: float with get
        /// <summary>
        /// Various features that the model supports such as tool calling or image input.
        /// </summary>
        abstract member capabilities: LanguageModelChatCapabilities with get

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatCapabilities =
        /// <summary>
        /// Whether image input is supported by the model.
        /// Common supported images are jpg and png, but each model will vary in supported mimetypes.
        /// </summary>
        abstract member imageInput: bool option with get
        /// <summary>
        /// Whether tool calling is supported by the model.
        /// If a number is provided, that is the maximum number of tools that can be provided in a request to the model.
        /// </summary>
        abstract member toolCalling: U2<bool, float> option with get

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatRequestMessage =
        /// <summary>
        /// The role of this message.
        /// </summary>
        abstract member role: LanguageModelChatMessageRole with get
        /// <summary>
        /// A heterogeneous array of things that a message can contain as content. Some parts may be message-type
        /// specific for some models.
        /// </summary>
        abstract member content: ReadonlyArray<U2<LanguageModelInputPart, obj>> with get
        /// <summary>
        /// The optional name of a user for this message.
        /// </summary>
        abstract member name: string option with get

    /// <summary>
    /// The various message types which a {@linkcode LanguageModelChatProvider} can emit in the chat response stream
    /// </summary>
    type LanguageModelResponsePart =
        U4<LanguageModelTextPart, LanguageModelToolResultPart, LanguageModelToolCallPart, LanguageModelDataPart>

    /// <summary>
    /// The various message types which can be sent via {@linkcode LanguageModelChat.sendRequest} and processed by a {@linkcode LanguageModelChatProvider}
    /// </summary>
    type LanguageModelInputPart =
        U4<LanguageModelTextPart, LanguageModelToolResultPart, LanguageModelToolCallPart, LanguageModelDataPart>

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatProvider<'T when 'T :> LanguageModelChatInformation> =
        /// <summary>
        /// An optional event fired when the available set of language models changes.
        /// </summary>
        abstract member onDidChangeLanguageModelChatInformation: Event<unit> option with get
        /// <summary>
        /// Get the list of available language models provided by this provider
        /// </summary>
        /// <param name="options">
        /// Options which specify the calling context of this function
        /// </param>
        /// <param name="token">
        /// A cancellation token
        /// </param>
        /// <returns>
        /// The list of available language models
        /// </returns>
        abstract member provideLanguageModelChatInformation: options: PrepareLanguageModelChatModelOptions * token: CancellationToken -> ProviderResult<ResizeArray<'T>>
        /// <summary>
        /// Returns the response for a chat request, passing the results to the progress callback.
        /// The {@linkcode LanguageModelChatProvider} must emit the response parts to the progress callback as they are received from the language model.
        /// </summary>
        /// <param name="model">
        /// The language model to use
        /// </param>
        /// <param name="messages">
        /// The messages to include in the request
        /// </param>
        /// <param name="options">
        /// Options for the request
        /// </param>
        /// <param name="progress">
        /// The progress to emit the streamed response chunks to
        /// </param>
        /// <param name="token">
        /// A cancellation token
        /// </param>
        /// <returns>
        /// A promise that resolves when the response is complete. Results are actually passed to the progress callback.
        /// </returns>
        abstract member provideLanguageModelChatResponse: model: 'T * messages: ReadonlyArray<LanguageModelChatRequestMessage> * options: ProvideLanguageModelChatResponseOptions * progress: Progress<LanguageModelResponsePart> * token: CancellationToken -> Thenable<unit>
        /// <summary>
        /// Returns the number of tokens for a given text using the model-specific tokenizer logic
        /// </summary>
        /// <param name="model">
        /// The language model to use
        /// </param>
        /// <param name="text">
        /// The text to count tokens for
        /// </param>
        /// <param name="token">
        /// A cancellation token
        /// </param>
        /// <returns>
        /// The number of tokens
        /// </returns>
        abstract member provideTokenCount: model: 'T * text: U2<string, LanguageModelChatRequestMessage> * token: CancellationToken -> Thenable<float>

    [<AllowNullLiteral>]
    [<Interface>]
    type PrepareLanguageModelChatModelOptions =
        /// <summary>
        /// Whether or not the user should be prompted via some UI flow, or if models should be attempted to be resolved silently.
        /// If silent is true, all models may not be resolved due to lack of info such as API keys.
        /// </summary>
        abstract member silent: bool with get

    module lm =

        [<AbstractClass>]
        [<Erase>]
        type Exports =
            /// <summary>
            /// An event that is fired when the set of available chat models changes.
            /// </summary>
            [<Emit("$0.onDidChangeChatModels")>]
            abstract member onDidChangeChatModels: Event<unit>
            /// <summary>
            /// Select chat models by a <see href="LanguageModelChatSelectorselector">LanguageModelChatSelectorselector</see>. This can yield multiple or no chat models and
            /// extensions must handle these cases, esp. when no chat model exists, gracefully.
            ///
            /// <code lang="ts">
            /// const models = await vscode.lm.selectChatModels({ family: 'gpt-3.5-turbo' });
            /// if (models.length > 0) {
            /// 	const [first] = models;
            /// 	const response = await first.sendRequest(...)
            /// 	// ...
            /// } else {
            /// 	// NO chat models available
            /// }
            /// </code>
            ///
            /// A selector can be written to broadly match all models of a given vendor or family, or it can narrowly select one model by ID.
            /// Keep in mind that the available set of models will change over time, but also that prompts may perform differently in
            /// different models.
            ///
            /// *Note* that extensions can hold on to the results returned by this function and use them later. However, when the
            /// <see href="onDidChangeChatModels">onDidChangeChatModels</see>-event is fired the list of chat models might have changed and extensions should re-query.
            /// </summary>
            /// <param name="selector">
            /// A chat model selector. When omitted all chat models are returned.
            /// </param>
            /// <returns>
            /// An array of chat models, can be empty!
            /// </returns>
            [<Emit("$0.selectChatModels($1...)")>]
            abstract member selectChatModels: ?selector: LanguageModelChatSelector -> Thenable<ResizeArray<LanguageModelChat>>
            /// <summary>
            /// Register a LanguageModelTool. The tool must also be registered in the package.json <c>languageModelTools</c> contribution
            /// point. A registered tool is available in the <see href="lm.tools">lm.tools</see> list for any extension to see. But in order for it to
            /// be seen by a language model, it must be passed in the list of available tools in <see href="LanguageModelChatRequestOptions.tools">LanguageModelChatRequestOptions.tools</see>.
            /// </summary>
            /// <returns>
            /// A <see href="Disposable">Disposable</see> that unregisters the tool when disposed.
            /// </returns>
            [<Emit("$0.registerTool($1...)")>]
            abstract member registerTool<'T>: name: string * tool: LanguageModelTool<'T> -> Disposable
            /// <summary>
            /// A list of all available tools that were registered by all extensions using <see href="lm.registerTool">lm.registerTool</see>. They can be called
            /// with <see href="lm.invokeTool">lm.invokeTool</see> with input that match their declared <c>inputSchema</c>.
            /// </summary>
            [<Emit("$0.tools")>]
            abstract member tools: ReadonlyArray<LanguageModelToolInformation>
            /// <summary>
            /// Invoke a tool listed in <see href="lm.tools">lm.tools</see> by name with the given input. The input will be validated against
            /// the schema declared by the tool
            ///
            /// A tool can be invoked by a chat participant, in the context of handling a chat request, or globally by any extension in
            /// any custom flow.
            ///
            /// In the former case, the caller shall pass the
            /// <see href="LanguageModelToolInvocationOptions.toolInvocationTokentoolInvocationToken">LanguageModelToolInvocationOptions.toolInvocationTokentoolInvocationToken</see>, which comes from a
            /// <see href="ChatRequest.toolInvocationTokenchat">request</see>". This makes sure the chat UI shows the tool invocation for the
            /// correct conversation.
            ///
            /// A tool <see href="LanguageModelToolResultresult">LanguageModelToolResultresult</see> is an array of <see href="LanguageModelTextParttext-">LanguageModelTextParttext-</see> and
            /// <see href="LanguageModelPromptTsxPartprompt-tsx">LanguageModelPromptTsxPartprompt-tsx</see>-parts. If the tool caller is using <c>@vscode/prompt-tsx</c>, it can
            /// incorporate the response parts into its prompt using a <c>ToolResult</c>. If not, the parts can be passed along to the
            /// <see href="LanguageModelChat">LanguageModelChat</see> via a user message with a <see href="LanguageModelToolResultPart">LanguageModelToolResultPart</see>.
            ///
            /// If a chat participant wants to preserve tool results for requests across multiple turns, it can store tool results in
            /// the <see href="ChatResult.metadata">ChatResult.metadata</see> returned from the handler and retrieve them on the next turn from
            /// <see href="ChatResponseTurn.result">ChatResponseTurn.result</see>.
            /// </summary>
            /// <param name="name">
            /// The name of the tool to call.
            /// </param>
            /// <param name="options">
            /// The options to use when invoking the tool.
            /// </param>
            /// <param name="token">
            /// A cancellation token. See <see href="CancellationTokenSource">CancellationTokenSource</see> for how to create one.
            /// </param>
            /// <returns>
            /// The result of the tool invocation.
            /// </returns>
            [<Emit("$0.invokeTool($1...)")>]
            abstract member invokeTool: name: string * options: LanguageModelToolInvocationOptions<obj> * ?token: CancellationToken -> Thenable<LanguageModelToolResult>
            /// <summary>
            /// Registers a provider that publishes Model Context Protocol servers for the editor to
            /// consume. This allows MCP servers to be dynamically provided to the editor in
            /// addition to those the user creates in their configuration files.
            ///
            /// Before calling this method, extensions must register the <c>contributes.mcpServerDefinitionProviders</c>
            /// extension point with the corresponding <see href="id">id</see>, for example:
            ///
            /// <code lang="js">
            /// 	"contributes": {
            /// 		"mcpServerDefinitionProviders": [
            /// 			{
            /// 				"id": "cool-cloud-registry.mcp-servers",
            /// 				"label": "Cool Cloud Registry",
            /// 			}
            /// 		]
            /// 	}
            /// </code>
            ///
            /// When a new McpServerDefinitionProvider is available, the editor will, by default,
            /// automatically invoke it to discover new servers and tools when a chat message is
            /// submitted. To enable this flow, extensions should call
            /// <c>registerMcpServerDefinitionProvider</c> during activation.
            /// </summary>
            /// <param name="id">
            /// The ID of the provider, which is unique to the extension.
            /// </param>
            /// <param name="provider">
            /// The provider to register
            /// </param>
            /// <returns>
            /// A disposable that unregisters the provider when disposed.
            /// </returns>
            [<Emit("$0.registerMcpServerDefinitionProvider($1...)")>]
            abstract member registerMcpServerDefinitionProvider: id: string * provider: McpServerDefinitionProvider -> Disposable
            /// <summary>
            /// Registers a {@linkcode LanguageModelChatProvider}
            /// Note: You must also define the language model chat provider via the <c>languageModelChatProviders</c> contribution point in package.json
            /// </summary>
            /// <param name="vendor">
            /// The vendor for this provider. Must be globally unique. An example is <c>copilot</c> or <c>openai</c>.
            /// </param>
            /// <param name="provider">
            /// The provider to register
            /// </param>
            /// <returns>
            /// A disposable that unregisters the provider when disposed
            /// </returns>
            [<Emit("$0.registerLanguageModelChatProvider($1...)")>]
            abstract member registerLanguageModelChatProvider: vendor: string * provider: LanguageModelChatProvider -> Disposable

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelAccessInformation =
        /// <summary>
        /// An event that fires when access information changes.
        /// </summary>
        abstract member onDidChange: Event<unit> with get
        /// <summary>
        /// Checks if a request can be made to a language model.
        ///
        /// *Note* that calling this function will not trigger a consent UI but just checks for a persisted state.
        /// </summary>
        /// <param name="chat">
        /// A language model chat object.
        /// </param>
        /// <returns>
        /// <c>true</c> if a request can be made, <c>false</c> if not, <c>undefined</c> if the language
        /// model does not exist or consent hasn't been asked for.
        /// </returns>
        abstract member canSendRequest: chat: LanguageModelChat -> bool option

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelChatTool =
        /// <summary>
        /// The name of the tool.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The description of the tool.
        /// </summary>
        abstract member description: string with get, set
        /// <summary>
        /// A JSON schema for the input this tool accepts.
        /// </summary>
        abstract member inputSchema: obj option with get, set

    [<RequireQualifiedAccess>]
    type LanguageModelChatToolMode =
        | Auto = 1
        | Required = 2

    /// <summary>
    /// A language model response part indicating a tool call, returned from a <see href="LanguageModelChatResponse">LanguageModelChatResponse</see>, and also can be
    /// included as a content part on a <see href="LanguageModelChatMessage">LanguageModelChatMessage</see>, to represent a previous tool call in a chat request.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelToolCallPart =
        /// <summary>
        /// The ID of the tool call. This is a unique identifier for the tool call within the chat request.
        /// </summary>
        abstract member callId: string with get, set
        /// <summary>
        /// The name of the tool to call.
        /// </summary>
        abstract member name: string with get, set
        /// <summary>
        /// The input with which to call the tool.
        /// </summary>
        abstract member input: obj with get, set

    /// <summary>
    /// The result of a tool call. This is the counterpart of a <see href="LanguageModelToolCallParttool">call</see>" and
    /// it can only be included in the content of a User message
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelToolResultPart =
        /// <summary>
        /// The ID of the tool call.
        ///
        /// *Note* that this should match the <see href="LanguageModelToolCallPart.callIdcallId">LanguageModelToolCallPart.callIdcallId</see> of a tool call part.
        /// </summary>
        abstract member callId: string with get, set
        /// <summary>
        /// The value of the tool result.
        /// </summary>
        abstract member content: ResizeArray<U4<LanguageModelTextPart, LanguageModelPromptTsxPart, LanguageModelDataPart, obj>> with get, set

    /// <summary>
    /// A language model response part containing a piece of text, returned from a <see href="LanguageModelChatResponse">LanguageModelChatResponse</see>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelTextPart =
        /// <summary>
        /// The text content of the part.
        /// </summary>
        abstract member value: string with get, set

    /// <summary>
    /// A language model response part containing a PromptElementJSON from <c>@vscode/prompt-tsx</c>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelPromptTsxPart =
        /// <summary>
        /// The value of the part.
        /// </summary>
        abstract member value: obj with get, set

    /// <summary>
    /// A result returned from a tool invocation. If using <c>@vscode/prompt-tsx</c>, this result may be rendered using a <c>ToolResult</c>.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelToolResult =
        /// <summary>
        /// A list of tool result content parts. Includes <c>unknown</c> because this list may be extended with new content types in
        /// the future.
        /// </summary>
        abstract member content: ResizeArray<U4<LanguageModelTextPart, LanguageModelPromptTsxPart, LanguageModelDataPart, obj>> with get, set

    /// <summary>
    /// A language model response part containing arbitrary data. Can be used in <see href="LanguageModelChatResponseresponses">LanguageModelChatResponseresponses</see>,
    /// <see href="LanguageModelChatMessagechat">messages</see>", <see href="LanguageModelToolResulttool">results</see>", and other language model interactions.
    /// </summary>
    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelDataPart =
        /// <summary>
        /// Create a new {@linkcode LanguageModelDataPart} for an image.
        /// </summary>
        /// <param name="data">
        /// Binary image data
        /// </param>
        /// <param name="mime">
        /// The MIME type of the image. Common values are <c>image/png</c> and <c>image/jpeg</c>.
        /// </param>
        static member inline image (data: JS.Uint8Array, mime: string): LanguageModelDataPart =
            emitJsExpr (data, mime) $$"""
import { LanguageModelDataPart } from "vscode";
LanguageModelDataPart.image($0, $1)"""
        /// <summary>
        /// Create a new {@linkcode LanguageModelDataPart} for a json.
        ///
        /// *Note* that this function is not expecting "stringified JSON" but
        /// an object that can be stringified. This function will throw an error
        /// when the passed value cannot be JSON-stringified.
        /// </summary>
        /// <param name="value">
        /// A JSON-stringifyable value.
        /// </param>
        /// <param name="mime">
        /// Optional MIME type, defaults to <c>application/json</c>
        /// </param>
        static member inline json (value: obj, ?mime: string): LanguageModelDataPart =
            emitJsExpr (value, mime) $$"""
import { LanguageModelDataPart } from "vscode";
LanguageModelDataPart.json($0, $1)"""
        /// <summary>
        /// Create a new {@linkcode LanguageModelDataPart} for text.
        ///
        /// *Note* that an UTF-8 encoder is used to create bytes for the string.
        /// </summary>
        /// <param name="value">
        /// Text data
        /// </param>
        /// <param name="mime">
        /// The MIME type if any. Common values are <c>text/plain</c> and <c>text/markdown</c>.
        /// </param>
        static member inline text (value: string, ?mime: string): LanguageModelDataPart =
            emitJsExpr (value, mime) $$"""
import { LanguageModelDataPart } from "vscode";
LanguageModelDataPart.text($0, $1)"""
        /// <summary>
        /// The mime type which determines how the data property is interpreted.
        /// </summary>
        abstract member mimeType: string with get, set
        /// <summary>
        /// The byte data for this part.
        /// </summary>
        abstract member data: JS.Uint8Array with get, set

    /// <summary>
    /// A token that can be passed to <see href="lm.invokeTool">lm.invokeTool</see> when invoking a tool inside the context of handling a chat request.
    /// </summary>
    type ChatParticipantToolToken =
        obj

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelToolInvocationOptions<'T> =
        /// <summary>
        /// An opaque object that ties a tool invocation to a chat request from a <see href="ChatParticipantchat">participant</see>".
        ///
        /// The _only_ way to get a valid tool invocation token is using the provided <see href="ChatRequest.toolInvocationTokentoolInvocationToken">ChatRequest.toolInvocationTokentoolInvocationToken</see>
        /// from a chat request. In that case, a progress bar will be automatically shown for the tool invocation in the chat response view, and if
        /// the tool requires user confirmation, it will show up inline in the chat view.
        ///
        /// If the tool is being invoked outside of a chat request, <c>undefined</c> should be passed instead, and no special UI except for
        /// confirmations will be shown.
        ///
        /// *Note* that a tool that invokes another tool during its invocation, can pass along the <c>toolInvocationToken</c> that it received.
        /// </summary>
        abstract member toolInvocationToken: ChatParticipantToolToken option with get, set
        /// <summary>
        /// The input with which to invoke the tool. The input must match the schema defined in
        /// <see href="LanguageModelToolInformation.inputSchema">LanguageModelToolInformation.inputSchema</see>
        /// </summary>
        abstract member input: 'T with get, set
        /// <summary>
        /// Options to hint at how many tokens the tool should return in its response, and enable the tool to count tokens
        /// accurately.
        /// </summary>
        abstract member tokenizationOptions: LanguageModelToolTokenizationOptions option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelToolTokenizationOptions =
        /// <summary>
        /// If known, the maximum number of tokens the tool should emit in its result.
        /// </summary>
        abstract member tokenBudget: float with get, set
        /// <summary>
        /// Count the number of tokens in a message using the model specific tokenizer-logic.
        /// </summary>
        /// <param name="text">
        /// A string.
        /// </param>
        /// <param name="token">
        /// Optional cancellation token.  See <see href="CancellationTokenSource">CancellationTokenSource</see> for how to create one.
        /// </param>
        /// <returns>
        /// A thenable that resolves to the number of tokens.
        /// </returns>
        abstract member countTokens: text: string * ?token: CancellationToken -> Thenable<float>

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelToolInformation =
        /// <summary>
        /// A unique name for the tool.
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// A description of this tool that may be passed to a language model.
        /// </summary>
        abstract member description: string with get
        /// <summary>
        /// A JSON schema for the input this tool accepts.
        /// </summary>
        abstract member inputSchema: obj option with get
        /// <summary>
        /// A set of tags, declared by the tool, that roughly describe the tool's capabilities. A tool user may use these to filter
        /// the set of tools to just ones that are relevant for the task at hand.
        /// </summary>
        abstract member tags: ReadonlyArray<string> with get

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelToolInvocationPrepareOptions<'T> =
        /// <summary>
        /// The input that the tool is being invoked with.
        /// </summary>
        abstract member input: 'T with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelTool<'T> =
        /// <summary>
        /// Invoke the tool with the given input and return a result.
        ///
        /// The provided <see href="LanguageModelToolInvocationOptions.input">LanguageModelToolInvocationOptions.input</see> has been validated against the declared schema.
        /// </summary>
        abstract member invoke: options: LanguageModelToolInvocationOptions<'T> * token: CancellationToken -> ProviderResult<LanguageModelToolResult>
        /// <summary>
        /// Called once before a tool is invoked. It's recommended to implement this to customize the progress message that appears
        /// while the tool is running, and to provide a more useful message with context from the invocation input. Can also
        /// signal that a tool needs user confirmation before running, if appropriate.
        ///
        /// * *Note 1:* Must be free of side-effects.
        /// * *Note 2:* A call to <c>prepareInvocation</c> is not necessarily followed by a call to <c>invoke</c>.
        /// </summary>
        abstract member prepareInvocation: options: LanguageModelToolInvocationPrepareOptions<'T> * token: CancellationToken -> ProviderResult<PreparedToolInvocation>

    [<AllowNullLiteral>]
    [<Interface>]
    type LanguageModelToolConfirmationMessages =
        /// <summary>
        /// The title of the confirmation message.
        /// </summary>
        abstract member title: string with get, set
        /// <summary>
        /// The body of the confirmation message.
        /// </summary>
        abstract member message: U2<string, MarkdownString> with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type PreparedToolInvocation =
        /// <summary>
        /// A customized progress message to show while the tool runs.
        /// </summary>
        abstract member invocationMessage: U2<string, MarkdownString> option with get, set
        /// <summary>
        /// The presence of this property indicates that the user should be asked to confirm before running the tool. The user
        /// should be asked for confirmation for any tool that has a side-effect or may potentially be dangerous.
        /// </summary>
        abstract member confirmationMessages: LanguageModelToolConfirmationMessages option with get, set

    [<AllowNullLiteral>]
    [<Interface>]
    type ChatLanguageModelToolReference =
        /// <summary>
        /// The tool name. Refers to a tool listed in <see href="lm.tools">lm.tools</see>.
        /// </summary>
        abstract member name: string with get
        /// <summary>
        /// The start and end index of the reference in the <see href="ChatRequest.promptprompt">ChatRequest.promptprompt</see>. When undefined, the reference was
        /// not part of the prompt text.
        ///
        /// *Note* that the indices take the leading <c>#</c>-character into account which means they can be used to modify the prompt
        /// as-is.
        /// </summary>
        abstract member range: float * float option with get

    type CodeActionProvider =
        CodeActionProvider<CodeAction>

    type CodeLensProvider =
        CodeLensProvider<CodeLens>

    type WorkspaceSymbolProvider =
        WorkspaceSymbolProvider<SymbolInformation>

    type CompletionItemProvider =
        CompletionItemProvider<CompletionItem>

    type DocumentLinkProvider =
        DocumentLinkProvider<DocumentLink>

    type InlayHintsProvider =
        InlayHintsProvider<InlayHint>

    type DocumentDropEditProvider =
        DocumentDropEditProvider<DocumentDropEdit>

    type DocumentPasteEditProvider =
        DocumentPasteEditProvider<DocumentPasteEdit>

    type TerminalLinkProvider =
        TerminalLinkProvider<TerminalLink>

    type TaskProvider =
        TaskProvider<Task>

    type WebviewPanelSerializer =
        WebviewPanelSerializer<obj>

    type WebviewViewResolveContext =
        WebviewViewResolveContext<obj>

    type CustomDocumentEditEvent =
        CustomDocumentEditEvent<CustomDocument>

    type CustomDocumentContentChangeEvent =
        CustomDocumentContentChangeEvent<CustomDocument>

    type CustomReadonlyEditorProvider =
        CustomReadonlyEditorProvider<CustomDocument>

    type CustomEditorProvider =
        CustomEditorProvider<CustomDocument>

    type LanguageModelChatProvider =
        LanguageModelChatProvider<LanguageModelChatInformation>

    module Position =

        module translate =

            [<Global>]
            [<AllowNullLiteral>]
            type change
                [<ParamObject; Emit("$0")>]
                (
                    ?lineDelta: float,
                    ?characterDelta: float
                ) =

                member val lineDelta : float option = nativeOnly with get, set
                member val characterDelta : float option = nativeOnly with get, set

        module ``with`` =

            [<Global>]
            [<AllowNullLiteral>]
            type change
                [<ParamObject; Emit("$0")>]
                (
                    ?line: float,
                    ?character: float
                ) =

                member val line : float option = nativeOnly with get, set
                member val character : float option = nativeOnly with get, set

    module Range =

        module ``with`` =

            [<Global>]
            [<AllowNullLiteral>]
            type change
                [<ParamObject; Emit("$0")>]
                (
                    ?start: Position,
                    ?``end``: Position
                ) =

                member val start : Position option = nativeOnly with get, set
                member val ``end`` : Position option = nativeOnly with get, set

    module IconPath =

        module U3 =

            [<Global>]
            [<AllowNullLiteral>]
            type Case2
                [<ParamObject; Emit("$0")>]
                (
                    light: Uri,
                    dark: Uri
                ) =

                member val light : Uri = nativeOnly with get, set
                member val dark : Uri = nativeOnly with get, set

    module TextEditor =

        module edit =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    undoStopBefore: bool,
                    undoStopAfter: bool
                ) =

                member val undoStopBefore : bool = nativeOnly with get
                member val undoStopAfter : bool = nativeOnly with get

        module insertSnippet =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    undoStopBefore: bool,
                    undoStopAfter: bool,
                    ?keepWhitespace: bool
                ) =

                member val undoStopBefore : bool = nativeOnly with get
                member val undoStopAfter : bool = nativeOnly with get
                member val keepWhitespace : bool option = nativeOnly with get

    module Uri =

        module from =

            [<Global>]
            [<AllowNullLiteral>]
            type components
                [<ParamObject; Emit("$0")>]
                (
                    scheme: string,
                    ?authority: string,
                    ?path: string,
                    ?query: string,
                    ?fragment: string
                ) =

                member val scheme : string = nativeOnly with get
                member val authority : string option = nativeOnly with get
                member val path : string option = nativeOnly with get
                member val query : string option = nativeOnly with get
                member val fragment : string option = nativeOnly with get

        module ``with`` =

            [<Global>]
            [<AllowNullLiteral>]
            type change
                [<ParamObject; Emit("$0")>]
                (
                    ?scheme: string,
                    ?authority: string,
                    ?path: string,
                    ?query: string,
                    ?fragment: string
                ) =

                member val scheme : string option = nativeOnly with get, set
                member val authority : string option = nativeOnly with get, set
                member val path : string option = nativeOnly with get, set
                member val query : string option = nativeOnly with get, set
                member val fragment : string option = nativeOnly with get, set

    module Disposable =

        module from =

            [<Global>]
            [<AllowNullLiteral>]
            type disposableLikes
                [<ParamObject; Emit("$0")>]
                (
                    dispose: (unit -> obj)
                ) =

                member val dispose : (unit -> obj) = nativeOnly with get, set

    module OpenDialogOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type filters =
            [<EmitIndexer>]
            abstract member Item: name: string -> ResizeArray<string> with get, set

    module SaveDialogOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type filters =
            [<EmitIndexer>]
            abstract member Item: name: string -> ResizeArray<string> with get, set

    module CodeAction =

        [<Global>]
        [<AllowNullLiteral>]
        type disabled
            [<ParamObject; Emit("$0")>]
            (
                reason: string
            ) =

            member val reason : string = nativeOnly with get

    module CodeActionProviderMetadata =

        [<Global>]
        [<AllowNullLiteral>]
        type documentation
            [<ParamObject; Emit("$0")>]
            (
                kind: CodeActionKind,
                command: Command
            ) =

            member val kind : CodeActionKind = nativeOnly with get
            member val command : Command = nativeOnly with get

    module MarkdownString =

        module isTrusted =

            module U2 =

                [<Global>]
                [<AllowNullLiteral>]
                type Case2
                    [<ParamObject; Emit("$0")>]
                    (
                        enabledCommands: ReadonlyArray<string>
                    ) =

                    member val enabledCommands : ReadonlyArray<string> = nativeOnly with get

    module MarkedString =

        module U2 =

            [<Global>]
            [<AllowNullLiteral>]
            type Case2
                [<ParamObject; Emit("$0")>]
                (
                    language: string,
                    value: string
                ) =

                member val language : string = nativeOnly with get, set
                member val value : string = nativeOnly with get, set

    module NotebookEdit =

        [<AllowNullLiteral>]
        [<Interface>]
        type newCellMetadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

        [<AllowNullLiteral>]
        [<Interface>]
        type newNotebookMetadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

        module updateCellMetadata =

            [<AllowNullLiteral>]
            [<Interface>]
            type newCellMetadata =
                [<EmitIndexer>]
                abstract member Item: key: string -> obj with get, set

        module updateNotebookMetadata =

            [<AllowNullLiteral>]
            [<Interface>]
            type newNotebookMetadata =
                [<EmitIndexer>]
                abstract member Item: key: string -> obj with get, set

    module WorkspaceEdit =

        module createFile =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ?overwrite: bool,
                    ?ignoreIfExists: bool,
                    ?contents: U2<JS.Uint8Array, DataTransferFile>
                ) =

                member val overwrite : bool option = nativeOnly with get
                member val ignoreIfExists : bool option = nativeOnly with get
                member val contents : U2<JS.Uint8Array, DataTransferFile> option = nativeOnly with get

        module deleteFile =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ?``recursive``: bool,
                    ?ignoreIfNotExists: bool
                ) =

                member val ``recursive`` : bool option = nativeOnly with get
                member val ignoreIfNotExists : bool option = nativeOnly with get

        module renameFile =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ?overwrite: bool,
                    ?ignoreIfExists: bool
                ) =

                member val overwrite : bool option = nativeOnly with get
                member val ignoreIfExists : bool option = nativeOnly with get

    module RenameProvider =

        module prepareRename =

            module U2 =

                [<Global>]
                [<AllowNullLiteral>]
                type Case2
                    [<ParamObject; Emit("$0")>]
                    (
                        range: Range,
                        placeholder: string
                    ) =

                    member val range : Range = nativeOnly with get, set
                    member val placeholder : string = nativeOnly with get, set

    module CompletionItem =

        module range =

            module U2 =

                [<Global>]
                [<AllowNullLiteral>]
                type Case2
                    [<ParamObject; Emit("$0")>]
                    (
                        inserting: Range,
                        replacing: Range
                    ) =

                    member val inserting : Range = nativeOnly with get, set
                    member val replacing : Range = nativeOnly with get, set

    module DocumentColorProvider =

        module provideColorPresentations =

            [<Global>]
            [<AllowNullLiteral>]
            type context
                [<ParamObject; Emit("$0")>]
                (
                    document: TextDocument,
                    range: Range
                ) =

                member val document : TextDocument = nativeOnly with get
                member val range : Range = nativeOnly with get

    module LanguageConfiguration =

        [<Global>]
        [<AllowNullLiteral>]
        type __electricCharacterSupport
            [<ParamObject; Emit("$0")>]
            (
                ?brackets: obj,
                ?docComment: LanguageConfiguration.__electricCharacterSupport.docComment
            ) =

            member val brackets : obj option = nativeOnly with get, set
            member val docComment : LanguageConfiguration.__electricCharacterSupport.docComment option = nativeOnly with get, set

        [<Global>]
        [<AllowNullLiteral>]
        type __characterPairSupport
            [<ParamObject; Emit("$0")>]
            (
                autoClosingPairs: ResizeArray<LanguageConfiguration.__characterPairSupport.autoClosingPairs>
            ) =

            member val autoClosingPairs : ResizeArray<LanguageConfiguration.__characterPairSupport.autoClosingPairs> = nativeOnly with get, set

        module __electricCharacterSupport =

            [<Global>]
            [<AllowNullLiteral>]
            type docComment
                [<ParamObject; Emit("$0")>]
                (
                    scope: string,
                    ``open``: string,
                    lineStart: string,
                    ?close: string
                ) =

                member val scope : string = nativeOnly with get, set
                member val ``open`` : string = nativeOnly with get, set
                member val lineStart : string = nativeOnly with get, set
                member val close : string option = nativeOnly with get, set

        module __characterPairSupport =

            [<Global>]
            [<AllowNullLiteral>]
            type autoClosingPairs
                [<ParamObject; Emit("$0")>]
                (
                    ``open``: string,
                    close: string,
                    ?notIn: ResizeArray<string>
                ) =

                member val ``open`` : string = nativeOnly with get, set
                member val close : string = nativeOnly with get, set
                member val notIn : ResizeArray<string> option = nativeOnly with get, set

    module WorkspaceConfiguration =

        [<Global>]
        [<AllowNullLiteral>]
        type inspect<'T>
            [<ParamObject; Emit("$0")>]
            (
                key: string,
                ?defaultValue: 'T,
                ?globalValue: 'T,
                ?workspaceValue: 'T,
                ?workspaceFolderValue: 'T,
                ?defaultLanguageValue: 'T,
                ?globalLanguageValue: 'T,
                ?workspaceLanguageValue: 'T,
                ?workspaceFolderLanguageValue: 'T,
                ?languageIds: ResizeArray<string>
            ) =

            member val key : string = nativeOnly with get, set
            member val defaultValue : 'T option = nativeOnly with get, set
            member val globalValue : 'T option = nativeOnly with get, set
            member val workspaceValue : 'T option = nativeOnly with get, set
            member val workspaceFolderValue : 'T option = nativeOnly with get, set
            member val defaultLanguageValue : 'T option = nativeOnly with get, set
            member val globalLanguageValue : 'T option = nativeOnly with get, set
            member val workspaceLanguageValue : 'T option = nativeOnly with get, set
            member val workspaceFolderLanguageValue : 'T option = nativeOnly with get, set
            member val languageIds : ResizeArray<string> option = nativeOnly with get, set

    module Diagnostic =

        module code =

            module U3 =

                [<Global>]
                [<AllowNullLiteral>]
                type Case3
                    [<ParamObject; Emit("$0")>]
                    (
                        value: U2<string, float>,
                        target: Uri
                    ) =

                    member val value : U2<string, float> = nativeOnly with get, set
                    member val target : Uri = nativeOnly with get, set

    module DiagnosticCollection =

        module forEach =

            type callback =
                delegate of uri: Uri * diagnostics: ReadonlyArray<Diagnostic> * collection: DiagnosticCollection -> obj

    module Terminal =

        module creationOptions =

            module U2 =

                [<AllowNullLiteral>]
                [<Interface>]
                type ReadOnlyTerminalOptions =
                    /// <summary>
                    /// A human-readable string which will be used to represent the terminal in the UI.
                    /// </summary>
                    abstract member name: string option with get
                    /// <summary>
                    /// A path to a custom shell executable to be used in the terminal.
                    /// </summary>
                    abstract member shellPath: string option with get
                    /// <summary>
                    /// Args for the custom shell executable. A string can be used on Windows only which allows
                    /// specifying shell args in [command-line format](https://msdn.microsoft.com/en-au/08dfcab2-eb6e-49a4-80eb-87d4076c98c6).
                    /// </summary>
                    abstract member shellArgs: U2<ResizeArray<string>, string> option with get
                    /// <summary>
                    /// A path or Uri for the current working directory to be used for the terminal.
                    /// </summary>
                    abstract member cwd: U2<string, Uri> option with get
                    /// <summary>
                    /// Object with environment variables that will be added to the editor process.
                    /// </summary>
                    abstract member env: Terminal.creationOptions.U2.ReadOnlyTerminalOptions.TerminalOptions.env option with get
                    /// <summary>
                    /// Whether the terminal process environment should be exactly as provided in
                    /// <c>TerminalOptions.env</c>. When this is false (default), the environment will be based on the
                    /// window's environment and also apply configured platform settings like
                    /// <c>terminal.integrated.env.windows</c> on top. When this is true, the complete environment
                    /// must be provided as nothing will be inherited from the process or any configuration.
                    /// </summary>
                    abstract member strictEnv: bool option with get
                    /// <summary>
                    /// When enabled the terminal will run the process as normal but not be surfaced to the user
                    /// until <c>Terminal.show</c> is called. The typical usage for this is when you need to run
                    /// something that may need interactivity but only want to tell the user about it when
                    /// interaction is needed. Note that the terminals will still be exposed to all extensions
                    /// as normal. The hidden terminals will not be restored when the workspace is next opened.
                    /// </summary>
                    abstract member hideFromUser: bool option with get
                    /// <summary>
                    /// A message to write to the terminal on first launch, note that this is not sent to the
                    /// process but, rather written directly to the terminal. This supports escape sequences such
                    /// a setting text style.
                    /// </summary>
                    abstract member message: string option with get
                    /// <summary>
                    /// The icon path or <see href="ThemeIcon">ThemeIcon</see> for the terminal.
                    /// </summary>
                    abstract member iconPath: IconPath option with get
                    /// <summary>
                    /// The icon <see href="ThemeColor">ThemeColor</see> for the terminal.
                    /// The <c>terminal.ansi*</c> theme keys are
                    /// recommended for the best contrast and consistency across themes.
                    /// </summary>
                    abstract member color: ThemeColor option with get
                    /// <summary>
                    /// The <see href="TerminalLocation">TerminalLocation</see> or <see href="TerminalEditorLocationOptions">TerminalEditorLocationOptions</see> or <see href="TerminalSplitLocationOptions">TerminalSplitLocationOptions</see> for the terminal.
                    /// </summary>
                    abstract member location: U3<TerminalLocation, TerminalEditorLocationOptions, TerminalSplitLocationOptions> option with get
                    /// <summary>
                    /// Opt-out of the default terminal persistence on restart and reload.
                    /// This will only take effect when <c>terminal.integrated.enablePersistentSessions</c> is enabled.
                    /// </summary>
                    abstract member isTransient: bool option with get
                    /// <summary>
                    /// The nonce to use to verify shell integration sequences are coming from a trusted source.
                    /// An example impact of UX of this is if the command line is reported with a nonce, it will
                    /// not need to verify with the user that the command line is correct before rerunning it
                    /// via the [shell integration command decoration](https://code.visualstudio.com/docs/terminal/shell-integration#_command-decorations-and-the-overview-ruler).
                    ///
                    /// This should be used if the terminal includes [custom shell integration support](https://code.visualstudio.com/docs/terminal/shell-integration#_supported-escape-sequences).
                    /// It should be set to a random GUID which will then set the <c>VSCODE_NONCE</c> environment
                    /// variable. Inside the shell, this should then be removed from the environment so as to
                    /// protect it from general access. Once that is done it can be passed through in the
                    /// relevant sequences to make them trusted.
                    /// </summary>
                    abstract member shellIntegrationNonce: string option with get

                [<AllowNullLiteral>]
                [<Interface>]
                type ReadOnlyExtensionTerminalOptions =
                    /// <summary>
                    /// A human-readable string which will be used to represent the terminal in the UI.
                    /// </summary>
                    abstract member name: string with get
                    /// <summary>
                    /// An implementation of <see href="Pseudoterminal">Pseudoterminal</see> that allows an extension to
                    /// control a terminal.
                    /// </summary>
                    abstract member pty: Pseudoterminal with get
                    /// <summary>
                    /// The icon path or <see href="ThemeIcon">ThemeIcon</see> for the terminal.
                    /// </summary>
                    abstract member iconPath: IconPath option with get
                    /// <summary>
                    /// The icon <see href="ThemeColor">ThemeColor</see> for the terminal.
                    /// The standard <c>terminal.ansi*</c> theme keys are
                    /// recommended for the best contrast and consistency across themes.
                    /// </summary>
                    abstract member color: ThemeColor option with get
                    /// <summary>
                    /// The <see href="TerminalLocation">TerminalLocation</see> or <see href="TerminalEditorLocationOptions">TerminalEditorLocationOptions</see> or <see href="TerminalSplitLocationOptions">TerminalSplitLocationOptions</see> for the terminal.
                    /// </summary>
                    abstract member location: U3<TerminalLocation, TerminalEditorLocationOptions, TerminalSplitLocationOptions> option with get
                    /// <summary>
                    /// Opt-out of the default terminal persistence on restart and reload.
                    /// This will only take effect when <c>terminal.integrated.enablePersistentSessions</c> is enabled.
                    /// </summary>
                    abstract member isTransient: bool option with get
                    /// <summary>
                    /// The nonce to use to verify shell integration sequences are coming from a trusted source.
                    /// An example impact of UX of this is if the command line is reported with a nonce, it will
                    /// not need to verify with the user that the command line is correct before rerunning it
                    /// via the [shell integration command decoration](https://code.visualstudio.com/docs/terminal/shell-integration#_command-decorations-and-the-overview-ruler).
                    ///
                    /// This should be used if the terminal includes [custom shell integration support](https://code.visualstudio.com/docs/terminal/shell-integration#_supported-escape-sequences).
                    /// It should be set to a random GUID. Inside the <see href="Pseudoterminal">Pseudoterminal</see> implementation, this value
                    /// can be passed through in the relevant sequences to make them trusted.
                    /// </summary>
                    abstract member shellIntegrationNonce: string option with get

                module ReadOnlyTerminalOptions =

                    module TerminalOptions =

                        [<AllowNullLiteral>]
                        [<Interface>]
                        type env =
                            [<EmitIndexer>]
                            abstract member Item: key: string -> string option with get, set

    module ExtensionContext =

        [<Global>]
        [<AllowNullLiteral>]
        type subscriptions
            [<ParamObject; Emit("$0")>]
            (
                dispose: obj
            ) =

            member val dispose : obj = nativeOnly

    module ProcessExecutionOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type env =
            [<EmitIndexer>]
            abstract member Item: key: string -> string with get, set

    module ShellQuotingOptions =

        module escape =

            module U2 =

                [<Global>]
                [<AllowNullLiteral>]
                type Case2
                    [<ParamObject; Emit("$0")>]
                    (
                        escapeChar: string,
                        charsToEscape: string
                    ) =

                    member val escapeChar : string = nativeOnly with get, set
                    member val charsToEscape : string = nativeOnly with get, set

    module ShellExecutionOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type env =
            [<EmitIndexer>]
            abstract member Item: key: string -> string with get, set

    module FileSystemProvider =

        module watch =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ``recursive``: bool,
                    excludes: ReadonlyArray<string>
                ) =

                member val ``recursive`` : bool = nativeOnly with get
                member val excludes : ReadonlyArray<string> = nativeOnly with get

        module writeFile =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    create: bool,
                    overwrite: bool
                ) =

                member val create : bool = nativeOnly with get
                member val overwrite : bool = nativeOnly with get

        module delete =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ``recursive``: bool
                ) =

                member val ``recursive`` : bool = nativeOnly with get

        module rename =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    overwrite: bool
                ) =

                member val overwrite : bool = nativeOnly with get

        module copy =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    overwrite: bool
                ) =

                member val overwrite : bool = nativeOnly with get

    module FileSystem =

        module delete =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ?``recursive``: bool,
                    ?useTrash: bool
                ) =

                member val ``recursive`` : bool option = nativeOnly with get, set
                member val useTrash : bool option = nativeOnly with get, set

        module rename =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ?overwrite: bool
                ) =

                member val overwrite : bool option = nativeOnly with get, set

        module copy =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ?overwrite: bool
                ) =

                member val overwrite : bool option = nativeOnly with get, set

    module DataTransfer =

        module forEach =

            type callbackfn =
                delegate of item: DataTransferItem * mimeType: string * dataTransfer: DataTransfer -> unit

    module TreeView =

        module reveal =

            [<Global>]
            [<AllowNullLiteral>]
            type options
                [<ParamObject; Emit("$0")>]
                (
                    ?select: bool,
                    ?focus: bool,
                    ?expand: U2<bool, float>
                ) =

                member val select : bool option = nativeOnly with get
                member val focus : bool option = nativeOnly with get
                member val expand : U2<bool, float> option = nativeOnly with get

    module TreeItem =

        module checkboxState =

            module U2 =

                [<Global>]
                [<AllowNullLiteral>]
                type Case2
                    [<ParamObject; Emit("$0")>]
                    (
                        state: TreeItemCheckboxState,
                        ?tooltip: string,
                        ?accessibilityInformation: AccessibilityInformation
                    ) =

                    member val state : TreeItemCheckboxState = nativeOnly with get
                    member val tooltip : string option = nativeOnly with get
                    member val accessibilityInformation : AccessibilityInformation option = nativeOnly with get

    module TerminalOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type env =
            [<EmitIndexer>]
            abstract member Item: key: string -> string option with get, set

    module EnvironmentVariableCollection =

        module forEach =

            type callback =
                delegate of variable: string * mutator: EnvironmentVariableMutator * collection: EnvironmentVariableCollection -> obj

    module ProgressOptions =

        module location =

            module U2 =

                [<Global>]
                [<AllowNullLiteral>]
                type Case2
                    [<ParamObject; Emit("$0")>]
                    (
                        viewId: string
                    ) =

                    member val viewId : string = nativeOnly with get, set

    module QuickInputButton =

        [<Global>]
        [<AllowNullLiteral>]
        type toggle
            [<ParamObject; Emit("$0")>]
            (
                ``checked``: bool
            ) =

            member val ``checked`` : bool = nativeOnly with get, set

    module FileWillRenameEvent =

        [<Global>]
        [<AllowNullLiteral>]
        type files
            [<ParamObject; Emit("$0")>]
            (
                oldUri: Uri,
                newUri: Uri
            ) =

            member val oldUri : Uri = nativeOnly with get
            member val newUri : Uri = nativeOnly with get

    module FileRenameEvent =

        [<Global>]
        [<AllowNullLiteral>]
        type files
            [<ParamObject; Emit("$0")>]
            (
                oldUri: Uri,
                newUri: Uri
            ) =

            member val oldUri : Uri = nativeOnly with get
            member val newUri : Uri = nativeOnly with get

    module ConfigurationScope =

        module U4 =

            [<Global>]
            [<AllowNullLiteral>]
            type Case4
                [<ParamObject; Emit("$0")>]
                (
                    languageId: string,
                    ?uri: Uri
                ) =

                member val languageId : string = nativeOnly with get, set
                member val uri : Uri option = nativeOnly with get, set

    module NotebookRendererMessaging =

        [<Global>]
        [<AllowNullLiteral>]
        type onDidReceiveMessage
            [<ParamObject; Emit("$0")>]
            (
                editor: NotebookEditor,
                message: obj
            ) =

            member val editor : NotebookEditor = nativeOnly with get
            member val message : obj = nativeOnly with get

    module NotebookCell =

        [<AllowNullLiteral>]
        [<Interface>]
        type metadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get

    module NotebookDocument =

        [<AllowNullLiteral>]
        [<Interface>]
        type metadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

    module NotebookDocumentCellChange =

        [<AllowNullLiteral>]
        [<Interface>]
        type metadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

    module NotebookDocumentChangeEvent =

        [<AllowNullLiteral>]
        [<Interface>]
        type metadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

    module NotebookCellExecutionSummary =

        [<Global>]
        [<AllowNullLiteral>]
        type timing
            [<ParamObject; Emit("$0")>]
            (
                startTime: float,
                endTime: float
            ) =

            member val startTime : float = nativeOnly with get
            member val endTime : float = nativeOnly with get

    module NotebookRange =

        module ``with`` =

            [<Global>]
            [<AllowNullLiteral>]
            type change
                [<ParamObject; Emit("$0")>]
                (
                    ?start: float,
                    ?``end``: float
                ) =

                member val start : float option = nativeOnly with get, set
                member val ``end`` : float option = nativeOnly with get, set

    module NotebookCellOutput =

        [<AllowNullLiteral>]
        [<Interface>]
        type metadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

    module NotebookCellData =

        [<AllowNullLiteral>]
        [<Interface>]
        type metadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

    module NotebookData =

        [<AllowNullLiteral>]
        [<Interface>]
        type metadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

    module NotebookDocumentContentOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type transientCellMetadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> bool option with get, set

        [<AllowNullLiteral>]
        [<Interface>]
        type transientDocumentMetadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> bool option with get, set

    module NotebookController =

        type executeHandler =
            delegate of cells: ResizeArray<NotebookCell> * notebook: NotebookDocument * controller: NotebookController -> U2<unit, Thenable<unit>>

        [<Global>]
        [<AllowNullLiteral>]
        type onDidChangeSelectedNotebooks
            [<ParamObject; Emit("$0")>]
            (
                notebook: NotebookDocument,
                selected: bool
            ) =

            member val notebook : NotebookDocument = nativeOnly with get
            member val selected : bool = nativeOnly with get

    module DebugAdapterExecutableOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type env =
            [<EmitIndexer>]
            abstract member Item: key: string -> string with get, set

    module CommentController =

        type reactionHandler =
            delegate of comment: Comment * reaction: CommentReaction -> Thenable<unit>

    module TestRunProfile =

        type runHandler =
            delegate of request: TestRunRequest * token: CancellationToken -> U2<Thenable<unit>, unit>

        type loadDetailedCoverage =
            delegate of testRun: TestRun * fileCoverage: FileCoverage * token: CancellationToken -> Thenable<ResizeArray<FileCoverageDetail>>

        type loadDetailedCoverageForTest =
            delegate of testRun: TestRun * fileCoverage: FileCoverage * fromTestItem: TestItem * token: CancellationToken -> Thenable<ResizeArray<FileCoverageDetail>>

    module TestController =

        module createRunProfile =

            type runHandler =
                delegate of request: TestRunRequest * token: CancellationToken -> U2<Thenable<unit>, unit>

    module TestItemCollection =

        module forEach =

            type callback =
                delegate of item: TestItem * collection: TestItemCollection -> obj

    module TelemetryLogger =

        module logUsage =

            [<AllowNullLiteral>]
            [<Interface>]
            type data =
                [<EmitIndexer>]
                abstract member Item: key: string -> U2<obj, TelemetryTrustedValue> with get, set

        module logError =

            [<AllowNullLiteral>]
            [<Interface>]
            type data =
                [<EmitIndexer>]
                abstract member Item: key: string -> U2<obj, TelemetryTrustedValue> with get, set

            [<AllowNullLiteral>]
            [<Interface>]
            type data_1 =
                [<EmitIndexer>]
                abstract member Item: key: string -> U2<obj, TelemetryTrustedValue> with get, set

    module TelemetrySender =

        module sendEventData =

            [<AllowNullLiteral>]
            [<Interface>]
            type data =
                [<EmitIndexer>]
                abstract member Item: key: string -> obj with get, set

        module sendErrorData =

            [<AllowNullLiteral>]
            [<Interface>]
            type data =
                [<EmitIndexer>]
                abstract member Item: key: string -> obj with get, set

    module TelemetryLoggerOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type additionalCommonProperties =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get, set

    module ChatResult =

        [<AllowNullLiteral>]
        [<Interface>]
        type metadata =
            [<EmitIndexer>]
            abstract member Item: key: string -> obj with get

    module LanguageModelChatRequestOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type modelOptions =
            [<EmitIndexer>]
            abstract member Item: name: string -> obj with get, set

    module McpStdioServerDefinition =

        [<AllowNullLiteral>]
        [<Interface>]
        type env =
            [<EmitIndexer>]
            abstract member Item: key: string -> U2<string, float> option with get, set

    module McpHttpServerDefinition =

        [<AllowNullLiteral>]
        [<Interface>]
        type headers =
            [<EmitIndexer>]
            abstract member Item: key: string -> string with get, set

    module ProvideLanguageModelChatResponseOptions =

        [<AllowNullLiteral>]
        [<Interface>]
        type modelOptions =
            [<EmitIndexer>]
            abstract member Item: name: string -> obj with get

    module Exports =

        module NotebookCellOutput =

            [<AllowNullLiteral>]
            [<Interface>]
            type metadata =
                [<EmitIndexer>]
                abstract member Item: key: string -> obj with get, set

        module McpStdioServerDefinition =

            [<AllowNullLiteral>]
            [<Interface>]
            type env =
                [<EmitIndexer>]
                abstract member Item: key: string -> U2<string, float> option with get, set

        module McpHttpServerDefinition =

            [<AllowNullLiteral>]
            [<Interface>]
            type headers =
                [<EmitIndexer>]
                abstract member Item: key: string -> string with get, set

/// Thenable is a common denominator between ES6 promises, Q, jquery.Deferred, WinJS.Promise,
/// and others. This API makes no assumption about what promise library is being used which
/// enables reusing existing code without migrating to a specific promise implementation. Still,
/// we recommend the use of native promises which are available in this editor.
[<AllowNullLiteral>]
[<Interface>]
type Thenable<'T> =
    /// <summary>Attaches callbacks for the resolution and/or rejection of the Promise.</summary>
    /// <param name="onfulfilled">The callback to execute when the Promise is resolved.</param>
    /// <param name="onrejected">The callback to execute when the Promise is rejected.</param>
    /// <returns>A Promise for the completion of which ever callback is executed.</returns>
    abstract ``then``: ?onfulfilled: ('T -> U2<'TResult, Thenable<'TResult>>) * ?onrejected: (obj option -> U2<'TResult, Thenable<'TResult>>) -> Thenable<'TResult>
    abstract ``then``: ?onfulfilled: ('T -> U2<'TResult, Thenable<'TResult>>) * ?onrejected: (obj option -> unit) -> Thenable<'TResult>
